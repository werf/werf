// Code generated by MockGen. DO NOT EDIT.
// Source: git_repo.go
//
// Generated by this command:
//
//	mockgen -source git_repo.go -package mock -destination ../../test/mock/git_repo.go
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"

	git_repo "github.com/werf/werf/v2/pkg/git_repo"
	repo_handle "github.com/werf/werf/v2/pkg/git_repo/repo_handle"
	path_matcher "github.com/werf/werf/v2/pkg/path_matcher"
	ls_tree "github.com/werf/werf/v2/pkg/true_git/ls_tree"
)

// MockGitRepo is a mock of GitRepo interface.
type MockGitRepo struct {
	ctrl     *gomock.Controller
	recorder *MockGitRepoMockRecorder
	isgomock struct{}
}

// MockGitRepoMockRecorder is the mock recorder for MockGitRepo.
type MockGitRepoMockRecorder struct {
	mock *MockGitRepo
}

// NewMockGitRepo creates a new mock instance.
func NewMockGitRepo(ctrl *gomock.Controller) *MockGitRepo {
	mock := &MockGitRepo{ctrl: ctrl}
	mock.recorder = &MockGitRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGitRepo) EXPECT() *MockGitRepoMockRecorder {
	return m.recorder
}

// AreSubmoduleCommitsValid mocks base method.
func (m *MockGitRepo) AreSubmoduleCommitsValid(ctx context.Context, commit string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AreSubmoduleCommitsValid", ctx, commit)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AreSubmoduleCommitsValid indicates an expected call of AreSubmoduleCommitsValid.
func (mr *MockGitRepoMockRecorder) AreSubmoduleCommitsValid(ctx, commit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AreSubmoduleCommitsValid", reflect.TypeOf((*MockGitRepo)(nil).AreSubmoduleCommitsValid), ctx, commit)
}

// CreateDetachedMergeCommit mocks base method.
func (m *MockGitRepo) CreateDetachedMergeCommit(ctx context.Context, fromCommit, toCommit string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateDetachedMergeCommit", ctx, fromCommit, toCommit)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateDetachedMergeCommit indicates an expected call of CreateDetachedMergeCommit.
func (mr *MockGitRepoMockRecorder) CreateDetachedMergeCommit(ctx, fromCommit, toCommit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateDetachedMergeCommit", reflect.TypeOf((*MockGitRepo)(nil).CreateDetachedMergeCommit), ctx, fromCommit, toCommit)
}

// FetchOrigin mocks base method.
func (m *MockGitRepo) FetchOrigin(ctx context.Context, opts git_repo.FetchOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchOrigin", ctx, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// FetchOrigin indicates an expected call of FetchOrigin.
func (mr *MockGitRepoMockRecorder) FetchOrigin(ctx, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchOrigin", reflect.TypeOf((*MockGitRepo)(nil).FetchOrigin), ctx, opts)
}

// GetCommitTreeEntry mocks base method.
func (m *MockGitRepo) GetCommitTreeEntry(ctx context.Context, commit, path string) (*ls_tree.LsTreeEntry, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommitTreeEntry", ctx, commit, path)
	ret0, _ := ret[0].(*ls_tree.LsTreeEntry)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCommitTreeEntry indicates an expected call of GetCommitTreeEntry.
func (mr *MockGitRepoMockRecorder) GetCommitTreeEntry(ctx, commit, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommitTreeEntry", reflect.TypeOf((*MockGitRepo)(nil).GetCommitTreeEntry), ctx, commit, path)
}

// GetMergeCommitParents mocks base method.
func (m *MockGitRepo) GetMergeCommitParents(ctx context.Context, commit string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMergeCommitParents", ctx, commit)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMergeCommitParents indicates an expected call of GetMergeCommitParents.
func (mr *MockGitRepoMockRecorder) GetMergeCommitParents(ctx, commit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMergeCommitParents", reflect.TypeOf((*MockGitRepo)(nil).GetMergeCommitParents), ctx, commit)
}

// GetName mocks base method.
func (m *MockGitRepo) GetName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetName")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetName indicates an expected call of GetName.
func (mr *MockGitRepoMockRecorder) GetName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetName", reflect.TypeOf((*MockGitRepo)(nil).GetName))
}

// GetOrCreateArchive mocks base method.
func (m *MockGitRepo) GetOrCreateArchive(ctx context.Context, opts git_repo.ArchiveOptions) (git_repo.Archive, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreateArchive", ctx, opts)
	ret0, _ := ret[0].(git_repo.Archive)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrCreateArchive indicates an expected call of GetOrCreateArchive.
func (mr *MockGitRepoMockRecorder) GetOrCreateArchive(ctx, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateArchive", reflect.TypeOf((*MockGitRepo)(nil).GetOrCreateArchive), ctx, opts)
}

// GetOrCreateChecksum mocks base method.
func (m *MockGitRepo) GetOrCreateChecksum(ctx context.Context, opts git_repo.ChecksumOptions) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreateChecksum", ctx, opts)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrCreateChecksum indicates an expected call of GetOrCreateChecksum.
func (mr *MockGitRepoMockRecorder) GetOrCreateChecksum(ctx, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateChecksum", reflect.TypeOf((*MockGitRepo)(nil).GetOrCreateChecksum), ctx, opts)
}

// GetOrCreatePatch mocks base method.
func (m *MockGitRepo) GetOrCreatePatch(ctx context.Context, opts git_repo.PatchOptions) (git_repo.Patch, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreatePatch", ctx, opts)
	ret0, _ := ret[0].(git_repo.Patch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrCreatePatch indicates an expected call of GetOrCreatePatch.
func (mr *MockGitRepoMockRecorder) GetOrCreatePatch(ctx, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreatePatch", reflect.TypeOf((*MockGitRepo)(nil).GetOrCreatePatch), ctx, opts)
}

// GetWorkTreeDir mocks base method.
func (m *MockGitRepo) GetWorkTreeDir() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkTreeDir")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetWorkTreeDir indicates an expected call of GetWorkTreeDir.
func (mr *MockGitRepoMockRecorder) GetWorkTreeDir() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkTreeDir", reflect.TypeOf((*MockGitRepo)(nil).GetWorkTreeDir))
}

// HeadCommitHash mocks base method.
func (m *MockGitRepo) HeadCommitHash(ctx context.Context) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HeadCommitHash", ctx)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HeadCommitHash indicates an expected call of HeadCommitHash.
func (mr *MockGitRepoMockRecorder) HeadCommitHash(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HeadCommitHash", reflect.TypeOf((*MockGitRepo)(nil).HeadCommitHash), ctx)
}

// HeadCommitTime mocks base method.
func (m *MockGitRepo) HeadCommitTime(ctx context.Context) (*time.Time, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HeadCommitTime", ctx)
	ret0, _ := ret[0].(*time.Time)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HeadCommitTime indicates an expected call of HeadCommitTime.
func (mr *MockGitRepoMockRecorder) HeadCommitTime(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HeadCommitTime", reflect.TypeOf((*MockGitRepo)(nil).HeadCommitTime), ctx)
}

// IsAncestor mocks base method.
func (m *MockGitRepo) IsAncestor(ctx context.Context, ancestorCommit, descendantCommit string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsAncestor", ctx, ancestorCommit, descendantCommit)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsAncestor indicates an expected call of IsAncestor.
func (mr *MockGitRepoMockRecorder) IsAncestor(ctx, ancestorCommit, descendantCommit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAncestor", reflect.TypeOf((*MockGitRepo)(nil).IsAncestor), ctx, ancestorCommit, descendantCommit)
}

// IsAnyCommitTreeEntriesMatched mocks base method.
func (m *MockGitRepo) IsAnyCommitTreeEntriesMatched(ctx context.Context, commit, pathScope string, pathMatcher path_matcher.PathMatcher, allFiles bool) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsAnyCommitTreeEntriesMatched", ctx, commit, pathScope, pathMatcher, allFiles)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsAnyCommitTreeEntriesMatched indicates an expected call of IsAnyCommitTreeEntriesMatched.
func (mr *MockGitRepoMockRecorder) IsAnyCommitTreeEntriesMatched(ctx, commit, pathScope, pathMatcher, allFiles any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAnyCommitTreeEntriesMatched", reflect.TypeOf((*MockGitRepo)(nil).IsAnyCommitTreeEntriesMatched), ctx, commit, pathScope, pathMatcher, allFiles)
}

// IsCommitDirectoryExist mocks base method.
func (m *MockGitRepo) IsCommitDirectoryExist(ctx context.Context, commit, path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCommitDirectoryExist", ctx, commit, path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCommitDirectoryExist indicates an expected call of IsCommitDirectoryExist.
func (mr *MockGitRepoMockRecorder) IsCommitDirectoryExist(ctx, commit, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCommitDirectoryExist", reflect.TypeOf((*MockGitRepo)(nil).IsCommitDirectoryExist), ctx, commit, path)
}

// IsCommitExists mocks base method.
func (m *MockGitRepo) IsCommitExists(ctx context.Context, commit string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCommitExists", ctx, commit)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCommitExists indicates an expected call of IsCommitExists.
func (mr *MockGitRepoMockRecorder) IsCommitExists(ctx, commit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCommitExists", reflect.TypeOf((*MockGitRepo)(nil).IsCommitExists), ctx, commit)
}

// IsCommitFileExist mocks base method.
func (m *MockGitRepo) IsCommitFileExist(ctx context.Context, commit, path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCommitFileExist", ctx, commit, path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCommitFileExist indicates an expected call of IsCommitFileExist.
func (mr *MockGitRepoMockRecorder) IsCommitFileExist(ctx, commit, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCommitFileExist", reflect.TypeOf((*MockGitRepo)(nil).IsCommitFileExist), ctx, commit, path)
}

// IsCommitTreeEntryDirectory mocks base method.
func (m *MockGitRepo) IsCommitTreeEntryDirectory(ctx context.Context, commit, relPath string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCommitTreeEntryDirectory", ctx, commit, relPath)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCommitTreeEntryDirectory indicates an expected call of IsCommitTreeEntryDirectory.
func (mr *MockGitRepoMockRecorder) IsCommitTreeEntryDirectory(ctx, commit, relPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCommitTreeEntryDirectory", reflect.TypeOf((*MockGitRepo)(nil).IsCommitTreeEntryDirectory), ctx, commit, relPath)
}

// IsCommitTreeEntryExist mocks base method.
func (m *MockGitRepo) IsCommitTreeEntryExist(ctx context.Context, commit, relPath string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCommitTreeEntryExist", ctx, commit, relPath)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCommitTreeEntryExist indicates an expected call of IsCommitTreeEntryExist.
func (mr *MockGitRepoMockRecorder) IsCommitTreeEntryExist(ctx, commit, relPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCommitTreeEntryExist", reflect.TypeOf((*MockGitRepo)(nil).IsCommitTreeEntryExist), ctx, commit, relPath)
}

// IsEmpty mocks base method.
func (m *MockGitRepo) IsEmpty(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsEmpty indicates an expected call of IsEmpty.
func (mr *MockGitRepoMockRecorder) IsEmpty(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*MockGitRepo)(nil).IsEmpty), ctx)
}

// IsLocal mocks base method.
func (m *MockGitRepo) IsLocal() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLocal")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsLocal indicates an expected call of IsLocal.
func (mr *MockGitRepoMockRecorder) IsLocal() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLocal", reflect.TypeOf((*MockGitRepo)(nil).IsLocal))
}

// IsShallowClone mocks base method.
func (m *MockGitRepo) IsShallowClone(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsShallowClone", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsShallowClone indicates an expected call of IsShallowClone.
func (mr *MockGitRepoMockRecorder) IsShallowClone(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsShallowClone", reflect.TypeOf((*MockGitRepo)(nil).IsShallowClone), ctx)
}

// LatestBranchCommit mocks base method.
func (m *MockGitRepo) LatestBranchCommit(ctx context.Context, branch string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LatestBranchCommit", ctx, branch)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LatestBranchCommit indicates an expected call of LatestBranchCommit.
func (mr *MockGitRepoMockRecorder) LatestBranchCommit(ctx, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LatestBranchCommit", reflect.TypeOf((*MockGitRepo)(nil).LatestBranchCommit), ctx, branch)
}

// ListCommitFilesWithGlob mocks base method.
func (m *MockGitRepo) ListCommitFilesWithGlob(ctx context.Context, commit, dir, glob string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCommitFilesWithGlob", ctx, commit, dir, glob)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCommitFilesWithGlob indicates an expected call of ListCommitFilesWithGlob.
func (mr *MockGitRepoMockRecorder) ListCommitFilesWithGlob(ctx, commit, dir, glob any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCommitFilesWithGlob", reflect.TypeOf((*MockGitRepo)(nil).ListCommitFilesWithGlob), ctx, commit, dir, glob)
}

// ReadCommitFile mocks base method.
func (m *MockGitRepo) ReadCommitFile(ctx context.Context, commit, path string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadCommitFile", ctx, commit, path)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadCommitFile indicates an expected call of ReadCommitFile.
func (mr *MockGitRepoMockRecorder) ReadCommitFile(ctx, commit, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadCommitFile", reflect.TypeOf((*MockGitRepo)(nil).ReadCommitFile), ctx, commit, path)
}

// ReadCommitTreeEntryContent mocks base method.
func (m *MockGitRepo) ReadCommitTreeEntryContent(ctx context.Context, commit, relPath string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadCommitTreeEntryContent", ctx, commit, relPath)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadCommitTreeEntryContent indicates an expected call of ReadCommitTreeEntryContent.
func (mr *MockGitRepoMockRecorder) ReadCommitTreeEntryContent(ctx, commit, relPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadCommitTreeEntryContent", reflect.TypeOf((*MockGitRepo)(nil).ReadCommitTreeEntryContent), ctx, commit, relPath)
}

// RemoteOriginUrl mocks base method.
func (m *MockGitRepo) RemoteOriginUrl(arg0 context.Context) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoteOriginUrl", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemoteOriginUrl indicates an expected call of RemoteOriginUrl.
func (mr *MockGitRepoMockRecorder) RemoteOriginUrl(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoteOriginUrl", reflect.TypeOf((*MockGitRepo)(nil).RemoteOriginUrl), arg0)
}

// ResolveAndCheckCommitFilePath mocks base method.
func (m *MockGitRepo) ResolveAndCheckCommitFilePath(ctx context.Context, commit, path string, checkSymlinkTargetFunc func(string) error) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveAndCheckCommitFilePath", ctx, commit, path, checkSymlinkTargetFunc)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveAndCheckCommitFilePath indicates an expected call of ResolveAndCheckCommitFilePath.
func (mr *MockGitRepoMockRecorder) ResolveAndCheckCommitFilePath(ctx, commit, path, checkSymlinkTargetFunc any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveAndCheckCommitFilePath", reflect.TypeOf((*MockGitRepo)(nil).ResolveAndCheckCommitFilePath), ctx, commit, path, checkSymlinkTargetFunc)
}

// ResolveCommitFilePath mocks base method.
func (m *MockGitRepo) ResolveCommitFilePath(ctx context.Context, commit, path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveCommitFilePath", ctx, commit, path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveCommitFilePath indicates an expected call of ResolveCommitFilePath.
func (mr *MockGitRepoMockRecorder) ResolveCommitFilePath(ctx, commit, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveCommitFilePath", reflect.TypeOf((*MockGitRepo)(nil).ResolveCommitFilePath), ctx, commit, path)
}

// StatusPathList mocks base method.
func (m *MockGitRepo) StatusPathList(ctx context.Context, pathMatcher path_matcher.PathMatcher) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StatusPathList", ctx, pathMatcher)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StatusPathList indicates an expected call of StatusPathList.
func (mr *MockGitRepoMockRecorder) StatusPathList(ctx, pathMatcher any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StatusPathList", reflect.TypeOf((*MockGitRepo)(nil).StatusPathList), ctx, pathMatcher)
}

// String mocks base method.
func (m *MockGitRepo) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockGitRepoMockRecorder) String() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockGitRepo)(nil).String))
}

// SyncWithOrigin mocks base method.
func (m *MockGitRepo) SyncWithOrigin(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SyncWithOrigin", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// SyncWithOrigin indicates an expected call of SyncWithOrigin.
func (mr *MockGitRepoMockRecorder) SyncWithOrigin(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SyncWithOrigin", reflect.TypeOf((*MockGitRepo)(nil).SyncWithOrigin), ctx)
}

// TagCommit mocks base method.
func (m *MockGitRepo) TagCommit(ctx context.Context, tag string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TagCommit", ctx, tag)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TagCommit indicates an expected call of TagCommit.
func (mr *MockGitRepoMockRecorder) TagCommit(ctx, tag any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TagCommit", reflect.TypeOf((*MockGitRepo)(nil).TagCommit), ctx, tag)
}

// Unshallow mocks base method.
func (m *MockGitRepo) Unshallow(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unshallow", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unshallow indicates an expected call of Unshallow.
func (mr *MockGitRepoMockRecorder) Unshallow(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unshallow", reflect.TypeOf((*MockGitRepo)(nil).Unshallow), ctx)
}

// ValidateStatusResult mocks base method.
func (m *MockGitRepo) ValidateStatusResult(ctx context.Context, pathMatcher path_matcher.PathMatcher) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateStatusResult", ctx, pathMatcher)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateStatusResult indicates an expected call of ValidateStatusResult.
func (mr *MockGitRepoMockRecorder) ValidateStatusResult(ctx, pathMatcher any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateStatusResult", reflect.TypeOf((*MockGitRepo)(nil).ValidateStatusResult), ctx, pathMatcher)
}

// WalkCommitFiles mocks base method.
func (m *MockGitRepo) WalkCommitFiles(ctx context.Context, commit, dir string, pathMatcher path_matcher.PathMatcher, fileFunc func(string) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WalkCommitFiles", ctx, commit, dir, pathMatcher, fileFunc)
	ret0, _ := ret[0].(error)
	return ret0
}

// WalkCommitFiles indicates an expected call of WalkCommitFiles.
func (mr *MockGitRepoMockRecorder) WalkCommitFiles(ctx, commit, dir, pathMatcher, fileFunc any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalkCommitFiles", reflect.TypeOf((*MockGitRepo)(nil).WalkCommitFiles), ctx, commit, dir, pathMatcher, fileFunc)
}

// MockgitRepo is a mock of gitRepo interface.
type MockgitRepo struct {
	ctrl     *gomock.Controller
	recorder *MockgitRepoMockRecorder
	isgomock struct{}
}

// MockgitRepoMockRecorder is the mock recorder for MockgitRepo.
type MockgitRepoMockRecorder struct {
	mock *MockgitRepo
}

// NewMockgitRepo creates a new mock instance.
func NewMockgitRepo(ctrl *gomock.Controller) *MockgitRepo {
	mock := &MockgitRepo{ctrl: ctrl}
	mock.recorder = &MockgitRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockgitRepo) EXPECT() *MockgitRepoMockRecorder {
	return m.recorder
}

// AreSubmoduleCommitsValid mocks base method.
func (m *MockgitRepo) AreSubmoduleCommitsValid(ctx context.Context, commit string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AreSubmoduleCommitsValid", ctx, commit)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AreSubmoduleCommitsValid indicates an expected call of AreSubmoduleCommitsValid.
func (mr *MockgitRepoMockRecorder) AreSubmoduleCommitsValid(ctx, commit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AreSubmoduleCommitsValid", reflect.TypeOf((*MockgitRepo)(nil).AreSubmoduleCommitsValid), ctx, commit)
}

// CreateDetachedMergeCommit mocks base method.
func (m *MockgitRepo) CreateDetachedMergeCommit(ctx context.Context, fromCommit, toCommit string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateDetachedMergeCommit", ctx, fromCommit, toCommit)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateDetachedMergeCommit indicates an expected call of CreateDetachedMergeCommit.
func (mr *MockgitRepoMockRecorder) CreateDetachedMergeCommit(ctx, fromCommit, toCommit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateDetachedMergeCommit", reflect.TypeOf((*MockgitRepo)(nil).CreateDetachedMergeCommit), ctx, fromCommit, toCommit)
}

// FetchOrigin mocks base method.
func (m *MockgitRepo) FetchOrigin(ctx context.Context, opts git_repo.FetchOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchOrigin", ctx, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// FetchOrigin indicates an expected call of FetchOrigin.
func (mr *MockgitRepoMockRecorder) FetchOrigin(ctx, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchOrigin", reflect.TypeOf((*MockgitRepo)(nil).FetchOrigin), ctx, opts)
}

// GetCommitTreeEntry mocks base method.
func (m *MockgitRepo) GetCommitTreeEntry(ctx context.Context, commit, path string) (*ls_tree.LsTreeEntry, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommitTreeEntry", ctx, commit, path)
	ret0, _ := ret[0].(*ls_tree.LsTreeEntry)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCommitTreeEntry indicates an expected call of GetCommitTreeEntry.
func (mr *MockgitRepoMockRecorder) GetCommitTreeEntry(ctx, commit, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommitTreeEntry", reflect.TypeOf((*MockgitRepo)(nil).GetCommitTreeEntry), ctx, commit, path)
}

// GetMergeCommitParents mocks base method.
func (m *MockgitRepo) GetMergeCommitParents(ctx context.Context, commit string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMergeCommitParents", ctx, commit)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMergeCommitParents indicates an expected call of GetMergeCommitParents.
func (mr *MockgitRepoMockRecorder) GetMergeCommitParents(ctx, commit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMergeCommitParents", reflect.TypeOf((*MockgitRepo)(nil).GetMergeCommitParents), ctx, commit)
}

// GetName mocks base method.
func (m *MockgitRepo) GetName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetName")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetName indicates an expected call of GetName.
func (mr *MockgitRepoMockRecorder) GetName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetName", reflect.TypeOf((*MockgitRepo)(nil).GetName))
}

// GetOrCreateArchive mocks base method.
func (m *MockgitRepo) GetOrCreateArchive(ctx context.Context, opts git_repo.ArchiveOptions) (git_repo.Archive, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreateArchive", ctx, opts)
	ret0, _ := ret[0].(git_repo.Archive)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrCreateArchive indicates an expected call of GetOrCreateArchive.
func (mr *MockgitRepoMockRecorder) GetOrCreateArchive(ctx, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateArchive", reflect.TypeOf((*MockgitRepo)(nil).GetOrCreateArchive), ctx, opts)
}

// GetOrCreateChecksum mocks base method.
func (m *MockgitRepo) GetOrCreateChecksum(ctx context.Context, opts git_repo.ChecksumOptions) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreateChecksum", ctx, opts)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrCreateChecksum indicates an expected call of GetOrCreateChecksum.
func (mr *MockgitRepoMockRecorder) GetOrCreateChecksum(ctx, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateChecksum", reflect.TypeOf((*MockgitRepo)(nil).GetOrCreateChecksum), ctx, opts)
}

// GetOrCreatePatch mocks base method.
func (m *MockgitRepo) GetOrCreatePatch(ctx context.Context, opts git_repo.PatchOptions) (git_repo.Patch, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreatePatch", ctx, opts)
	ret0, _ := ret[0].(git_repo.Patch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrCreatePatch indicates an expected call of GetOrCreatePatch.
func (mr *MockgitRepoMockRecorder) GetOrCreatePatch(ctx, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreatePatch", reflect.TypeOf((*MockgitRepo)(nil).GetOrCreatePatch), ctx, opts)
}

// GetWorkTreeDir mocks base method.
func (m *MockgitRepo) GetWorkTreeDir() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkTreeDir")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetWorkTreeDir indicates an expected call of GetWorkTreeDir.
func (mr *MockgitRepoMockRecorder) GetWorkTreeDir() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkTreeDir", reflect.TypeOf((*MockgitRepo)(nil).GetWorkTreeDir))
}

// HeadCommitHash mocks base method.
func (m *MockgitRepo) HeadCommitHash(ctx context.Context) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HeadCommitHash", ctx)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HeadCommitHash indicates an expected call of HeadCommitHash.
func (mr *MockgitRepoMockRecorder) HeadCommitHash(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HeadCommitHash", reflect.TypeOf((*MockgitRepo)(nil).HeadCommitHash), ctx)
}

// HeadCommitTime mocks base method.
func (m *MockgitRepo) HeadCommitTime(ctx context.Context) (*time.Time, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HeadCommitTime", ctx)
	ret0, _ := ret[0].(*time.Time)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HeadCommitTime indicates an expected call of HeadCommitTime.
func (mr *MockgitRepoMockRecorder) HeadCommitTime(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HeadCommitTime", reflect.TypeOf((*MockgitRepo)(nil).HeadCommitTime), ctx)
}

// IsAncestor mocks base method.
func (m *MockgitRepo) IsAncestor(ctx context.Context, ancestorCommit, descendantCommit string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsAncestor", ctx, ancestorCommit, descendantCommit)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsAncestor indicates an expected call of IsAncestor.
func (mr *MockgitRepoMockRecorder) IsAncestor(ctx, ancestorCommit, descendantCommit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAncestor", reflect.TypeOf((*MockgitRepo)(nil).IsAncestor), ctx, ancestorCommit, descendantCommit)
}

// IsAnyCommitTreeEntriesMatched mocks base method.
func (m *MockgitRepo) IsAnyCommitTreeEntriesMatched(ctx context.Context, commit, pathScope string, pathMatcher path_matcher.PathMatcher, allFiles bool) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsAnyCommitTreeEntriesMatched", ctx, commit, pathScope, pathMatcher, allFiles)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsAnyCommitTreeEntriesMatched indicates an expected call of IsAnyCommitTreeEntriesMatched.
func (mr *MockgitRepoMockRecorder) IsAnyCommitTreeEntriesMatched(ctx, commit, pathScope, pathMatcher, allFiles any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAnyCommitTreeEntriesMatched", reflect.TypeOf((*MockgitRepo)(nil).IsAnyCommitTreeEntriesMatched), ctx, commit, pathScope, pathMatcher, allFiles)
}

// IsCommitDirectoryExist mocks base method.
func (m *MockgitRepo) IsCommitDirectoryExist(ctx context.Context, commit, path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCommitDirectoryExist", ctx, commit, path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCommitDirectoryExist indicates an expected call of IsCommitDirectoryExist.
func (mr *MockgitRepoMockRecorder) IsCommitDirectoryExist(ctx, commit, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCommitDirectoryExist", reflect.TypeOf((*MockgitRepo)(nil).IsCommitDirectoryExist), ctx, commit, path)
}

// IsCommitExists mocks base method.
func (m *MockgitRepo) IsCommitExists(ctx context.Context, commit string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCommitExists", ctx, commit)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCommitExists indicates an expected call of IsCommitExists.
func (mr *MockgitRepoMockRecorder) IsCommitExists(ctx, commit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCommitExists", reflect.TypeOf((*MockgitRepo)(nil).IsCommitExists), ctx, commit)
}

// IsCommitFileExist mocks base method.
func (m *MockgitRepo) IsCommitFileExist(ctx context.Context, commit, path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCommitFileExist", ctx, commit, path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCommitFileExist indicates an expected call of IsCommitFileExist.
func (mr *MockgitRepoMockRecorder) IsCommitFileExist(ctx, commit, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCommitFileExist", reflect.TypeOf((*MockgitRepo)(nil).IsCommitFileExist), ctx, commit, path)
}

// IsCommitTreeEntryDirectory mocks base method.
func (m *MockgitRepo) IsCommitTreeEntryDirectory(ctx context.Context, commit, relPath string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCommitTreeEntryDirectory", ctx, commit, relPath)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCommitTreeEntryDirectory indicates an expected call of IsCommitTreeEntryDirectory.
func (mr *MockgitRepoMockRecorder) IsCommitTreeEntryDirectory(ctx, commit, relPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCommitTreeEntryDirectory", reflect.TypeOf((*MockgitRepo)(nil).IsCommitTreeEntryDirectory), ctx, commit, relPath)
}

// IsCommitTreeEntryExist mocks base method.
func (m *MockgitRepo) IsCommitTreeEntryExist(ctx context.Context, commit, relPath string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCommitTreeEntryExist", ctx, commit, relPath)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCommitTreeEntryExist indicates an expected call of IsCommitTreeEntryExist.
func (mr *MockgitRepoMockRecorder) IsCommitTreeEntryExist(ctx, commit, relPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCommitTreeEntryExist", reflect.TypeOf((*MockgitRepo)(nil).IsCommitTreeEntryExist), ctx, commit, relPath)
}

// IsEmpty mocks base method.
func (m *MockgitRepo) IsEmpty(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsEmpty indicates an expected call of IsEmpty.
func (mr *MockgitRepoMockRecorder) IsEmpty(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*MockgitRepo)(nil).IsEmpty), ctx)
}

// IsLocal mocks base method.
func (m *MockgitRepo) IsLocal() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLocal")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsLocal indicates an expected call of IsLocal.
func (mr *MockgitRepoMockRecorder) IsLocal() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLocal", reflect.TypeOf((*MockgitRepo)(nil).IsLocal))
}

// IsShallowClone mocks base method.
func (m *MockgitRepo) IsShallowClone(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsShallowClone", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsShallowClone indicates an expected call of IsShallowClone.
func (mr *MockgitRepoMockRecorder) IsShallowClone(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsShallowClone", reflect.TypeOf((*MockgitRepo)(nil).IsShallowClone), ctx)
}

// LatestBranchCommit mocks base method.
func (m *MockgitRepo) LatestBranchCommit(ctx context.Context, branch string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LatestBranchCommit", ctx, branch)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LatestBranchCommit indicates an expected call of LatestBranchCommit.
func (mr *MockgitRepoMockRecorder) LatestBranchCommit(ctx, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LatestBranchCommit", reflect.TypeOf((*MockgitRepo)(nil).LatestBranchCommit), ctx, branch)
}

// ListCommitFilesWithGlob mocks base method.
func (m *MockgitRepo) ListCommitFilesWithGlob(ctx context.Context, commit, dir, glob string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCommitFilesWithGlob", ctx, commit, dir, glob)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCommitFilesWithGlob indicates an expected call of ListCommitFilesWithGlob.
func (mr *MockgitRepoMockRecorder) ListCommitFilesWithGlob(ctx, commit, dir, glob any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCommitFilesWithGlob", reflect.TypeOf((*MockgitRepo)(nil).ListCommitFilesWithGlob), ctx, commit, dir, glob)
}

// ReadCommitFile mocks base method.
func (m *MockgitRepo) ReadCommitFile(ctx context.Context, commit, path string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadCommitFile", ctx, commit, path)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadCommitFile indicates an expected call of ReadCommitFile.
func (mr *MockgitRepoMockRecorder) ReadCommitFile(ctx, commit, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadCommitFile", reflect.TypeOf((*MockgitRepo)(nil).ReadCommitFile), ctx, commit, path)
}

// ReadCommitTreeEntryContent mocks base method.
func (m *MockgitRepo) ReadCommitTreeEntryContent(ctx context.Context, commit, relPath string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadCommitTreeEntryContent", ctx, commit, relPath)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadCommitTreeEntryContent indicates an expected call of ReadCommitTreeEntryContent.
func (mr *MockgitRepoMockRecorder) ReadCommitTreeEntryContent(ctx, commit, relPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadCommitTreeEntryContent", reflect.TypeOf((*MockgitRepo)(nil).ReadCommitTreeEntryContent), ctx, commit, relPath)
}

// RemoteOriginUrl mocks base method.
func (m *MockgitRepo) RemoteOriginUrl(arg0 context.Context) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoteOriginUrl", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemoteOriginUrl indicates an expected call of RemoteOriginUrl.
func (mr *MockgitRepoMockRecorder) RemoteOriginUrl(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoteOriginUrl", reflect.TypeOf((*MockgitRepo)(nil).RemoteOriginUrl), arg0)
}

// ResolveAndCheckCommitFilePath mocks base method.
func (m *MockgitRepo) ResolveAndCheckCommitFilePath(ctx context.Context, commit, path string, checkSymlinkTargetFunc func(string) error) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveAndCheckCommitFilePath", ctx, commit, path, checkSymlinkTargetFunc)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveAndCheckCommitFilePath indicates an expected call of ResolveAndCheckCommitFilePath.
func (mr *MockgitRepoMockRecorder) ResolveAndCheckCommitFilePath(ctx, commit, path, checkSymlinkTargetFunc any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveAndCheckCommitFilePath", reflect.TypeOf((*MockgitRepo)(nil).ResolveAndCheckCommitFilePath), ctx, commit, path, checkSymlinkTargetFunc)
}

// ResolveCommitFilePath mocks base method.
func (m *MockgitRepo) ResolveCommitFilePath(ctx context.Context, commit, path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveCommitFilePath", ctx, commit, path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveCommitFilePath indicates an expected call of ResolveCommitFilePath.
func (mr *MockgitRepoMockRecorder) ResolveCommitFilePath(ctx, commit, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveCommitFilePath", reflect.TypeOf((*MockgitRepo)(nil).ResolveCommitFilePath), ctx, commit, path)
}

// StatusPathList mocks base method.
func (m *MockgitRepo) StatusPathList(ctx context.Context, pathMatcher path_matcher.PathMatcher) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StatusPathList", ctx, pathMatcher)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StatusPathList indicates an expected call of StatusPathList.
func (mr *MockgitRepoMockRecorder) StatusPathList(ctx, pathMatcher any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StatusPathList", reflect.TypeOf((*MockgitRepo)(nil).StatusPathList), ctx, pathMatcher)
}

// String mocks base method.
func (m *MockgitRepo) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockgitRepoMockRecorder) String() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockgitRepo)(nil).String))
}

// SyncWithOrigin mocks base method.
func (m *MockgitRepo) SyncWithOrigin(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SyncWithOrigin", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// SyncWithOrigin indicates an expected call of SyncWithOrigin.
func (mr *MockgitRepoMockRecorder) SyncWithOrigin(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SyncWithOrigin", reflect.TypeOf((*MockgitRepo)(nil).SyncWithOrigin), ctx)
}

// TagCommit mocks base method.
func (m *MockgitRepo) TagCommit(ctx context.Context, tag string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TagCommit", ctx, tag)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TagCommit indicates an expected call of TagCommit.
func (mr *MockgitRepoMockRecorder) TagCommit(ctx, tag any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TagCommit", reflect.TypeOf((*MockgitRepo)(nil).TagCommit), ctx, tag)
}

// Unshallow mocks base method.
func (m *MockgitRepo) Unshallow(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unshallow", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unshallow indicates an expected call of Unshallow.
func (mr *MockgitRepoMockRecorder) Unshallow(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unshallow", reflect.TypeOf((*MockgitRepo)(nil).Unshallow), ctx)
}

// ValidateStatusResult mocks base method.
func (m *MockgitRepo) ValidateStatusResult(ctx context.Context, pathMatcher path_matcher.PathMatcher) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateStatusResult", ctx, pathMatcher)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateStatusResult indicates an expected call of ValidateStatusResult.
func (mr *MockgitRepoMockRecorder) ValidateStatusResult(ctx, pathMatcher any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateStatusResult", reflect.TypeOf((*MockgitRepo)(nil).ValidateStatusResult), ctx, pathMatcher)
}

// WalkCommitFiles mocks base method.
func (m *MockgitRepo) WalkCommitFiles(ctx context.Context, commit, dir string, pathMatcher path_matcher.PathMatcher, fileFunc func(string) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WalkCommitFiles", ctx, commit, dir, pathMatcher, fileFunc)
	ret0, _ := ret[0].(error)
	return ret0
}

// WalkCommitFiles indicates an expected call of WalkCommitFiles.
func (mr *MockgitRepoMockRecorder) WalkCommitFiles(ctx, commit, dir, pathMatcher, fileFunc any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalkCommitFiles", reflect.TypeOf((*MockgitRepo)(nil).WalkCommitFiles), ctx, commit, dir, pathMatcher, fileFunc)
}

// withRepoHandle mocks base method.
func (m *MockgitRepo) withRepoHandle(ctx context.Context, commit string, f func(repo_handle.Handle) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "withRepoHandle", ctx, commit, f)
	ret0, _ := ret[0].(error)
	return ret0
}

// withRepoHandle indicates an expected call of withRepoHandle.
func (mr *MockgitRepoMockRecorder) withRepoHandle(ctx, commit, f any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "withRepoHandle", reflect.TypeOf((*MockgitRepo)(nil).withRepoHandle), ctx, commit, f)
}

// MockPatch is a mock of Patch interface.
type MockPatch struct {
	ctrl     *gomock.Controller
	recorder *MockPatchMockRecorder
	isgomock struct{}
}

// MockPatchMockRecorder is the mock recorder for MockPatch.
type MockPatchMockRecorder struct {
	mock *MockPatch
}

// NewMockPatch creates a new mock instance.
func NewMockPatch(ctrl *gomock.Controller) *MockPatch {
	mock := &MockPatch{ctrl: ctrl}
	mock.recorder = &MockPatchMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPatch) EXPECT() *MockPatchMockRecorder {
	return m.recorder
}

// GetBinaryPaths mocks base method.
func (m *MockPatch) GetBinaryPaths() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBinaryPaths")
	ret0, _ := ret[0].([]string)
	return ret0
}

// GetBinaryPaths indicates an expected call of GetBinaryPaths.
func (mr *MockPatchMockRecorder) GetBinaryPaths() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBinaryPaths", reflect.TypeOf((*MockPatch)(nil).GetBinaryPaths))
}

// GetFilePath mocks base method.
func (m *MockPatch) GetFilePath() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFilePath")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetFilePath indicates an expected call of GetFilePath.
func (mr *MockPatchMockRecorder) GetFilePath() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFilePath", reflect.TypeOf((*MockPatch)(nil).GetFilePath))
}

// GetPaths mocks base method.
func (m *MockPatch) GetPaths() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPaths")
	ret0, _ := ret[0].([]string)
	return ret0
}

// GetPaths indicates an expected call of GetPaths.
func (mr *MockPatchMockRecorder) GetPaths() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPaths", reflect.TypeOf((*MockPatch)(nil).GetPaths))
}

// GetPathsToRemove mocks base method.
func (m *MockPatch) GetPathsToRemove() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPathsToRemove")
	ret0, _ := ret[0].([]string)
	return ret0
}

// GetPathsToRemove indicates an expected call of GetPathsToRemove.
func (mr *MockPatchMockRecorder) GetPathsToRemove() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPathsToRemove", reflect.TypeOf((*MockPatch)(nil).GetPathsToRemove))
}

// HasBinary mocks base method.
func (m *MockPatch) HasBinary() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasBinary")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasBinary indicates an expected call of HasBinary.
func (mr *MockPatchMockRecorder) HasBinary() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasBinary", reflect.TypeOf((*MockPatch)(nil).HasBinary))
}

// IsEmpty mocks base method.
func (m *MockPatch) IsEmpty() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsEmpty indicates an expected call of IsEmpty.
func (mr *MockPatchMockRecorder) IsEmpty() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*MockPatch)(nil).IsEmpty))
}

// MockArchive is a mock of Archive interface.
type MockArchive struct {
	ctrl     *gomock.Controller
	recorder *MockArchiveMockRecorder
	isgomock struct{}
}

// MockArchiveMockRecorder is the mock recorder for MockArchive.
type MockArchiveMockRecorder struct {
	mock *MockArchive
}

// NewMockArchive creates a new mock instance.
func NewMockArchive(ctrl *gomock.Controller) *MockArchive {
	mock := &MockArchive{ctrl: ctrl}
	mock.recorder = &MockArchiveMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockArchive) EXPECT() *MockArchiveMockRecorder {
	return m.recorder
}

// GetFilePath mocks base method.
func (m *MockArchive) GetFilePath() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFilePath")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetFilePath indicates an expected call of GetFilePath.
func (mr *MockArchiveMockRecorder) GetFilePath() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFilePath", reflect.TypeOf((*MockArchive)(nil).GetFilePath))
}
