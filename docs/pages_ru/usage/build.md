---
title: Сборка
permalink: usage/build.html
---

## Обзор

Чтобы доставить приложение в кубы как правило нужно собрать один или несколько образов приложения.

От пользователя требуется предоставить сборочные инструкции в виде Dockerfile или альтернативного сборочного синтаксиса stapel.

Предоставляется простой интерфейс для встараивания в CI/CD pipeline или для локального использования: команда `werf build [--repo REPO]`. Далее werf из коробки без специальной конфигурации берёт на себя всю работу по сборке, предоставляя следующие фичи:

* оркестрация одновременной/параллельной сборки всех образов приложения;
* общий кеш промежуточных слоёв и образов в Container Registry, доступный с любых раннеров;
* оптимальная схема тегирования, основанная на содержимом образа, предотвращающая лишние пересборки и downtime приложения при дальнейшем выкате;
* система обеспечения воспроизводимости и неизменности образов для коммита: однажды собранные образы для коммита более не будут пересобраны (в рамках политик очистки — см. очистка);

После прочтения данного раздела пользователь узнает как описать инструкции сборки образов, как работает механизм сборки, какие есть варианты конфигурации сборочного механизма и варианты организации хранилища под нужды проекта.

## Конфигурация

### Образы в werf.yaml

> прим. для переводчика: на основе https://werf.io/documentation/v1.2/reference/werf_yaml.html#image-section

Все требуемые образы должны быть сначала добавлены в werf.yaml проекта с помощью директивы `image` с указанием имени образа:

```yaml
image: frontend
```

Имя образа — это короткое символьное имя, на которое мы будем ссылаться в других местах конфигурации и при вызове команд werf. Например, когда нам потребуется либо получить полное имя опубликованного в container registry образа, либо при запуске команд внутри собранного образа через `werf kube-run` и т.п.

Если в файле конфигурации описывается только один образ, то он может быть безымянным:

```yaml
image: ~
```

Если в файле конфигурации описывается более одного образа, то **каждый образ** должен иметь собственное имя. Также один образ может иметь несколько имен, указываемых в виде YAML-списка (это эквивалентно описанию нескольких одинаковых образов с разными именами):

```yaml
image: frontend
---
image: backend
---
image: [database, postgre]
```

### Dockerfile

Сборка образа с использованием имеющегося Dockerfile — самый простой путь начать использовать werf в существующем проекте. Ниже приведен пример описания образа по имени `example` в werf.yaml:

```yaml
image: example
dockerfile: Dockerfile
```

Также, вы можете описывать несколько образов из одного и того же Dockerfile:

```yaml
image: backend
dockerfile: Dockerfile
target: backend
---
image: frontend
dockerfile: Dockerfile
target: frontend
```

И конечно, вы можете описывать образы, основанные на разных Dockerfile:

```yaml
image: backend
dockerfile: dockerfiles/Dockerfile.backend
---
image: frontend
dockerfile: dockerfiles/Dockerfile.frontend
```

#### contextAddFiles

Контекст сборки Dockerfile-образа включает только файлы из текущего коммита репозитория проекта, которые содержатся в директории, заданной директивой `context` (по умолчанию это директория проекта).

Директива `contextAddFiles` позволяет дополнить контекст сборки файлами из директории проекта, которые не хранятся в git:

```yaml
image: app
context: app
contextAddFiles:
 - file1
 - dir1/
 - dir2/file2.out
```

В данной конфигурации контекст сборки будет состоять из следующих файлов:

- `app/**/*` из текущего коммита репозитория проекта;
- Файлы `app/file1`, `app/dir2/file2.out` и директория `dir1`, которые находятся в директории проекта.

Файлы `contextAddFiles` имеют больший приоритет, чем файлы из репозитория проекта, поэтому при пересечении пользователь будет работать с ними.

> По умолчанию, использование директивы `contextAddFiles` запрещено гитерминизмом (подробнее об этом в [статье]({{ "/advanced/giterminism.html#contextaddfiles" | true_relative_url }}))

### Stapel

Альтернативный способ сборки образов с использованием т.н. сборщика stapel. Его особенности:

* Обеспечивает интеграцию с git и инкрементальную пересборку с учетом истории git-репозитория.
* Позволяет использовать golang-шаблонизацию для описания сборочных инструкций.

#### Базовый образ

```yaml
image: example
from: alpine
```

Приведенная конфигурация описывает _образ_ `example`, _базовым образом_ для которого является образ из DockerHub с именем `alpine`. _Базовый образ_ может быть указан с помощью директив `from`, `fromImage` или `fromArtifact`.

##### from, fromLatest

Директива `from` определяет имя и тег _базового образа_. Если тег не указан, то по умолчанию — `latest`.

```yaml
from: <image>[:<tag>]
```

По умолчанию процесс сборки не зависит от digest _базового образа_, а зависит только от значения директивы `from`.
Поэтому изменение _базового образа_ в локальном хранилище или в container registry не будет влиять на сборку, пока стадия _from_, с указанным значением образа, находится в _stages storage_.

Если вам нужна проверка digest образа, чтобы всегда использовать актуальный _базовый образ_, вы можете использовать директиву `fromLatest`.
Это приведет к тому, что при каждом запуске werf будет проверяться актуальный digest _базового образа_ в container registry.

Пример использования директивы `fromLatest`:

```yaml
fromLatest: true
```

> По умолчанию, использование директивы `fromLatest` запрещено гитерминизмом (подробнее об этом в [статье]({{ "advanced/giterminism.html" | true_relative_url }}))

##### fromImage и fromArtifact

В качестве _базового образа_ можно указывать не только образ из локального хранилища или container registry, но и имя другого _образа_ или [_артефакта_]({{ "advanced/building_images_with_stapel/artifacts.html" | true_relative_url }}), описанного в том же файле `werf.yaml`. В этом случае необходимо использовать директивы `fromImage` и `fromArtifact` соответственно.

```yaml
fromImage: <image name>
fromArtifact: <artifact name>
```

Если _базовый образ_ уникален для конкретного приложения, то рекомендуемый способ — хранить его описание в конфигурации приложения (в файле `werf.yaml`) как отдельный _образ_ или _артефакт_, вместо того, чтобы ссылаться на Docker-образ.

Также эта рекомендация будет полезной, если вам, по каким-либо причинам, не хватает существующего _конвейера стадий_.
Используя в качестве _базового образа_ образ, описанный в том же `werf.yaml`, вы по сути можете построить свой _конвейер стадий_.

<a class="google-drawings" href="{{ "images/configuration/base_image2.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/configuration/base_image2_preview.png" | true_relative_url }}">
</a>

##### fromCacheVersion

Как описано выше, в обычном случае процесс сборки активно использует кэширование.
При сборке выполняется проверка — изменился ли _базовый образ_.
В зависимости от используемых директив эта проверка на изменение digest или имени и тега образа.
Если образ не изменился, то дайджест стадии `from` остается прежней, и если в _stages storage_ есть образ с таким дайджестом, то он и будет использован при сборке.

С помощью директивы `fromCacheVersion` вы можете влиять на дайджест стадии `from` (т.к. значение `fromCacheVersion` — это часть дайджеста стадии) и, таким образом, управлять принудительной пересборкой образа.
Если вы измените значение, указанное в директиве `fromCacheVersion`, то независимо от того, менялся _базовый образ_ (или его digest) или остался прежним, при сборке изменится дайджест стадии `from` и, соответственно, всех последующих стадий.
Это приведет к тому, что сборка всех стадий будет выполнена повторно.

```yaml
fromCacheVersion: <arbitrary string>
```

#### Конфигурация финального образа через Dockerfile-инструкции

Инструкции в [Dockerfile](https://docs.docker.com/engine/reference/builder/) можно условно разделить на две группы: сборочные инструкции и инструкции, которые влияют на manifest Docker-образа.
Так как werf сборщик использует свой синтаксис для описания сборки, поддерживаются только следующие Dockerfile-инструкции второй группы:

* `USER` — имя пользователя (или UID) и опционально пользовательская группа (или GID) ([подробнее](https://docs.docker.com/engine/reference/builder/#user))
* `WORKDIR` — рабочая директория ([подробнее](https://docs.docker.com/engine/reference/builder/#workdir))
* `VOLUME` — точка монтирования ([подробнее](https://docs.docker.com/engine/reference/builder/#volume))
* `ENV` — переменные окружения ([подробнее](https://docs.docker.com/engine/reference/builder/#env))
* `LABEL` — метаданные ([подробнее](https://docs.docker.com/engine/reference/builder/#label))
* `EXPOSE` — описание сетевых портов, которые будут прослушиваться в запущенном контейнере ([подробнее](https://docs.docker.com/engine/reference/builder/#expose))
* `ENTRYPOINT` — команда по умолчанию, которая будет выполнена при запуске контейнера ([подробнее](https://docs.docker.com/engine/reference/builder/#entrypoint))
* `CMD` — аргументы по умолчанию для `ENTRYPOINT` ([подробнее](https://docs.docker.com/engine/reference/builder/#cmd))
* `HEALTHCHECK` — инструкции, которые Docker может использовать для проверки работоспособности запущенного контейнера ([подробнее](https://docs.docker.com/engine/reference/builder/#healthcheck))

Эти инструкции могут быть указаны с помощью директивы `docker` в конфигурации.

Пример:

```yaml
docker:
  WORKDIR: /app
  CMD: ["python", "./index.py"]
  EXPOSE: '5000'
  ENV:
    TERM: xterm
    LC_ALL: en_US.UTF-8
```

Указанные в конфигурации Dockerfile-инструкции применяются на последней стадии конвейера стадий, стадии `docker_instructions`.
Поэтому указание Dockerfile-инструкций в `werf.yaml` никак не влияет на сам процесс сборки, а только добавляет данные к уже собранному образу.

Если вам требуются определённые переменные окружения во время сборки (например, `TERM`), то вам необходимо использовать [базовый образ]({{ "advanced/building_images_with_stapel/base_image.html" | true_relative_url }}), в котором эти переменные окружения установлен или экспортировать их в [_пользовательской стадии_]({{ "advanced/building_images_with_stapel/assembly_instructions.html#пользовательские-стадии" | true_relative_url }}).

#### Добавление исходного кода из git-репозиториев

##### Что такое git mapping?

***Git mapping*** определяет, какой файл или папка из Git-репозитория должны быть добавлены в конкретное место образа.
Git-репозиторий может быть как локальным репозиторием, в котором находится файл конфигурации сборки (`werf.yaml`), так и удаленным.
В этом случае указывается адрес репозитория и версия кода — ветка, тег или конкретный коммит.

werf добавляет файлы из Git-репозитория в образ, копируя их с помощью [git archive](https://git-scm.com/docs/git-archive), либо накладывая Git-патч.
При повторных сборках и появлении изменений в Git-репозитории werf добавляет patch к собранному ранее образу, чтобы в конечном образе отразить изменения файлов и папок. Более подробно механизм переноса файлов и накладывания патчей рассматриваются [в следующей секции](#подробнее-про-gitarchive-gitcache-gitlatestpatch).

Конфигурация _git mapping_ поддерживает фильтры, что позволяет сформировать практически любую файловую структуру в образе, используя произвольное количество _git mappings_.
Также вы можете указать группу и владельца конечных файлов в образе, что освобождает от необходимости делать это отдельной командой (`chown`).

В werf реализована поддержка сабмодулей Git (git submodules) и если werf определяет, что какая-то часть _git mapping_ является сабмодулем, то принимаются соответствующие меры, чтобы обрабатывать изменения в сабмодулях корректно.

> Все Git-сабмодули проекта связаны с конкретным коммитом, поэтому все разработчики, работающие с репозиторием с сабмодулями, получают одинаковое содержимое.
> werf не инициализирует и не обновляет сабмодули, а использует соответствующие связанные коммиты.

Пример добавления файлов из папки `/src` локального Git-репозитория в папку `/app` собираемого образа и добавления кода PhantomJS из удаленного репозитория в папку `/src/phantomjs` собираемого образа:

```yaml
git:
- add: /src
  to: /app
- url: https://github.com/ariya/phantomjs
  add: /
  to: /src/phantomjs
```

##### Синтаксис

Для добавления кода из локального Git-репозитория используется следующий синтаксис:

- `add` — (не обязательный параметр) путь к директории или файлу, содержимое которого (которой) нужно добавить в образ. Указывается абсолютный путь *относительно корня* репозитория, т.е. он должен начинаться с `/`. По умолчанию копируется все содержимое репозитория, отсутствие параметра `add` равносильно указанию `add: /`;
- `to` — путь внутри образа, куда будет скопировано соответствующее содержимое;
- `owner` — имя или id пользователя-владельца файлов в образе;
- `group` — имя или id группы-владельца файлов в образе;
- `excludePaths` — список исключений (маска) при рекурсивном копировании файлов и папок. Указывается относительно пути, указанного в `add`;
- `includePaths` — список масок файлов и папок для рекурсивного копирования. Указывается относительно пути, указанного в `add`;
- `stageDependencies` — список масок файлов и папок для указания зависимости пересборки стадии от их изменений. Позволяет указать, при изменении каких файлов и папок необходимо принудительно пересобирать конкретную пользовательскую стадию. Более подробно рассматривается [здесь]({{ "advanced/building_images_with_stapel/assembly_instructions.html" | true_relative_url }}).

При использовании удаленных репозиториев дополнительно используются следующие параметры:
- `url` — адрес удаленного репозитория;
- `branch`, `tag`, `commit` — имя ветки, тега или коммита соответственно. По умолчанию — ветка master.

> По умолчанию использование директивы `branch` запрещено гитерминизмом (подробнее об этом [в статье]({{ "advanced/giterminism.html" | true_relative_url }})).

##### Копирование директорий

Параметр `add` определяет источник, путь в Git-репозитории, откуда файлы рекурсивно копируются в образ и помещаются по адресу, указанному в параметре `to`. Если параметр не определен, то по умолчанию используется значение `/`, т.е. копируется весь репозиторий.
Пример простейшей конфигурации, добавляющей содержимое всего локального Git-репозитория в образ в папку `/app`.

```yaml
git:
- add: /
  to: /app
```

<div class="tabs">
  <a href="javascript:void(0)" class="tabs__btn btn__example1 active" onclick="openTab(event, 'btn__example1', 'tab__example1', 'git-mapping-01-source')">Структура в репозитории</a>
  <a href="javascript:void(0)" class="tabs__btn btn__example1" onclick="openTab(event, 'btn__example1', 'tab__example1', 'git-mapping-01-dest')">Структура в конечном образе</a>
</div>
<div id="git-mapping-01-source" class="tabs__content tab__example1 active">
  <img src="{{ "images/build/git_mapping_01.png" | true_relative_url }}" alt="git repository files tree" />
</div>
<div id="git-mapping-01-dest" class="tabs__content tab__example1">
  <img src="{{ "images/build/git_mapping_02.png" | true_relative_url }}" alt="image files tree" />
</div>

Также можно указать несколько _git mappings_:

```yaml
git:
- add: /src
  to: /app/src
- add: /assets
  to: /static
```

<div class="tabs">
  <a href="javascript:void(0)" class="tabs__btn btn__example2 active" onclick="openTab(event, 'btn__example2', 'tab__example2', 'git-mapping-02-source')">Структура в репозитории</a>
  <a href="javascript:void(0)" class="tabs__btn btn__example2" onclick="openTab(event, 'btn__example2', 'tab__example2', 'git-mapping-02-dest')">Структура в конечном образе</a>
</div>
<div id="git-mapping-02-source" class="tabs__content tab__example2 active">
  <img src="{{ "images/build/git_mapping_03.png" | true_relative_url }}" alt="git repository files tree" />
</div>
<div id="git-mapping-02-dest" class="tabs__content tab__example2">
  <img src="{{ "images/build/git_mapping_04.png" | true_relative_url }}" alt="image files tree" />
</div>

Следует отметить, что конфигурация _git mapping_ не похожа, например, на копирование типа `cp -r /src /app`.
Параметр `add` указывает на *содержимое* каталога, которое будет рекурсивно копироваться из репозитория.
Поэтому, если папка `/assets` со всем содержимым из репозитория должна быть скопирована в папку `/app/assets` образа, то имя *assets* вы должны указать два раза.
Либо, как вариант, вы можете использовать [фильтр](#использование-фильтров) (например, параметр `includePaths`).

Примеры обоих вариантов, которые вы можете использовать для достижения одинакового результата:
```yaml
git:
- add: /assets
  to: /app/assets
```

либо

```yaml
git:
- add: /
  to: /app
  includePaths: assets
```

##### Изменение владельца

При добавлении файла из Git-репозитория вы можете указать имя и/или группу владельца файлов в образе.
Добавляемым файлам и папкам в образе при копировании будут установлены соответствующие права.
Пользователь и группа могут быть указаны как именем, так и числовым id (userid, groupid).

Пример использования:

```yaml
git:
- add: /src/index.php
  to: /app/index.php
  owner: www-data
```

Если указан только параметр `owner`, как в приведенном примере, то группой-владельцем устанавливается основная группа указанного пользователя в системе.

В результате в папку `/app` образа будет добавлен файл `index.php` и ему будут установлены следующие права:

![index.php owned by www-data user and group]({{ "images/build/git_mapping_05.png" | true_relative_url }})

Если значения параметра `owner` или `group` не числовые id, а текстовые (т.е. названия соответственно пользователя и группы), то соответствующие пользователь и группа должны существовать в системе. Их нужно добавить заранее при необходимости (к примеру, на стадии _beforeInstall_), иначе при сборке возникнет ошибка.

```yaml
git:
- add: /src/index.php
  to: /app/index.php
  owner: wwwdata
```

##### Использование фильтров

Парамеры фильтров, `includePaths` и `excludePaths`, используются при составлении списка файлов для добавления.
Эти параметры содержат набор путей или масок, применяемых соответственно для включения и исключения файлов и папок при добавлении в образ.

Фильтр `excludePaths` работает следующим образом: каждая маска списка применяется к каждому файлу, найденному по пути `add`.
Если файл удовлетворяет хотя бы одной маске, то он исключается из списка файлов на добавление.
Если файл не удовлетворяет ни одной маске, то он добавляется в образ.

Фильтр `includePaths` работает наоборот — если файл удовлетворяет хотя бы одной маске, то он добавляется в образ.

Конфигурация _git mapping_ может содержать оба фильтра.
В этом случае файл добавляется в образ, если его путь удовлетворяет хотя бы одной маске `includePaths` и не удовлетворяет ни одной маске `excludePaths`.

Пример:

```yaml
git:
- add: /src
  to: /app
  includePaths:
  - '**/*.php'
  - '**/*.js'
  excludePaths:
  - '**/*-dev.*'
  - '**/*-test.*'
```

В приведенном примере добавляются `.php` и `.js` файлы из папки  `/src` исключая файлы с суффиксом `-dev.` или `-test.` в имени файла.

> Последний шаг в алгоритме с добавлением суффикса`**/*` сделан для удобства — вам достаточно указать название папки в параметрах _git mapping_, чтобы все ее содержимое удовлетворяло шаблону параметра

Маска может содержать следующие шаблоны:

- `*` — Удовлетворяет любому файлу. Шаблон включает `.` и исключает `/`.
- `**` — Удовлетворяет директории со всем ее содержимым, рекурсивно.
- `?` — Удовлетворяет любому **одному** символу в имени файла (аналогично regexp-шаблону `/.{1}/`).
- `[set]` — Удовлетворяет любому символу из указанного набора символов. Аналогично использованию в regexp-шаблонах, включая указание диапазонов типа `[^a-z]`.
- `\` — Экранирует следующий символ.

Маска, которая начинается с шаблона `*` или `**`, должна быть взята в одинарные или двойные кавычки в `werf.yaml`:
- `"*.rb"` — двойные кавычки;
- `'**/*'` — одинарные кавычки.

Примеры фильтров:

```yaml
add: /src
to: /app
includePaths:
# Удовлетворяет всем php файлам, расположенным конкретно в папке /src.
- '*.php'

# Удовлетворяет всем php файлам рекурсивно, начиная с папки /src
# (также удовлетворяет файлам *.php, т.к. '.' включается шаблон **).
- '**/*.php'

# Удовлетворяет всем файлам в папке /src/module1 рекурсивно.
- module1
```

Фильтр `includePaths` может применяться для копирования одного файла без изменения имени. Пример:
```yaml
git:
- add: /src
  to: /app
  includePaths: index.php
```

##### Наложение путей копирования

Если вы определяете несколько _git mappings_, вы должны учитывать, что при наложении путей в образе в параметре `to` вы можете столкнуться с невозможностью добавления файлов. Пример:

```yaml
git:
- add: /src
  to: /app
- add: /assets
  to: /app/assets
```

Чтобы избежать ошибок сборки, werf определяет возможные наложения касающиеся фильтров `includePaths` и `excludePaths`, и если такое наложение присутствует, то werf пытается разрешить самые простые конфликты, неявно добавляя соответствующий параметр `excludePaths` в _git mapping_.
Однако, такое поведение может все-таки привести к неожиданным результатам, поэтому лучше всего избегать наложения путей при определении _git mappings_.

В примере выше werf в итоге неявно добавит параметр  `excludePaths`, и итоговая конфигурация будет следующей:

```yaml
git:
- add: /src
  to: /app
  excludePaths:  # werf добавил этот фильтр, чтобы исключить конфликт наложения результирующих путей
  - assets       # между /src/assets и /assets
- add: /assets
  to: /app/assets
```

##### Добавление репозитория по протоколу HTTPS

Синтаксис для работы по протоколу `https`:

{% raw %}
```yaml
git:
- url: https://[USERNAME[:PASSWORD]@]repo_host/repo_path[.git/]
```
{% endraw %}

Указание логина и пароля при доступе по `https` опционально.

Пример доступа к репозиторию из pipeline GitLab CI с использованием переменных окружения:

{% raw %}
```yaml
git:
- url: https://{{ env "CI_REGISTRY_USER" }}:{{ env "CI_JOB_TOKEN" }}@registry.gitlab.company.name/common/helper-utils.git
```
{% endraw %}

В приведенном примере используется метод [env](http://masterminds.github.io/sprig/os.html) библиотеки [Sprig](http://masterminds.github.io/sprig/) для доступа к переменным окружения.

##### Добавление репозитория по протоколу SSH

Доступ к удаленному репозиторию с помощью протокола `git` защищается с использованием доступа поверх SSH. Это распространенная практика, используемая в частности GitHub, Bitbucket, GitLab, Gogs, Gitolite и т.д. Обычно адрес репозитория выглядит следующим образом:

```yaml
git:
- url: git@gitlab.company.name:project_group/project.git
```

Для работы с удаленными репозиториями по SSH необходимо понимать, как werf находит SSH-ключи (читай далее подробнее).

##### Работа с SSH-ключами

SSH-ключи для доступа предоставляются через SSH-agent. SSH-agent — это демон, который работает через файловый сокет, путь к которому хранится в переменной окружения `SSH_AUTH_SOCK`. werf монтирует этот файловый сокет во все _сборочные контейнеры_ и устанавливает переменную окружения `SSH_AUTH_SOCK`. Т.e. соединение с удаленным Git-репозиторием устанавливается с использованием ключей, зарегистрированных в запущенном SSH-агенте.

werf использует следующий алгоритм для определения запущенного SSH-агента:

- werf запущен с ключом `--ssh-key` (одним или несколькими):
  - Запускается временный SSH-агент, в который добавляются указанные при запуске werf ключи. Эти ключи используются при всех операциях с удаленными репозиториями.
  - Уже запущенный SSH-агент игнорируется.
- werf запущен без указания ключа `--ssh-key` и есть запущенный SSH-агент:
  - Используется переменная окружения `SSH_AUTH_SOCK`, ключи добавляются в соответствующий SSH-агент и используются далее при всех операциях работы с удаленными репозиториями.
- werf запущен без указания ключа `--ssh-key` и нет запущенного SSH-агента:
  - Если существует файл `~/.ssh/id_rsa`, запускается временный SSH-агент, в который добавляется ключ из файла `~/.ssh/id_rsa`.
- Если ни один из вариантов не применим, то SSH-агент не запускается и при операциях с внешними Git-репозиториями не используются никакие SSH-ключи. Сборка образа, с объявленными удаленными репозиториями в _git mapping_, завершится с ошибкой.

##### Подробнее про gitArchive, gitCache, gitLatestPatch

Далее будет более подробно рассмотрен процесс добавления файлов в конечный образ. Как упоминалось ранее, Docker-образ состоит из набора слоёв. Чтобы понимать, какие слои создает werf, представим последовательную сборку трех коммитов: `1`, `2` и `3`:

- Сборка коммита 1. Исходя из конфигурации _git mapping_, все соответствующие файлы добавляются в один слой. Сам процесс добавления выполняется с помощью `git archive`. Получившийся слой соответствует стадии _gitArchive_.
- Сборка коммита 2. Накладывается патч с изменениями файлов, в результате чего получается еще один слой. Получившийся слой соответствует стадии _gitLatestPatch_.
- Сборка коммита 3. Файлы уже добавлены, и werf накладывает патч, обновляя слой _gitLatestPatch_.

Сборки для этих коммитов можно представить ​​следующим образом:

| | gitArchive | gitLatestPatch |
|---|:---:|:---:|
| Commit No. 1 is made, build at 10:00 |  files as in commit No. 1 | - |
| Commit No. 2 is made, build at 10:05 |  files as in commit No. 1 | files as in commit No. 2 |
| Commit No. 3 is made, build at 10:15 |  files as in commit No. 1 | files as in commit No. 3 |

Со временем количество коммитов растет, и размер патча между коммитом №1 и текущим может стать довольно большим. Это еще больше увеличит размер последнего слоя и общий размер стадий. Чтобы предотвратить неконтролируемый рост последнего слоя, werf предоставляет дополнительный промежуточный этап — _gitCache_. Когда _gitLatestPatch_ diff становится слишком большим, большая часть его diff объединяется с _gitCache_ diff, тем самым уменьшая размер стадии _gitLatestPatch_.

##### Rebase и _git-стадии_

Каждая Git-стадия хранит служебные лейблы с SHA коммитами, которые использовались при сборке стадии.
Эти коммиты будут использоваться при сборке следующей Git-стадии при создании патчей (по сути это `git diff COMMIT_FROM_PREVIOUS_GIT_STAGE LATEST_COMMIT` для каждого _git-mapping_).

Если в стадии сохранён коммит, который отсутствует в Git-репозитории (например, после выполнения rebase), werf пересоберёт эту стадию, используя актуальный коммит.

## Сборщик

TODO: как это работает, как конфигурируется: parallel, buildah/docker, режимы buildah, синхронизация+конфигурация

## Организация хранилища

TODO: repo, cache-repo, final-repo, secondary-repo и примеры


## OLD

#### Стадии и хранилище

Мы разделили сборочный процесс образов, описанных в файле конфигурации [werf.yaml]({{ "reference/werf_yaml.html" | true_relative_url }}) на этапы, [с четкими функциями и назначением](#зависимости-стадии). Каждый такой этап соответствует промежуточному образу. В werf такой этап называется [стадией](#конвеер-стадий), а **конечный образ** соответствует последней собранной стадии для определённого состояния git и конфигурации werf.yaml.

Стадии — это этапы сборочного процесса. ***Стадия*** определяется группой инструкций, указанных в конфигурации. Причем группировка этих инструкций не случайна, имеет определенную логику и учитывает условия и правила сборки. С каждой _стадией_ связан конкретный Docker-образ. Все стадии хранятся в [хранилище](#хранилище).

##### Конвеер стадий

_Конвейер стадий_ — набор условий и правил выполнения стадий, подразумевающий также четко определенный порядок выполнения стадий. werf использует не один, а несколько _конвейеров стадий_ в своей работе, по-разному собирая образы в зависимости от их описанной конфигурации.

<div class="tabs">
  <a href="javascript:void(0)" class="tabs__btn active" onclick="openTab(event, 'tabs__btn', 'tabs__content', 'dockerfile-image-tab')">Dockerfile-образ</a>
  <a href="javascript:void(0)" class="tabs__btn" onclick="openTab(event, 'tabs__btn', 'tabs__content', 'stapel-image-tab')">Stapel-образ</a>
  <a href="javascript:void(0)" class="tabs__btn" onclick="openTab(event, 'tabs__btn', 'tabs__content', 'stapel-artifact-tab')">Stapel-артефакт</a>
</div>

<div id="dockerfile-image-tab" class="tabs__content active">
<a class="google-drawings" href="{{ "images/reference/stages_and_images1.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/reference/stages_and_images1_preview.png" | true_relative_url }}">
</a>
</div>

<div id="stapel-image-tab" class="tabs__content">
<a class="google-drawings" href="{{ "images/reference/stages_and_images2.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/reference/stages_and_images2_preview.png" | true_relative_url }}" >
</a>
</div>

<div id="stapel-artifact-tab" class="tabs__content">
<a class="google-drawings" href="{{ "images/reference/stages_and_images3.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/reference/stages_and_images3_preview.png" | true_relative_url }}">
</a>
</div>

Пользователю нужно только написать правильную конфигурацию, остальная работа со стадиями выполняется werf.

Для каждой _стадии_, werf подсчитывает уникальный сборочный идентификатор — [дайджест стадии](#дайджест-стадии).

В случае отсутствия у стадии [зависимостей стадии](#зависимости-стадии), она пропускается, и, соответственно, _конвейер стадий_ уменьшается на одну стадию. Таким образом конвейер стадий может уменьшаться, вплоть до единственной стадии _from_.

<a class="google-drawings" href="{{ "images/reference/stages_and_images4.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/reference/stages_and_images4_preview.png" | true_relative_url }}">
</a>

#### Дайджест стадии

_Дайджест стадии_ используется для [тегирования](#именование-стадий) _стадии_ (дайджест является только частью тега) в _хранилище_.
werf не собирает стадию, если стадия с таким же _дайджестом_ уже находится в _хранилище_ (это поведение похоже на кэширование в Docker, только имеет более сложную логику).

***Дайджест стадии*** — это контрольная сумма от:
- контрольной суммы [зависимостей стадии](#зависимости-стадии).
- дайджеста предыдущей стадии;
- идентификатора git коммита связанного с предыдущей стадией (если эта стадия связана с git).

_Дайджест_ стадии идентифицирует содержимое стадии и зависит от истории правок в git, которые привели к этому коммиту.

#### Зависимости стадии

_Зависимости стадии_ — это данные, которые напрямую связаны и влияют на [дайджест стадии](#дайджест-стадии). К зависимостям стадии относятся:

- файлы (и их содержимое) из git-репозиториев;
- инструкции сборки стадии из файла `werf.yaml`;
- произвольные строки указанные пользователем в `werf.yaml`
- и т.п.

Большинство _зависимостей стадии_ определяется в файле конфигурации `werf.yaml`, остальные — во время запуска.

Следующая таблица иллюстрирует зависимости в Dockerfile-образе, Stapel-образе и [Stapel-артефакте]({{ "advanced/building_images_with_stapel/artifacts.html" | true_relative_url }}).
Каждая строка таблицы описывает зависимости для определенной стадии. Левая колонка содержит краткое описание зависимостей, правая содержит соответствующую часть `werf.yaml` и ссылки на разделы с более подробной информацией.

<div class="tabs">
  <a href="javascript:void(0)" id="image-from-dockerfile-dependencies" class="tabs__btn dependencies-btn active">Dockerfile-образ</a>
  <a href="javascript:void(0)" id="image-dependencies" class="tabs__btn dependencies-btn">Stapel-образ</a>
  <a href="javascript:void(0)" id="artifact-dependencies" class="tabs__btn dependencies-btn">Stapel-артефакт</a>
</div>

<div id="dependencies">
{% for stage in site.data.stages.ru.entries %}
<div class="stage {{stage.type}}">
  <div class="stage-body">
    <div class="stage-base">
      <p>stage {{ stage.name | escape }}</p>

      {% if stage.dependencies %}
      <div class="dependencies">
        {% for dependency in stage.dependencies %}
        <div class="dependency">
          {{ dependency | escape }}
        </div>
        {% endfor %}
      </div>
      {% endif %}
    </div>

<div class="werf-config" markdown="1">

{% if stage.werf_config %}
```yaml
{{ stage.werf_config }}
```
{% endif %}

{% if stage.references %}
<div class="references">
    Подробнее:
    <ul>
    {% for reference in stage.references %}
        <li><a href="{{ reference.link | true_relative_url }}">{{ reference.name }}</a></li>
    {% endfor %}
    </ul>
</div>
{% endif %}

</div>

    </div>
</div>
{% endfor %}
</div>

<link rel="stylesheet" type="text/css" href="{{ assets["stages.css"].digest_path | true_relative_url }}" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script>
function application() {
  if ($("a[id=image-from-dockerfile-dependencies]").hasClass('active')) {
    $(".image").addClass('hidden');
    $(".artifact").addClass('hidden');
    $(".image-from-dockerfile").removeClass('hidden')
  }
  else if ($("a[id=image-dependencies]").hasClass('active')) {
    $(".image-from-dockerfile").addClass('hidden');
    $(".artifact").addClass('hidden');
    $(".image").removeClass('hidden')
  }
  else if ($("a[id=artifact-dependencies]").hasClass('active')) {
    $(".image-from-dockerfile").addClass('hidden');
    $(".image").addClass('hidden');
    $(".artifact").removeClass('hidden')
  }
  else {
    $(".image-from-dockerfile").addClass('hidden');
    $(".image").addClass('hidden');
    $(".artifact").addClass('hidden')
  }
}

$('.tabs').on('click', '.dependencies-btn', function() {
  $(this).toggleClass('active').siblings().removeClass('active');
  application()
});

application();
$.noConflict();
</script>

<< как это работает





---

>> Организация хранилища

## Хранилище

_Хранилище_ хранит стадии и метаданные проекта. Эти данные могут храниться локально на хост-машине, либо в Docker Repo.

Большинство команд werf используют _стадии_. Такие команды требуют указания места размещения _хранилища_ с помощью ключа `--repo` или переменной окружения `WERF_REPO`.

Существует 2 типа хранилища:
1. _Локальное хранилище_. Использует локальный docker-server для хранения docker-образов.
2. _Удалённое хранилище_. Использует container registry для хранения docker-образов. Включается опцией `--repo=CONTAINER_REGISTRY_REPO`, например, `--repo=registry.mycompany.com/web`. **ЗАМЕЧАНИЕ** Каждый проект должен использовать в качестве хранилища уникальный адрес репозитория, который используется только этим проектом.

Стадии будут [именоваться по-разному](#именование-стадий) в зависимости от типа используемого хранилища.

При использовании container registry для хранения стадий, локальный docker-server на всех хостах, где запускают werf, используется как кеш. Этот кеш может быть очищен автоматически самим werf-ом, либо удалён с помощью других инструментов (например `docker rmi`) без каких-либо последствий.

### Именование стадий

Стадии в _локальном хранилище_ именуются согласно следующей схемы: `PROJECT_NAME:STAGE_DIGEST-TIMESTAMP_MILLISEC`. Например:

```
myproject                   9f3a82975136d66d04ebcb9ce90b14428077099417b6c170e2ef2fef-1589786063772   274bd7e41dd9        16 seconds ago      65.4MB
myproject                   7a29ff1ba40e2f601d1f9ead88214d4429835c43a0efd440e052e068-1589786061907   e455d998a06e        18 seconds ago      65.4MB
myproject                   878f70c2034f41558e2e13f9d4e7d3c6127cdbee515812a44fef61b6-1589786056879   771f2c139561        23 seconds ago      65.4MB
myproject                   5e4cb0dcd255ac2963ec0905df3c8c8a9be64bbdfa57467aabeaeb91-1589786050923   699770c600e6        29 seconds ago      65.4MB
myproject                   14df0fe44a98f492b7b085055f6bc82ffc7a4fb55cd97d30331f0a93-1589786048987   54d5e60e052e        31 seconds ago      64.2MB
```

Стадии в _удалённом хранилище_ именуются согласно следующей схемы: `CONTAINER_REGISTRY_REPO:STAGE_DIGEST-TIMESTAMP_MILLISEC`. Например:

```
localhost:5000/myproject-stages                 d4bf3e71015d1e757a8481536eeabda98f51f1891d68b539cc50753a-1589714365467   7c834f0ff026        20 hours ago        66.7MB
localhost:5000/myproject-stages                 e6073b8f03231e122fa3b7d3294ff69a5060c332c4395e7d0b3231e3-1589714362300   2fc39536332d        20 hours ago        66.7MB
localhost:5000/myproject-stages                 20dcf519ff499da126ada17dbc1e09f98dd1d9aecb85a7fd917ccc96-1589714359522   f9815cec0867        20 hours ago        65.4MB
localhost:5000/myproject-stages                 1dbdae9cc1c9d5d8d3721e32be5ed5542199def38ff6e28270581cdc-1589714352200   6a37070d1b46        20 hours ago        65.4MB
localhost:5000/myproject-stages                 f88cb5a1c353a8aed65d7ad797859b39d357b49a802a671d881bd3b6-1589714347985   5295f82d8796        20 hours ago        65.4MB
localhost:5000/myproject-stages                 796e905d0cc975e718b3f8b3ea0199ea4d52668ecc12c4dbf85a136d-1589714344546   a02ec3540da5        20 hours ago        64.2MB
```

- `PROJECT_NAME` — имя проекта;
- `CONTAINER_REGISTRY_REPO` — репозиторий, заданный опцией `--repo`;
- `STAGE_DIGEST` — дайджест стадии. Дайджест является идентификатором содержимого стадии и также зависит от истории правок в git репозитории, которые привели к такому содержимому.
- `TIMESTAMP_MILLISEC` — уникальный идентификатор, который генерируется в процессе [процедуры сохранения стадии]({{ "internals/build_process.html#сохранение-стадий-в-хранилище" | true_relative_url }}) после того как стадия была собрана.

# Организация хранилища стадий

В данной статье описано, как устроено хранилище собираемых образов в werf, какие бывают типы хранилища, какие функции выполняют эти хранилища, а также различные варианты организации хранилища в проекте.

## Хранилище стадий

werf собирает образы, состоящие из одной или нескольких стадий. Все стадии собираемых образов сохраняются в так называемое **хранилище стадий** по мере сборки.

Есть два вида хранилища стадий: **локальное** и **репозиторий** (container registry).

* Локальное хранилище стадий может быть использовано _только для локальной разработки_ и на данный момент только для сборки образов. В качестве локального хранилища выступает Docker server. Локальное хранилище стадий будет задействовано, например, если вызвать команду `werf build` без аргумента `--repo`.
* Во всех остальных случаях (т.е. кроме локальной разработки) в качестве хранилища стадий всегда выступает репозиторий в container registry. Если запустить сборку с хранилищем стадий в репозитории (например, `werf build` с параметром `--repo ghcr.io/example/myrepo`), то werf сначала проверит наличие требуемых стадий в локальном хранилище и скопирует оттуда подходящие стадии, чтобы не пересобирать эти стадии заново.

Для дальнейших подробностей введём также понятие **инсталляции проекта** — это Git-репозиторий проекта и связанные с ним хранилища стадий в репозитории. Во всех вызовах werf предполагается использование одного и того же Git-репозитория и одних и тех же хранилищ стадий *(может быть указано одно или несколько — подробности см. далее)*.

Также предполагается, что хранилище стадий инсталляции не может быть удалено или очищено сторонними средствами без негативных последствий для работы werf *(например, см. [первичный репозиторий](#первичный-репозиторий))*. Исключение составляют некоторые типы хранилищ, которые могут быть безопасно удалены в любой момент времени *(например, см. [кэширующий репозиторий](#кэширующий-репозиторий))*.

### Первичный репозиторий

* Задаётся параметром `--repo` (или переменной окружения `WERF_REPO`).
* У проекта всегда есть только один такой репозиторий.

Данное хранилище является основным и объединяет в себе несколько функций:

1. История проекта.
  - Хранилище метаданных, связанных с Git-репозиторием, для собираемых образов и стадий.
  - История проекта позволяет реализовать продвинутый алгоритм безопасной очистки старых стадий на основе истории Git-репозитория (команда `werf cleanup`).
2. Синхронизация сборки в распределённом окружении.
  - Данное хранилище позволяет запускать сборку в распределённом окружении и эффективно переиспользовать собираемые стадии в таком окружении. Это возможно за счёт механизмов распределённой синхронизации, встроенных в werf. Эти механизмы работают исключительно с первичным репозиторием.
  - Как только стадия попадает в первичный репозиторий, эта стадия может быть переиспользована другими сборочными процессами, которые могут быть запущены с произвольного хоста.
3. Сборочный кэш ранее собранных стадий.
  - Ранее собранные стадии по возможности переиспользуются вместо того, чтобы собираться заново.
  - Данная функция схожа с привычным локальным сборочным кэшом в Docker server, однако в случае werf этот кэш находится в container registry.
4. Хранилище финальных образов, используемых при запуске приложения в Kubernetes.
  - Kubernetes будет скачивать образы из этого репозитория для запуска контейнеров приложения.
  - В качестве финальных образов напрямую используются те же стадии, из которых состоит собранный образ.

**Очистка (ВАЖНО!).** Для корректной и полноценной работы werf первичный репозиторий должен быть надёжным (persistent) хранилищем, образы из которого удаляются лишь специальной командой очистки `werf cleanup`. Первичный репозиторий — это не просто сборочный кэш проекта, но и хранилище его истории, похожее на историю коммитов в Git-репозитории.

Помимо первичного репозитория в werf есть другие типы репозиториев, которые могут выполнять часть его функций. Они будут рассмотрены далее. Стоит помнить, что **без первичного репозитория werf не работает, а все другие репозитории — дополнительные**; они были созданы, чтобы снять часть функций первичного репозитория в вашей инсталляции проекта.

### Вторичный репозиторий

* Задаётся параметром `--secondary-repo` (или переменной окружения `WERF_SECONDARY_REPO_<NAME>`).
* Может быть указан один или несколько таких репозиториев.

Данное хранилище — это репозиторий только для чтения (read-only), выполняющий функцию сборочного кэша ранее собранных стадий *(см. функции [первичного репозитория](#первичный-репозиторий))*.

Как правило, в качестве secondary-repo может быть указан уже существующий первичный репозиторий от другой инсталляции проекта. Отсутствующие стадии по мере необходимости будут скопированы из вторичного репозитория в первичный вместо сборки с нуля. Вновь собранные же стадии будут помещены только в первичный репозиторий, потому что вторичный репозиторий всегда read-only, т.е. мы не имеем права в него записывать новые данные.

**Очистка** вторичного репозитория не требуется, т.к. этот репозиторий в то же время является первичным для другой инсталляции проекта и его данные управляются там.

### Кэширующий репозиторий

* Задаётся параметром `--cache-repo` (или переменной окружения `WERF_CACHE_REPO_<NAME>`).
* Может быть указан один или несколько таких репозиториев.

Выполняет функцию сборочного кэша ранее собранных стадий *(см. функции [первичного репозитория](#первичный-репозиторий))*. Кэширующий репозиторий отличается от вторичного тем, что он read-write, т.е. используется как для записи новых стадий в кэш, так и для использования собранных стадий из этого кэша.

Существующие стадии будут скопированы из кэширующего репозитория в первичный, поскольку первичный репозиторий обязан содержать все собранные стадии образов проекта. Вновь собранные стадии будут опубликованы и в первичный репозиторий, и в кэширующий репозиторий.

Стадии, которые используются в качестве базовых для сборки новых стадий:
* будут скачиваться из кэша,
* если их нет в кэширующем репозитории — будут скачиваться из первичного репозитория, а затем загружены в кэширующий для дальнейшего использования.

Другими словами, кэширующий репозиторий заполняется не только вновь собираемыми стадиями, но и базовыми стадиями, используемыми для сборки новых стадий.

Кэширующий репозиторий никогда не используется при запуске приложения в Kubernetes.

**Очистка** кэширующего репозитория осуществляется путём его полного удаления. После очистки такой репозиторий будет вновь наполнен актуальными часто используемыми данными.

### Финальный репозиторий

* Задаётся параметром `--final-repo` (или переменной окружения `WERF_FINAL_REPO`).
* Может быть указан только один такой репозиторий.

Данный репозиторий будет использоваться исключительно для публикации финальных образов, задействованных для деплоя приложения в Kubernetes.
- Вновь собираемые образы попадают сначала в первичный репозиторий, и затем копируются в финальный.
- Финальный репозиторий никогда не хранит промежуточные стадии образов, в нем есть лишь последняя стадия образа.
- Финальный репозиторий никогда не хранит промежуточные образы (артефакты), нужные для сборки конечных образов. Сюда попадают только конечные образы, используемые в Kubernetes.

**Очистка** данного репозитория выполняется командой `werf cleanup` в паре с первичным репозиторием (для этого необходимо указывать два параметра команде `werf cleanup`: `--repo` и `--final-repo`).

## Примеры организации хранилища стадий

Рассмотрим варианты использования и комбинации описанных репозиториев. Стоит отметить, что любой из описанных вариантов требует указания [первичного репозитория](#первичный-репозиторий).

### 1. Стандарт

* **Первичный** репозиторий доступен со всех сборочных хостов, а также из кластера Kubernetes. Другие репозитории не используются.
* При сборке образов сборочный кэш будет скачиваться и загружаться в первичный репозиторий. При выкате Kubernetes будет скачивать финальные образы приложения из данного репозитория.
* В большинстве случаев следует использовать именно эту простую схему. Также данная схема подходит, если нет уверенности в том, что требуется для проекта.

### 2. Дополнительный кэш в локальной сети

* **Первичный** репозиторий доступен со всех сборочных хостов, а также из кластера Kubernetes.
* **Кэширующий** репозиторий работает в локальной сети с быстрым доступом.
* При сборке образов сборочный кэш загружается и в первичный репозиторий, и в кэширующий репозиторий. Стадии образов, требуемые для сборки других стадий, будут скачиваться из кэширующего репозитория.

### 3. Полная оптимизация

* **Первичный** репозиторий располагается в локальной сети с быстрым доступом и доступен со всех сборочных хостов. Доступ к данному репозиторию из кластера Kubernetes не требуется. В отличие от кэширующего репозитория, первичный не может быть полностью очищен или удалён без последствий для работы werf, поэтому требуется обеспечить персистивность и надёжность данного хранилища.
* Опционально могут быть подняты дополнительные **кэширующие** репозитории в локальной сети с быстрым доступом.
* **Финальный** репозиторий располагается близко к кластеру Kubernetes для того, чтобы запускаемое приложение быстро скачивало образы приложения (скачивание финальных образов со стороны Kubernetes будет происходить чаще, чем их загрузка со сборочных хостов). Также к финальному репозиторию требуется доступ на запись со всех сборочных хостов. В финальный репозиторий будут загружены лишь конечные образы приложения (без промежуточных образов артефактов, которые нужны для сборки других образов).

<< Организация хранилища








>> Как это работает

# Процесс сборки

Сборочный процесс werf для образов, описанных в [werf.yaml]({{ "reference/werf_yaml.html" | true_relative_url }}), подразумевает [последовательную сборку стадий]({{ "internals/stages_and_storage.html" | true_relative_url }}#конвеер-стадий) для описанных образов.

Несмотря на то, что [_конвейеры стадий_]({{ "internals/stages_and_storage.html#конвеер-стадий" | true_relative_url }}) для Dockerfile-образа, Stapel-образа и Stapel-артефакта отличаются, каждая стадия подчиняется общим правилам [выборки из хранилища](#выборка-стадий), [сохранения](#сохранение-стадий-в-хранилище), а также [работы кеша и блокировок]({{ "advanced/synchronization.html" | true_relative_url }}) в параллельных запусках.

## Сборка стадии Dockerfile-образа

Для сборки Dockerfile-образа werf создает единственную [стадию]({{ "internals/stages_and_storage.html#конвеер-стадий" | true_relative_url }}) — `dockerfile`.

В настоящий момент, при сборке стадии werf использует стандартные команды встроенного в Docker клиента (это аналогично выполнению команды `docker build`), а также аргументы, которые пользователь описывает в `werf.yaml`. Кэш, создаваемый при сборке, используется, как и при обычной сборке, без помощи werf.

Интересной особенностью werf является то, что в качестве сборочного контекста используются файлы не из директории проекта, а из git-репозитория. Все файлы, которые содержатся в директории, заданной директивой `context` (по умолчанию это директория проекта), берутся из текущего коммита репозитория проекта (подробнее про гитерминизм можно почитать [в отдельной статье]({{ "advanced/giterminism.html#dockerfile-образ" | true_relative_url }})).

В итоге сборку стадии `dockerfile` можно представить следующим образом:

```shell
docker build --file=Dockerfile - < ~/.werf/service/tmp/context/4b9d6bc2-a549-42f9-86b8-4032c146f888
```

Подробнее о файле конфигурации сборки `werf.yaml` в [соответствующем разделе]({{ "reference/werf_yaml.html#сборщик-dockerfile" | true_relative_url }}).




## Сборка стадии Stapel-образа и Stapel-артефакта

При сборке стадии предполагается, что инструкции стадии будут запускаться в контейнере, основанном на предыдущей собранной стадии или на [базовом образе]({{ "advanced/building_images_with_stapel/base_image.html#from-fromlatest" | true_relative_url }}). Такой контейнер будет упоминаться далее как **сборочный контейнер**.

Перед запуском _сборочного контейнера_ werf подготавливает набор инструкций, который зависит от типа стадии и содержит как служебные команды werf, так и [пользовательские]({{ "advanced/building_images_with_stapel/assembly_instructions.html" | true_relative_url }}), указанные в конфигурации `werf.yaml`. Например, среди служебных команд может быть добавление файлов, наложение патчей, запуск ansible заданий и т.п.

Stapel-сборщик использует свой набор инструментов и библиотек и никак не зависит от базового образа. При запуске _сборочного контейнера_ werf монтирует всё необходимое из специального служебного образа `registry.werf.io/werf/stapel`. Подробнее об образе можно прочитать [в соответствующей статье]({{ "internals/development/stapel_image.html" | true_relative_url }}).

В _сборочный контейнер_ [пробрасывается сокет ssh-агента с хоста]({{ "internals/integration_with_ssh_agent.html" | true_relative_url }}), а также могут использоваться [пользовательские маунты]({{ "advanced/building_images_with_stapel/mount_directive.html" | true_relative_url }}).

Также стоит отметить, что при сборке werf игнорирует некоторые параметры манифеста базового образа, перетирая их определёнными значениями:
- `--user=0:0`;
- `--workdir=/`;
- `--entrypoint=/.werf/stapel/embedded/bin/bash`.

В итоге запуск _сборочного контейнера_ произвольной стадии можно представить следующим образом:
```shell
docker run \
  --volume=/tmp/ssh-ln8yCMlFLZob/agent.17554:/.werf/tmp/ssh-auth-sock \
  --volumes-from=stapel_0.6.1 \
  --env=SSH_AUTH_SOCK=/.werf/tmp/ssh-auth-sock \
  --user=0:0 \
  --workdir=/ \
  --entrypoint=/.werf/stapel/embedded/bin/bash \
  sha256:d6e46aa2470df1d32034c6707c8041158b652f38d2a9ae3d7ad7e7532d22ebe0 \
  -ec eval $(echo c2V0IC14 | /.werf/stapel/embedded/bin/base64 --decode)
```

Подробнее о файле конфигурации сборки `werf.yaml` в [соответствующем разделе]({{ "reference/werf_yaml.html#stapel-сборщик" | true_relative_url }}).

### Как Stapel-сборщик работает с CMD и ENTRYPOINT

Для сборки стадии werf запускает контейнер со служебными значениями `CMD` и `ENTRYPOINT` а затем, заменяет их значениями [базового образа]({{ "advanced/building_images_with_stapel/base_image.html" | true_relative_url }}). Если в базовом образе эти значения не установлены, werf сбрасывает их следующим образом:
- `[]` для `CMD`;
- `[""]` для `ENTRYPOINT`.

Также werf сбрасывает (использует специальные пустые значения) значение `ENTRYPOINT` базового образа, если указано значение `CMD` в конфигурации (`docker.CMD`).

В противном случае поведение werf аналогично [поведению Docker](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).

<< Как это работает



>> Закрытый контур (не важно)

### Как использовать Stapel-сборщик в закрытом контуре

При запуске _сборочного контейнера_ werf монтирует инструментарий из специального образа, имя и тег которого зашиты в коде.

Для сборки со Stapel в закрытом контуре (без доступа к служебному образу) необходимо загрузить образ в доступный container registry и переопределить имя с помощью переменных окружения `WERF_STAPEL_IMAGE_NAME` и `WERF_STAPEL_IMAGE_VERSION` (например, `WERF_STAPEL_IMAGE_NAME=localhost:5000/stapel` и `WERF_STAPEL_IMAGE_VERSION=0.6.2`).

<< Закрытый контур (не важно)




>> Как это работает

## Выборка стадий

Алгоритм выборки стадии в werf можно представить следующим образом:

1. Рассчитывается [дайджест стадии]({{ "internals/stages_and_storage.html#дайджест-стадии" | true_relative_url }}).
2. Выбираются все стадии, подходящие под дайджест, т.к. с одним дайджестом может быть связанно несколько стадий в [хранилище]({{ "internals/stages_and_storage.html#хранилище" | true_relative_url }}).
3. Выбирается старейший по времени `TIMESTAMP_MILLISEC` (подробнее про именование стадий [здесь]({{ "internals/stages_and_storage.html#именование-стадий" | true_relative_url }})).

### Дополнение для Stapel-образов и Stapel-артефактов

К основному алгоритму добавляется проверка родства git-коммитов. После шага **2** выполняется дополнительный отсев с использованием истории git: если текущая стадия связана с git (стадия git-архив, пользовательская стадия с git-патчами или стадия git latest patch), тогда выбираются только те стадии, которые связаны с коммитами, являющимися предками текущего коммита. Таким образом, коммиты соседних веток будут отброшены.

Возможна ситуация когда существует несколько собранных образов с одинаковым дайджестом. Более того, стадии для разных git-веток могут иметь одинаковую дайджест. Однако werf гарантированно предотвращает переиспользование кеша между несвязанными ветками. Кеш в разных ветках может быть переиспользован только если этот кеш относится к коммиту, который является базовым, как для одной ветки, так и для другой.

## Сохранение стадий в хранилище

Множество процессов werf (на одном хосте или на нескольких хостах) могут инициировать сборку одной и той же стадии в один момент времени, потому что этой стадии еще нет в хранилище.

werf использует алгоритм оптимистичных блокировок в процессе сохранения свежесобранного образа в хранилище. Когда сборка нового образа закончена, werf блокирует хранилище на любые операции с целевым дайджестом:
- Если за время сборки подходящего образа не появилось в хранилище, то werf сохраняет новый образ, сгенерировав гарантированно уникальный идентификатор `TIMESTAMP_MILLISEC`.
- Если за время сборки подходящий образ появился в хранилище, то werf отбрасывает свежесобранный образ, а вместо него использует появившийся в хранилище образ.

Другими словами: первый процесс, который закончит сборку новой стадии (самый быстрый процесс) получит шанс сохранить собранный образ в хранилище. Медленный процесс сборки не будет блокировать более быстрые процессы в параллельной и распределенной среде.

В процессе выборки и сохранения новых стадий в хранилище werf использует [менеджер блокировок]({{ "advanced/synchronization.html" | true_relative_url }}) для координации работы нескольких процессов werf.

<< Как это работает





>> Конфигурация сборщика

## Параллельная сборка

Параллельная сборка в werf регулируется двумя параметрами `-p, --parallel` и `--parallel-tasks-limit`. По умолчанию параллельная сборка включена и собирается не более 5 образов одновременно.

После построение дерева зависимостей образов, werf разбивает сборку на этапы. Каждый этап содержит набор независимых образов, которые могут собираться параллельно.

```shell
┌ Concurrent builds plan (no more than 5 images at the same time)
│ Set #0:
│ - ⛵ image common-base
│ - 🛸 artifact jq
│ - 🛸 artifact libjq
│ - 🛸 artifact kcov
│
│ Set #1:
│ - ⛵ image base-for-go
│
│ Set #2:
│ - 🛸 artifact terraform-provider-vsphere
│ - 🛸 artifact terraform-provider-gcp
│ - 🛸 artifact candictl
│ - ⛵ image candictl-tests
│ - 🛸 artifact helm
│ - 🛸 artifact controller
│
│ Set #3:
│ - ⛵ image base
│
│ Set #4:
│ - ⛵ image tests
│ - ⛵ image app
└ Concurrent builds plan (no more than 5 images at the same time)
```

## Buildah

werf поддерживает использование Buildah в экспериментальном режиме для сборки образов.

При этом процесс сборки не изменился, перемены коснулись только бэкенда контейнеров и хранилища (сервер Docker был заменен на Buildah).

Более подробную информацию о Buildah можно получить в разделе [Режим сборки с использованием Buildah.]({{ "/advanced/buildah_mode.html" | true_relative_url }})

# Режим сборки с использованием Buildah

> ПРИМЕЧАНИЕ: werf поддерживает сборку образов с _использованием Docker-сервера_ или _с использованием Buildah_. Поддерживается сборка как Dockerfile-образов, так и stapel-образов через Buildah.

Для сборки без Docker-сервера werf использует встроенный Buildah в rootless-режиме.

## Системные требования

Требования к хост-системе для запуска werf в Buildah-режиме без Docker/Kubernetes можно найти в [инструкциях по установке](/installation.html). А для запуска werf в Kubernetes или в Docker-контейнерах требования следующие:
* Если ваше ядро Linux версии 5.13+ (в некоторых дистрибутивах 5.11+) **рекомендуется** режим работы через модуль ядра `overlay`:
  * Убедитесь, что модуль ядра `overlay` загружен с `lsmod | grep overlay`.
  * Убедитесь, что настройка ядра `CONFIG_USER_NS=y` включена в вашем ядре с помощью `grep CONFIG_USER_NS /boot/config-VERSION`.
  * При использовании ядра в debian-системах команда `sysctl kernel.unprivileged_userns_clone` должна вернуть `1`. В ином случае выполните:
    ```shell
    echo 'kernel.unprivileged_userns_clone = 1' | sudo tee -a /etc/sysctl.conf
    sudo sysctl -p
    ```
  * Команда `sysctl user.max_user_namespaces` должна вернуть по меньшей мере `15000`. В ином случае выполните:
    ```shell
    echo 'user.max_user_namespaces = 15000' | sudo tee -a /etc/sysctl.conf
    sudo sysctl -p
    ```
* Если ядро более старое или у вас не получается активировать модуль ядра `overlay`, то установите `fuse-overlayfs`, который обычно доступен в репозиториях вашего дистрибутива. В крайнем случае может быть использован драйвер хранилища `vfs`.



>> Конфигурация сборщика

## Включение Buildah

Buildah включается установкой переменной окружения `WERF_BUILDAH_MODE` в один из вариантов: `auto`, `native-chroot`, `native-rootless`. Большинству пользователей для включения режима Buildah достаточно установить `WERF_BUILDAH_MODE=auto`.

* `auto` — автоматический выбор режима в зависимости от платформы и окружения;
* `native-chroot` работает только в Linux и использует `chroot`-изоляцию для сборочных контейнеров;
* `native-rootless` работает только в Linux и использует `rootless`-изоляцию для сборочных контейнеров. На этом уровне изоляции werf использует среду выполнения сборочных операций в контейнерах (runc, crun, kata или runsc).

> ПРИМЕЧАНИЕ: На данный момент Buildah доступен только для пользователей Linux и Windows с включённой подсистемой WSL2. Для пользователей MacOS на данный момент предлагается использование виртуальной машины для запуска werf в режиме Buildah.

## Драйвер хранилища

werf может использовать драйвер хранилища `overlay` или `vfs`:

* `overlay` позволяет использовать файловую систему OverlayFS. Можно использовать либо встроенную в ядро Linux поддержку OverlayFS (если она доступна), либо реализацию fuse-overlayfs. Это рекомендуемый выбор по умолчанию.
* `vfs` обеспечивает доступ к виртуальной файловой системе вместо OverlayFS. Эта файловая система уступает по производительности и требует привилегированного контейнера, поэтому ее не рекомендуется использовать. Однако в некоторых случаях она может пригодиться.

Как правило, достаточно использовать драйвер по умолчанию (`overlay`). Драйвер хранилища можно задать с помощью переменной окружения `WERF_BUILDAH_STORAGE_DRIVER`.

## Ulimits

По умолчанию Buildah режим в werf наследует системные ulimits при запуске сборочных контейнеров. Пользователь может переопределить эти параметры с помощью переменной окружения `WERF_BUILDAH_ULIMIT`.

Формат `WERF_BUILDAH_ULIMIT=type:softlimit[:hardlimit][,type:softlimit[:hardlimit],...]` — конфигурация лимитов, указанные через запятую:
* "core": maximum core dump size (ulimit -c)
* "cpu": maximum CPU time (ulimit -t)
* "data": maximum size of a process's data segment (ulimit -d)
* "fsize": maximum size of new files (ulimit -f)
* "locks": maximum number of file locks (ulimit -x)
* "memlock": maximum amount of locked memory (ulimit -l)
* "msgqueue": maximum amount of data in message queues (ulimit -q)
* "nice": niceness adjustment (nice -n, ulimit -e)
* "nofile": maximum number of open files (ulimit -n)
* "nproc": maximum number of processes (ulimit -u)
* "rss": maximum size of a process's (ulimit -m)
* "rtprio": maximum real-time scheduling priority (ulimit -r)
* "rttime": maximum amount of real-time execution between blocking syscalls
* "sigpending": maximum number of pending signals (ulimit -i)
* "stack": maximum stack size (ulimit -s)

<< Конфигурация сборщика


>> Как это работает

# Git worktree

Для корректной работы сборщика stapel werf-у требуется полная git-история проекта, чтобы работать в наиболее эффективном режиме. Поэтому по умолчанию werf выполняет fetch истории для текущего git проекта, когда это требуется. Это означает, что werf может автоматически сконвертировать shallow-clone репозитория в полный clone и скачать обновлённый список веток и тегов из origin в процессе очистки образов.

Поведение по умолчанию описывается следующими настройками:

```yaml
gitWorktree:
  forceShallowClone: false
  allowUnshallow: true
  allowFetchOriginBranchesAndTags: true
```

Чтобы, например, выключить автоматический unshallow рабочей директории git, необходимы следующие настройки:

```yaml
gitWorktree:
  forceShallowClone: true
  allowUnshallow: false
```

<< Как это работает


>> Как это работает

# Синхронизация в werf

Синхронизация — это группа сервисных компонентов werf, предназначенных для координации нескольких процессов werf при выборке и сохранении стадий в хранилище, а также при публикации образов в репозиторий образов. Существует 2 таких компонента для синхронизации:

1. _Кеш хранилища_ — это внутренний служебный кеш werf, который существенно повышает производительность фазы расчёта стадий в случае, если эти стадии уже есть в хранилище. Кеш хранилища содержит соответствие существующих в хранилище с дайджестом (или другими словами: содержит предварительно рассчитанный шаг алгоритма выборки стадий по дайджесту). Данный кеш является когерентным и werf автоматически сбрасывает его, если будет замечена несостыковка между хранилищем стадий и кешом хранилища.
2. _Менеджер блокировок_. Блокировки требуются для корректной публикации новых стадий в хранилище, публикации новых образов в репозиторий образов и для организации параллельных процессов выката в Kubernetes (блокируется имя релиза).

Все команды, использующие параметры хранилища (`--repo=...`) также требуют указания адреса менеджера блокировок, который задается опцией `--synchronization=...` или переменной окружения `WERF_SYNCHRONIZATION=...`.

Существует 2 типа наборов компонентов для синхронизации:
1. Локальный. Включается опцией `--synchronization=:local`.
- Локальный _кеш хранилища_ располагается по умолчанию в файлах `~/.werf/shared_context/storage/stages_storage_cache/1/PROJECT_NAME/DIGEST`, каждый из которых хранит соответствие существующих в хранилище по некоторому дайджесту.
- Локальный _менеджер блокировок_ использует файловые блокировки, предоставляемые операционной системой.
2. Kubernetes. Включается опцией `--synchronization=kubernetes://NAMESPACE[:CONTEXT][@(base64:CONFIG_DATA)|CONFIG_PATH]`.
- _Кеш хранилища_ в Kubernetes использует для каждого проекта отдельный ConfigMap `cm/PROJECT_NAME`, который создается в указанном `NAMESPACE`.
- _Менеджер блокировок_ в Kubernetes использует ConfigMap по имени проекта `cm/PROJECT_NAME` (тот же самый что и для кеша хранилища) для хранения распределённых блокировок в аннотациях этого ConfigMap. werf использует [библиотека lockgate](https://github.com/werf/lockgate), которая реализует распределённые блокировки с помощью обновления аннотаций в ресурсах Kubernetes.
3. Http. Включается опцией `--synchronization=http[s]://DOMAIN`.
- Есть публичный сервер синхронизации доступный по домену `https://synchronization.werf.io`.
- Собственный http сервер синхронизации может быть запущен командой `werf synchronization`.

werf использует `--synchronization=:local` (локальный _кеш хранилища_ и локальный _менеджер блокировок_) по умолчанию, если используется локальное хранилище.

werf использует `--synchronization=https://synchronization.werf.io` по умолчанию, если используется удалённое хранилище (`--repo=CONTAINER_REGISTRY_REPO`).

Пользователь может принудительно указать произвольный адрес компонентов для синхронизации, если это необходимо, с помощью явного указания опции `--synchronization=:local|(kubernetes://NAMESPACE[:CONTEXT][@(base64:CONFIG_DATA)|CONFIG_PATH])|(http[s]://DOMAIN)`.

**ЗАМЕЧАНИЕ:** Множество процессов werf, работающих с одним и тем же проектом обязаны использовать одинаковое хранилище и адрес набора компонентов синхронизации.

<< Как это работает

>> Дизайн стапеля

## Запуск инструкций сборки

### Пользовательские стадии

***Пользовательские стадии*** — это [_стадии_]({{ "internals/stages_and_storage.html" | true_relative_url }}) со сборочными инструкциями из [конфигурации]({{ "reference/werf_yaml.html#секция-image" | true_relative_url }}). Другими словами — это стадии, конфигурируемые пользователем (существуют также служебные стадии, которые пользователь конфигурировать не может). В настоящее время существует два вида сборочных инструкций: _shell_ и _ansible_.

werf поддерживает четыре _пользовательские стадии_, которые выполняются последовательно в следующем порядке: _beforeInstall_, _install_, _beforeSetup_ и _setup_. В результате выполнения инструкций пользовательской стадии создается один Docker-слой. Т.е. по одному слою на каждую стадию вне зависимости от количества инструкций.

### Использование пользовательских стадий

werf позволяет определять до четырех _пользовательских стадий_ с инструкциями сборки. На содержание самих инструкций сборки werf не накладывает каких-либо ограничений, т.е. вы можете указывать все те же инструкции, которые указывали в Dockerfile в директиве `RUN`. Однако важно не просто перенести инструкции из Dockerfile, а правильно разбить их на _пользовательские стадии_. Исходя из опыта работы с реальными приложениями, мы пришли к заключению, что сборка большинства приложений проходит следующие этапы:

- установка системных пакетов;
- установка системных зависимостей;
- установка зависимостей приложения;
- настройка системных пакетов;
- настройка приложения.

Какая может быть наилучшая стратегия выполнения этих этапов?

Первая мысль — лучше выполнять эти этапы последовательно, кэшируя промежуточные результаты, а с другой стороны – разбивать инструкции по файловым зависимостям.

Подход с _пользовательскими стадиями_ предлагает следующую стратегию:
- использовать стадию _beforeInstall_ для инсталляции системных пакетов;
- использовать стадию _install_ для инсталляции системных зависимостей и зависимостей приложения;
- использовать стадию _beforeSetup_ для настройки системных параметров и установки приложения;
- использовать стадию _setup_ для настройки приложения.

#### beforeInstall

Данная стадия предназначена для выполнения инструкций перед установкой приложения.
Этот этап предназначен для системных приложений, которые редко изменяются, но требуют много времени для установки.
Примером таких приложений могут быть языковые пакеты или инструменты сборки, такие как Composer, Java, Gradle и т.д.
Также сюда можно добавлять инструкции настройки системы, которые редко изменяются.
Например, языковые настройки, настройки часового пояса, добавление пользователей и групп.

Поскольку эти компоненты меняются редко, они будут кэшироваться в рамках стадии _beforeInstall_ на длительный период.

#### install

Данная стадия предназначена для установки приложения и его зависимостей, а также выполнения базовых настроек.

На данной стадии появляется доступ к исходному коду используемых Git-репозиториев (директива `git`) и появляется возможность установки зависимостей на основе manifest-файлов с использованием таких инструментов, как Composer, Gradle, npm и т.д. Поскольку сборка стадии зависит от manifest-файла, для достижения наилучшего результата важно добавить зависимость от изменений в manifest-файлах репозитория для этой стадии. Например, если в проекте используется Composer, то добавление файла `composer.lock` в зависимости стадии _beforeInstall_ позволит пересобирать стадию при изменении файла `composer.lock`.

#### beforeSetup

Данная стадия предназначена для подготовки приложения перед настройкой.

На данной стадии рекомендуется выполнять разного рода компиляцию и обработку.
Например, компиляция jar-файлов, бинарных файлов, файлов библиотек, создание ассетов web-приложений, минификация, шифрование и т.п.
Перечисленные операции, как правило, зависят от изменений в исходном коде, и на данной стадии также важно определить достаточные зависимости от изменений в репозитории. Логично, что стадия будет зависеть от большего числа файлов в репозитории, чем на предыдущей стадии, и, соответственно, ее пересборка будет выполняться чаще.

При правильно определенных зависимостях изменения в коде приложения должны приводить к пересборке стадии _beforeSetup_, а изменение manifest-файла к стадии _install_ и последующих стадий.

#### setup

Данная стадия предназначена для настройки приложения.

Обычно на данной стадии выполняется копирование файлов конфигурации (например, в папку `/etc`), создание файлов текущей версии приложения и т.д.
Такого рода операции не должны быть затратными по времени, т.к. они, скорее всего, будут выполняться в большинстве сборок.

#### Пользовательская стратегия

Несмотря на изложенную четкую стратегию шаблона _пользовательских стадий_ и функции каждой стадии, по сути для пользователя нет никаких ограничений. Предложенное использование стадий является лишь рекомендацией, которая основана на нашем опыте с реальными приложениями. Вы можете использовать только одну пользовательскую стадию, либо определить свою стратегию группировки инструкций, чтобы получить преимущества кэширования и зависимостей от изменений в Git-репозиториях с учетом особенностей сборки вашего приложения.

### Синтаксис

Пользовательские стадии и инструкции сборки определяются внутри двух взаимоисключающих директив — `shell` и `ansible`. Каждый образ может собираться либо используя сборочные инструкции ***shell***, либо задачи ***ansible***, описанные в соответствующих директивах.

В каждой директиве можно описывать инструкции для _пользовательских стадий_, соответственно:
- `beforeInstall`;
- `install`;
- `beforeSetup`;
- `setup`.

Также можно указывать директивы версий кэша (***cacheVersion***), которые по сути являются частью дайджеста каждой _пользовательской стадии_. Более подробно [в соответствующем разделе](#зависимость-от-значения-cacheversion).

### Shell

Синтаксис описания _пользовательских стадий_ при использовании сборочных инструкций _shell_:

```yaml
shell:
  beforeInstall:
  - <bash_command 1>
  - <bash_command 2>
  ...
  - <bash_command N>
  install:
  - bash command
  ...
  beforeSetup:
  - bash command
  ...
  setup:
  - bash command
  ...
  cacheVersion: <version>
  beforeInstallCacheVersion: <version>
  installCacheVersion: <version>
  beforeSetupCacheVersion: <version>
  setupCacheVersion: <version>
```

Сборочные инструкции _shell_ — это массив Bash-команд для соответствующей _пользовательской стадии_. Все команды одной стадии выполняются как одна инструкция `RUN` в Dockerfile, т.е. в результате создается один слой на каждую _пользовательскую стадию_.

werf при сборке использует собственный исполняемый файл `bash`, и вам не нужно отдельно добавлять его в образ (или [базовый образ]({{ "advanced/building_images_with_stapel/base_image.html" | true_relative_url }})) при сборке.

Пример описания стадии _beforeInstall_ содержащей команды `apt-get update` и `apt-get install`:

```yaml
beforeInstall:
- apt-get update
- apt-get install -y build-essential g++ libcurl4
```

Исполняемый файл `bash` находится внутри Docker-тома _stapel_. Подробнее про эту концепцию можно узнать [в этой статье](https://habr.com/company/flant/blog/352432/) (упоминаемый в статье `dappdeps` был переименован в `stapel`, но принцип сохранился)

### Ansible

Синтаксис описания _пользовательских стадий_ при использовании сборочных инструкций _ansible_:

```yaml
ansible:
  beforeInstall:
  - <ansible task 1>
  - <ansible task 2>
  ...
  - <ansible task N>
  install:
  - ansible task
  ...
  beforeSetup:
  - ansible task
  ...
  setup:
  - ansible task
  ...
  cacheVersion: <version>
  beforeInstallCacheVersion: <version>
  installCacheVersion: <version>
  beforeSetupCacheVersion: <version>
  setupCacheVersion: <version>
```

#### Ansible config и stage playbook

Сборочные инструкции _ansible_ — это массив Ansible-заданий для соответствующей _пользовательской стадии_.

Сгенерированный `ansible.cfg` содержит настройки для Ansible:
- использование локального транспорта (transport = local);
- подключение callback плагина werf для удобного логирования (stdout_callback = werf);
- включение режима цвета (force_color = 1);
- установка использования `sudo` для повышения привилегий (чтобы не было необходимости использовать `become` в Ansible-заданиях).

Сгенерированный `playbook.yml` — playbook, содержащий все задания соответствующей _пользовательской стадии_. Пример `werf.yaml` с описанием стадии _install_:

```yaml
ansible:
  install:
  - debug: msg='Start install'
  - file: path=/etc mode=0777
  - copy:
      src: /bin/sh
      dest: /bin/sh.orig
  - apk:
      name: curl
      update_cache: yes
  ...
```

Исполняемые файлы и библиотеки `ansible` и `python` находятся внутри Docker-тома _stapel_. Подробнее про эту концепцию можно узнать [в этой статье](https://habr.com/company/flant/blog/352432/) (упоминаемый в статье `dappdeps` был переименован в `stapel`, но принцип сохранился)

#### Поддерживаемые модули

Одной из концепций, которую использует werf, является идемпотентность сборки. Это значит, что если «ничего не изменилось», то werf при повторном и последующих запусках сборки должен создавать бинарно идентичные образы. В werf эта задача решается с помощью подсчета _дайджестов стадий_.

Многие модули Ansible не являются идемпотентными, т.е. они могут давать разный результат запусков при неизменных входных параметрах. Это, конечно, не дает возможность корректно высчитывать _дайджест_ стадии, чтобы определять реальную необходимость её пересборки из-за изменений. Это привело к тому, что список поддерживаемых модулей был ограничен.

На текущий момент, список поддерживаемых модулей Ansible следующий:

- [Commands modules](https://docs.ansible.com/ansible/2.5/modules/list_of_commands_modules.html): command, shell, raw, script.
- [Crypto modules](https://docs.ansible.com/ansible/2.5/modules/list_of_crypto_modules.html): openssl_certificate и другие.
- [Files modules](https://docs.ansible.com/ansible/2.5/modules/list_of_files_modules.html): acl, archive, copy, stat, tempfile и другие.
- [Net Tools Modules](https://docs.ansible.com/ansible/2.5/modules/list_of_net_tools_modules.html): get_url, slurp, uri.
- [Packaging/Language modules](https://docs.ansible.com/ansible/2.5/modules/list_of_packaging_modules.html#language): composer, gem, npm, pip и другие.
- [Packaging/OS modules](https://docs.ansible.com/ansible/2.5/modules/list_of_packaging_modules.html#os): apt, apk, yum и другие.
- [System modules](https://docs.ansible.com/ansible/2.5/modules/list_of_system_modules.html): user, group, getent, locale_gen, timezone, cron и другие.
- [Utilities modules](https://docs.ansible.com/ansible/2.5/modules/list_of_utilities_modules.html): assert, debug, set_fact, wait_for.

При указании в _конфигурации сборки_ модуля, отсутствующего в приведенном списке, сборка прервется с ошибкой. Не стесняйтесь [сообщать](https://github.com/werf/werf/issues/new) нам, если вы считаете что какой-либо модуль должен быть включен в список поддерживаемых.

#### Копирование файлов

Предпочтительный способ копирования файлов в образ — использование [_git mapping_]({{ "advanced/building_images_with_stapel/git_directive.html" | true_relative_url }}).
werf не может определять изменения в копируемых файлах при использовании модуля `copy`.
Единственный вариант копирования внешнего файла в образ на текущий момент — использовать метод `.Files.Get` Go-шаблона.
Данный метод возвращает содержимое файла как строку, что дает возможность использовать содержимое как часть _пользовательской стадии_.
Таким образом, при изменении содержимого файла изменится дайджест соответствующей стадии, что приведет к пересборке всей стадии.

Пример копирования файла `nginx.conf` в образ:

{% raw %}
```yaml
ansible:
  install:
  - copy:
      content: |
{{ .Files.Get "/conf/etc/nginx.conf" | indent 8}}
      dest: /etc/nginx/nginx.conf
```
{% endraw %}

В результате получится подобный `playbook.yml`:

```yaml
- hosts: all
  gather_facts: no
  tasks:
    install:
    - copy:
        content: |
          http {
            sendfile on;
            tcp_nopush on;
            tcp_nodelay on;
            ...
```

#### Шаблоны Jinja

В Ansible реализована поддержка шаблонов [Jinja](https://docs.ansible.com/ansible/2.5/user_guide/playbooks_templating.html) в playbook'ах. Однако у Go-шаблонов и Jinja-шаблонов одинаковый разделитель: {% raw %}`{{` и `}}`{% endraw %}. Чтобы использовать Jinja-шаблоны в конфигурации werf, их нужно экранировать. Для этого есть два варианта: экранировать только {% raw %}`{{`{% endraw %}, либо экранировать все выражение шаблона Jinja.

Например, у вас есть следующая задача Ansible:

{% raw %}
```yaml
- copy:
    src: {{item}}
    dest: /etc/nginx
    with_files:
    - /app/conf/etc/nginx.conf
    - /app/conf/etc/server.conf
```
{% endraw %}

{% raw %}
Тогда, выражение Jinja-шаблона `{{item}}` должно быть экранировано:
{% endraw %}

{% raw %}
```yaml
# Экранируем только {{.
src: {{"{{"}} item }}
```
либо
```yaml
# Экранируем все выражение.
src: {{`{{item}}`}}
```
{% endraw %}

#### Проблемы с Ansible

- Live-вывод реализован только для модулей `raw` и `command`. Остальные модули отображают вывод каналов `stdout` и `stderr` после выполнения, что приводит к задержкам и скачкообразному выводу.
- Модуль `apt` подвисает на некоторых версиях Debian и Ubuntu. Проявляется также на наследуемых образах ([issue #645](https://github.com/werf/werf/issues/645)).

### Переменные окружения сборочного контейнера

Вы можете использовать сервисные переменные окружения, которые доступны в сборочном контейнере, и, соответственно, доступны в инструкциях сборки. Их использование не приведёт к изменению инструкций сборки и вытекающим из этого пересборкам, даже если сами значения сервисных переменных меняются.

Доступны следующие переменные:
- `WERF_COMMIT_HASH`. Пример значения: `cda9d17265d174c62424e8f7b5e5640bf749c565`.
- `WERF_COMMIT_TIME_HUMAN`. Пример значения: `2022-01-24 17:26:19 +0300 +0300`.
- `WERF_COMMIT_TIME_UNIX`. Пример значения: `1643034379`.

Пример использования:
{% raw %}
```yaml
shell:
  install:
  - echo "Commands on the Install stage for $WERF_COMMIT_HASH"
```
{% endraw %}

В примере выше хэш текущего коммита будет подставлен в команду `echo ...`, но произойдет это в самый последний момент — на этапе выполнения инструкций shell'ом. Таким образом пересборок слоя install на каждом коммите происходить не будет.

### Зависимости пользовательских стадий

Одна из особенностей werf — возможность определять зависимости, при которых происходит пересборка _стадии_.
Как указано [в статье]({{ "internals/stages_and_storage.html" | true_relative_url }}), сборка _стадий_ выполняется последовательно, одна за другой, и для каждой _стадии_ высчитывается _дайджест стадии_. У _дайджестов_ есть ряд зависимостей, при изменении которых _дайджест стадии_ меняется, что служит для werf сигналом для пересборки стадии с измененным _дайджестом_. Поскольку каждая следующая _стадия_ имеет зависимость, в том числе и от предыдущей _стадии_ согласно _конвейеру стадий_, при изменении дайджеста какой-либо _стадии_ произойдет пересборка и _стадии_ с изменённым дайджестом и всех последующих _стадий_.

_Дайджест пользовательских стадий_ и, соответственно, пересборка _пользовательских стадий_ зависят от изменений:
- в инструкциях сборки;
- в директивах семейства _cacheVersion_;
- в Git-репозитории (или Git-репозиториях);
- в файлах, импортируемых из [артефактов]({{ "advanced/building_images_with_stapel/artifacts.html" | true_relative_url }}).

Первые три описанных варианта зависимостей рассматриваются подробно далее.

### Зависимость от изменений в инструкциях сборки

_Дайджест пользовательской стадии_ зависит от итогового текста инструкций, т.е. после применения шаблонизатора. Любые изменения в тексте инструкций с учетом применения шаблонизатора Go или Jinja (в случае Ansible) в _пользовательской стадии_ приводят к пересборке _стадии_. Например, вы используете следующие _shell-инструкции_:

```yaml
shell:
  beforeInstall:
  - echo "Commands on the Before Install stage"
  install:
  - echo "Commands on the Install stage"
  beforeSetup:
  - echo "Commands on the Before Setup stage"
  setup:
  - echo "Commands on the Setup stage"
```

При первой сборке этого образа будут выполнены инструкции всех четырех _пользовательских стадий_.
В данной конфигурации нет _git mapping_, так что последующие сборки не приведут к повторному выполнению инструкций — _дайджест пользовательских стадий_ не изменилась, сборочный кэш содержит актуальную информацию.

Изменим инструкцию сборки для стадии _install_:

```yaml
shell:
  beforeInstall:
  - echo "Commands on the Before Install stage"
  install:
  - echo "Commands on the Install stage"
  - echo "Installing ..."
  beforeSetup:
  - echo "Commands on the Before Setup stage"
  setup:
  - echo "Commands on the Setup stage"
```

Дайджест стадии _install_ изменилась, и запуск werf для сборки приведет к выполнению всех инструкций стадии _install_ и инструкций последующих _стадий_, т.е. _beforeSetup_ и _setup_.

Дайджест стадии может меняться также из-за использования переменных окружения и Go-шаблонов.
Если не уделять этому достаточное внимание при написании конфигурации, можно столкнуться с неожиданными пересборками стадий. Например:

{% raw %}
```yaml
shell:
  beforeInstall:
  - echo "Commands on the Before Install stage for {{ env "CI_COMMIT_SHA” }}"
  install:
  - echo "Commands on the Install stage"
  ...
```
{% endraw %}

Первая сборка высчитает дайджест стадии _beforeInstall_ на основе команды (хэш коммита, конечно, будет другой):
```shell
echo "Commands on the Before Install stage for 0a8463e2ed7e7f1aa015f55a8e8730752206311b"
```

После очередного коммита, при сборке дайджест стадии _beforeInstall_ уже будет другой (с других хешем коммита):

```shell
echo "Commands on the Before Install stage for 36e907f8b6a639bd99b4ea812dae7a290e84df27"
```

Соответственно, используя переменную `CI_COMMIT_SHA` дайджест стадии _beforeInstall_ будет меняться после каждого коммита, что будет приводить к пересборке.

### Зависимость от изменений в Git-репозитории

<a class="google-drawings" href="{{ "images/configuration/assembly_instructions3.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/configuration/assembly_instructions3_preview.png" | true_relative_url }}" alt="Зависимость от изменений в git-репозитории">
</a>

Как описывалось в статье [про _git mapping_]({{ "advanced/building_images_with_stapel/git_directive.html" | true_relative_url }}), существуют специальные стадии _gitArchive_ и _gitLatestPatch_.
Стадия _gitArchive_ выполняется после пользовательской стадии _beforeInstall_, а стадия _gitLatestPatch_ после пользовательской стадии _setup_, если в локальном Git-репозитории есть изменения.
Таким образом, чтобы выполнить сборку с последней версией исходного кода, можно пересобрать стадию _beforeInstall_, изменив значение директивы _cacheVersion_ либо изменив сами инструкции стадии _beforeInstall_.

Пользовательские стадии _install_, _beforeSetup_ и _setup_ также могут зависеть от изменений в Git-репозитории. В этом случае (если такая зависимость определена) Git-патч применяется перед выполнением инструкций _пользовательской стадии_, чтобы сборочные инструкции выполнялись с актуальной версией кода приложения.

> Во время процесса сборки исходный код обновляется **только в рамках одной стадии**, последующие стадии, зависящие последовательно друг от друга, будут использовать также обновленную версию файлов.
> Первая сборка добавляет файлы из Git-репозитория на стадии _gitArchive_. Все последующие сборки обновляют файлы на стадии _gitCache_, _gitLatestPatch_ или на одной из следующих пользовательских стадий: _install_, _beforeSetup_, _setup_.
<br />
<br />
Пример этого этапа (фаза подсчета дайджестов, _calculating digests_):
![git files actualized on specific stage]({{ "images/build/git_mapping_updated_on_stage.png" | true_relative_url }})

Зависимость _пользовательской стадии_ от изменений в Git-репозитории указывается с помощью параметра `git.stageDependencies`. Синтаксис:

```yaml
git:
- ...
  stageDependencies:
    install:
    - <mask 1>
    ...
    - <mask N>
    beforeSetup:
    - <mask>
    ...
    setup:
    - <mask>
```

У параметра `git.stageDependencies` возможно указывать 3 ключа: `install`, `beforeSetup` и `setup`.
Значение каждого ключа — массив масок файлов, относящихся к соответствующей стадии. Соответствующая _пользовательская стадия_ пересобирается, если в Git-репозитории происходят изменения подпадающие под указанную маску.

Для каждой _пользовательской стадии_ werf создает список подпадающих под маску файлов и вычисляет контрольную сумму каждого файла с учетом его аттрибутов и содержимого. Эти контрольные суммы являются частью _дайджеста стадии_, поэтому любое изменение файлов в репозитории, подпадающее под маску, приводит к изменениям _дайджеста стадии_. К этим изменениям относятся: изменение атрибутов файла, изменение содержимого файла, добавление или удаление подпадающего под маску файла и т.п.

При применении маски, указанной в `git.stageDependencies`, учитываются значения параметров `git.includePaths` и `git.excludePaths` (смотри подробнее про них [в соответствующем разделе]({{ "advanced/building_images_with_stapel/git_directive.html#использование-фильтров" | true_relative_url }})). werf считает подпадающими под маску только файлы, удовлетворяющие фильтру `includePaths` и подпадающие под маску `stageDependencies`. Аналогично werf считает подпадающими под маску только файлы, не удовлетворяющие фильтру `excludePaths` и не подпадающие под маску `stageDependencies`.

Правила описания маски в параметре `stageDependencies` аналогичны описанию параметров `includePaths` и `excludePaths`. Маска определяет шаблон для файлов и путей и может содержать следующие шаблоны:

- `*` — Удовлетворяет любому файлу. Шаблон включает `.` и исключает `/`.
- `**` — Удовлетворяет директории со всем ее содержимым, рекурсивно.
- `?` — Удовлетворяет любому одному символу в имени файла (аналогично regexp-шаблону `/.{1}/`).
- `[set]` — Удовлетворяет любому символу из указанного набора символов. Аналогично использованию в regexp-шаблонах, включая указание диапазонов типа `[^a-z]`.
- `\` — Экранирует следующий символ.


Маска, которая начинается с шаблона `*` или `**`, должна быть взята в одинарные или двойные кавычки в `werf.yaml`:

```
# * в начале маски, используем двойные кавычки
- "*.rb"
# одинарные также работают
- '**/*'
# нет * в начале, можно не использовать кавычки
- src/**/*.js
```

Факт изменения файлов в Git-репозитории werf определяет, подсчитывая их контрольные суммы. Для _пользовательской стадии_ и для каждой маски применяется следующий алгоритм:

- werf создает список всех файлов согласно пути, определенному в параметре `add`, и применяет фильтры `excludePaths` и `includePaths`;
- К каждому файлу с учетом его пути применяется маска, согласно правилам применения шаблонов;
- Если под маску подпадает каталог, то все содержимое этого каталога считается подпадающей под маску рекурсивно;
- У получившегося списка файлов werf подсчитывает контрольные суммы с учетом аттрибутов файлов и их содержимого.

Контрольные суммы подсчитываются вначале сборочного процесса перед запуском какой-либо стадии.

Пример:

```yaml
image: app
git:
- add: /src
  to: /app
  stageDependencies:
    beforeSetup:
    - "*"
shell:
  install:
  - echo "install stage"
  beforeSetup:
  - echo "beforeSetup stage"
  setup:
  - echo "setup stage"
```

В приведенном файле конфигурации `werf.yaml` указан _git mapping_, согласно которому содержимое папки `/src` локального Git-репозитория копируется в папку `/app` собираемого образа.
Во время первой сборки файлы кэшируются в стадии _gitArchive_ и выполняются сборочные инструкции стадий _install_, _beforeSetup_ и _setup_.

Сборка следующего коммита, в котором будут только изменения файлов за пределами папки `/src`, не приведет к выполнению инструкций каких-либо стадий. Если коммит будет содержать изменение внутри папки `/src`, контрольные суммы файлов подпадающих под маску изменятся, werf применит Git-патч и пересоберёт все пользовательские стадии, начиная со стадии _beforeSetup_, а именно — _beforeSetup_ и _setup_. Применение Git-патча будет выполнено один раз на стадии _beforeSetup_.

### Зависимость от значения CacheVersion

Существуют ситуации, когда необходимо принудительно пересобрать все или какую-то конкретную _пользовательскую стадию_. Этого можно достичь, изменяя параметры `cacheVersion` или `<user stage name>CacheVersion`.

Дайджест пользовательской стадии _install_ зависит от значения параметра `installCacheVersion`. Чтобы пересобрать пользовательскую стадию _install_ (и все последующие стадии), можно изменить значение параметра `installCacheVersion`.

> Обратите внимание, что параметры `cacheVersion` и `beforeInstallCacheVersion` имеют одинаковый эффект — при изменении этих параметров возникает пересборка стадии _beforeInstall_ и всех последующих стадий.

#### Пример: Общий образ для нескольких приложений

Вы можете определить образ, содержащий общие системные пакеты в отдельном файле `werf.yaml`. Изменение параметра `cacheVersion` может быть использовано для пересборки этого образа, чтобы обновить версии системных пакетов.

```yaml
image: ~
from: ubuntu:latest
shell:
  beforeInstallCacheVersion: 2
  beforeInstall:
  - apt update
  - apt install ...
```

Этот образ может быть использован как базовый образ для нескольких приложений (например, если образ с hub.docker.com не удовлетворяет вашим требованиям).

#### Пример использования внешних зависимостей

Параметры _CacheVersion_ можно использовать совместно [с шаблонами Go-шаблонизатора]({{ "reference/werf_yaml_template_engine.html" | true_relative_url }}), чтобы определить зависимость _пользовательской стадии_ от файлов, не находящихся в Git-репозитории.

{% raw %}
```yaml
image: ~
from: ubuntu:latest
shell:
  installCacheVersion: {{.Files.Get "some-library-latest.tar.gz" | sha256sum}}
  install:
  - tar zxf some-library-latest.tar.gz
  - <build application>
```
{% endraw %}

Если использовать, например, скрипт загрузки файла `some-library-latest.tar.gz` и запускать werf для сборки уже после скачивания файла, то пересборка пользовательской стадии _install_ (и всех последующих) будет происходить в случае, если скачан новый (измененный) файл.

## Ускорение сборки и уменьшение размера за счёт монтирования

Довольно часто бывают случаи, когда при сборке у вас появляются файлы которые нет необходимости оставлять в образе, и их нужно исключить. Например:
- Большинство пакетных менеджеров создают в системе кэш пакетов и служебных файлов.
  - [APT](https://wiki.debian.org/Apt) хранит список пакетов в директории `/var/lib/apt/lists/`.
  - APT также хранит сами пакеты в директории `/var/cache/apt/`.
  - [YUM](http://yum.baseurl.org/) может оставлять скачанные пакеты в директории `/var/cache/yum/.../packages/`.
- Менеджеры пакетов, используемые разработчиками, такие как, ​npm (Node.js), Glide (Go), pip (Python), хранят файлы в директории кэша.
- Компиляция приложений на C/C++ и т.п. языках оставляет объектные файлы и т.п.

Такого рода файлы:
- не нужны в образе;
- могут значительно увеличивать размер образа;
- могут быть полезны при повторной сборке образа или других образов.

Если монтировать такого рода файлы в сборочный контейнер, то можно добиться не только уменьшения размера образа, но и ускорения процесса сборки. В Docker такой механизм реализуется с помощью [томов](https://docs.docker.com/storage/volumes/).

Для указания тома используется директива `mount`. Директории узла сборки монтируются в сборочный контейнер согласно директивам `from`/`fromPath` и `to` описания томов. Для указания в качестве точки монтирования на сборочном узле любого файла или директории, вы можете использовать директиву `fromPath`. Либо, используя директиву `from`, вы можете указать одну из следующих служебных директорий:
- `tmp_dir` временная директория, индивидуальная для каждого описанного образа, создаваемая заново при каждой сборке;
- `build_dir` общая директория, доступная всем образам проекта и сохраняемая между сборками (находится по пути `~/.werf/shared_context/mounts/projects/<project name>/<mount id>/`). Вы можете использовать эту директорию для хранения, например, кэша и т.п.

> werf монтирует служебные директории с возможностью чтения и записи при каждой сборке, но в образе содержимого этих директорий не будет. Если вам необходимо сохранить какие-либо данные из этих директорий непосредственно в образе, то вы должны их скопировать при сборке

На стадии `from`, werf добавляет специальные лейблы к образу стадии, согласно описанных точек монтирования. Затем, на каждой стадии, werf использует эти лейблы при монтировании директорий в сборочный контейнер. Такая реализация позволяет наследовать точки монтирования от [базового образа]({{ "advanced/building_images_with_stapel/base_image.html" | true_relative_url }}).

Также, нужно иметь в виду, что на стадии `from` werf очищает точки монтирования в [базовом образе]({{ "advanced/building_images_with_stapel/base_image.html" | true_relative_url }}) (т.е. эти папки будут пусты).

> По умолчанию, использование директивы `fromPath` и `from: build_dir` запрещено гитерминизмом (подробнее об этом в [статье]({{ "/advanced/giterminism.html#mount" | true_relative_url }}))

## Импорт из артефактов и образов

Из-за используемых инструментов сборки, либо просто из-за исходных файлов, размер конечного образа может увеличиваться в несколько раз. Зачастую эти файлы не нужны в конечном образе. Для решения таких проблем, сообщество Docker предлагает выполнять установки инструментов, сборку и удаление ненужных файлов за один шаг.

Условный пример:
```
RUN “download-source && cmd && cmd2 && remove-source”
```

> Аналогичный пример может быть реализован и в werf. Для этого достаточно описать инструкции в одной _пользовательской стадии_. Пример при использовании _shell-сборщика_ для стадии _install_ (аналогичен и для _ansible-сборщика_):
```yaml
shell:
  install:
  - "download-source"
  - "cmd"
  - "cmd2"
  - "remove-source"
```

Однако при использовании такого метода кэширование работать не будет, и установка инструментов сборки будет выполняться каждый раз.

Другой способ — использование multi-stage сборки, которая поддерживается начиная с версии 17.05 Docker.

```
FROM node:latest AS storefront
WORKDIR /app
COPY react-app .
RUN npm install
RUN npm run build

FROM maven:latest AS appserver
WORKDIR /app
COPY . .
RUN mvn package

FROM java:8-jdk-alpine
COPY --from=storefront /app/react-app/build/ /static
COPY --from=appserver /app/target/AtSea-0.0.1-SNAPSHOT.jar /app/AtSea.jar
```

Смысл такого подхода в следующем — описать несколько вспомогательных образов и выборочно копировать артефакты из одного образа в другой, оставляя все то, что не нужно в конечном образе.

werf предлагает такой-же подход, но с использованием [_образов_]({{ "reference/werf_yaml.html#секция-image" | true_relative_url }}) и _артефактов_.

> Почему werf не использует multi-stage сборку?
* Исторически, возможность _импорта_ появилась значительно раньше чем в Docker появилась multi-stage сборка.
* werf дает больше гибкости при работе со вспомогательными образами

Импорт _ресурсов_ из _образов_ и _артефактов_ должен быть описан в директиве `import` в конфигурации [_образа_]({{ "reference/werf_yaml.html#секция-image" | true_relative_url }}) или _артефакта_ куда импортируются файлы. `import` — массив записей, каждая из которых должна содержать следующие параметры:

- `image: <image name>` или `artifact: <artifact name>`: _исходный образ_, имя образа из которого вы хотите копировать файлы или папки.
- `stage: <stage name>`: _стадия исходного образа_, определённая стадия _исходного образа_ из которого вы хотите копировать файлы или папки.
- `add: <absolute path>`: _исходный путь_, абсолютный путь к файлу или папке в _исходном образе_ для копирования.
- `to: <absolute path>`: _путь назначения_, абсолютный путь в _образе назначения_ (куда импортируются файлы или папки). В случае отсутствия считается равным значению указанному в параметре `add`.
- `before: <install || setup>` or `after: <install || setup>`: _стадия образа назначения_ для импорта. В настоящий момент возможен импорт только до/после стадии _install_ или _setup_.

Пример:
```yaml
import:
- artifact: application-assets
  add: /app/public/assets
  to: /var/www/site/assets
  after: install
- image: frontend
  add: /app/assets
  after: setup
```

Так же как и при конфигурации _git mappings_ поддерживаются маски включения и исключения файлов и папок.
Для указания маски включения файлов используется параметр `include_paths: []`, а для исключения `exclude_paths: []`. Маски указываются относительно пути источника (параметр `add`).
Вы также можете указывать владельца и группу для импортируемых ресурсов с помощью параметров `owner: <owner>` и `group: <group>` соответственно.
Это поведение аналогично используемому при добавлении кода из git-репозиториев, и вы можете подробнее почитать об этом в [соответствующем разделе]({{ "advanced/building_images_with_stapel/git_directive.html" | true_relative_url }}).

> Обратите внимание, что путь импортируемых ресурсов и путь указанный в _git mappings_ не должны пересекаться

Подробнее об использовании _артефактов_ можно узнать в [отдельной статье]({{ "advanced/building_images_with_stapel/artifacts.html" | true_relative_url }}).

## Артефакты

### Что такое артефакты?

***Артефакт*** — это специальный образ, используемый в других артефактах или отдельных образах, описанных в конфигурации. Артефакт предназначен преимущественно для отделения ресурсов инструментов сборки от процесса сборки образа приложения. Примерами таких ресурсов могут быть — программное обеспечение или данные, которые необходимы для сборки, но не нужны для запуска приложения, и т.п.

Используя артефакты, вы можете собирать неограниченное количество компонентов, что позволяет решать, например, следующие задачи:
- Если приложение состоит из набора компонент, каждый со своими зависимостями, то обычно вам приходится пересобирать все компоненты каждый раз. Вам бы хотелось пересобирать только те компоненты, которым это действительно нужно.
- Компоненты должны быть собраны в разных окружениях.

Импортирование _ресурсов_ из _артефактов_ указывается с помощью [директивы import]({{ "advanced/building_images_with_stapel/import_directive.html" | true_relative_url }}) в конфигурации в [_секции образа_]({{ "reference/werf_yaml.html#секция-image" | true_relative_url }}) или _секции артефакта_.

### Конфигурация

Конфигурация _артефакта_ похожа на конфигурацию обычного _образа_. Каждый _артефакт_ должен быть описан в своей секции конфигурации.

Инструкции, связанные со стадией _from_ (инструкции указания [базового образа]({{ "advanced/building_images_with_stapel/base_image.html" | true_relative_url }}) и [монтирования]({{ "advanced/building_images_with_stapel/mount_directive.html" | true_relative_url }})), а также инструкции [импорта]({{ "advanced/building_images_with_stapel/import_directive.html" | true_relative_url }}) точно такие же как и при описании _образа_.

Стадия добавления инструкций Docker (`docker_instructions`) и [соответствующие директивы]({{ "advanced/building_images_with_stapel/docker_directive.html" | true_relative_url }}) не доступны при описании _артефактов_. _Артефакт_ — это инструмент сборки, и все что от него требуется, это — только данные.

Остальные _стадии_ и инструкции описания артефактов рассматриваются далее подробно.

#### Именование

<div class="summary" markdown="1">
```yaml
artifact: string
```
</div>

_Образ артефакта_ объявляется с помощью директивы `artifact`. Синтаксис: `artifact: string`. Так как артефакты используются только самим werf, отсутствуют какие-либо ограничения на именование артефактов, в отличие от ограничений на [именование обычных _образов_]({{ "reference/werf_yaml.html#секция-image" | true_relative_url }}).

Пример:
```yaml
artifact: "application assets"
```

#### Добавление исходного кода из git-репозиториев

<div class="summary">

<a class="google-drawings" href="{{ "images/configuration/stapel_artifact2.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/configuration/stapel_artifact2_preview.png" | true_relative_url }}">
</a>

</div>

В отличие от обычных _образов_, у _конвейера стадий артефактов_ нет стадий _gitCache_ и _gitLatestPatch_.

> В werf для _артефактов_ реализована необязательная зависимость от изменений в git-репозиториях. Таким образом, по умолчанию werf игнорирует какие-либо изменения в git-репозитории, кэшируя образ после первой сборки. Но вы можете определить зависимости от файлов и папок, при изменении в которых образ артефакта будет пересобираться

Читайте подробнее про работу с _git-репозиториями_ в соответствующей [статье]({{ "advanced/building_images_with_stapel/git_directive.html" | true_relative_url }}).

#### Запуск инструкций сборки

<div class="summary">

<a class="google-drawings" href="{{ "images/configuration/stapel_artifact3.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/configuration/stapel_artifact3_preview.png" | true_relative_url }}">
</a>

</div>

У артефактов точно такое же как и у обычных образов использование директив и пользовательских стадий — _beforeInstall_, _install_, _beforeSetup_ и _setup_.

Если в директиве `stageDependencies` в блоке git для _пользовательской стадии_ не указана зависимость от каких-либо файлов, то образ кэшируется после первой сборки, и не будет повторно собираться пока соответствующая _стадия_ находится в _stages storage_.

> Если необходимо повторно собирать артефакт при любых изменениях в git, нужно указать _stageDependency_ `**/*` для соответствующей _пользовательской_ стадии. Пример для стадии _install_:
```yaml
git:
- to: /
  stageDependencies:
    install: "**/*"
```

Читайте подробнее про работу с _инструкциями сборки_ в соответствующей [статье]({{ "advanced/building_images_with_stapel/assembly_instructions.html" | true_relative_url }}).

### Использование артефактов

В отличие от [*обычного образа*]({{ "advanced/building_images_with_stapel/assembly_instructions.html" | true_relative_url }}), у *образа артефакта* нет стадии _git latest patch_. Это сделано намеренно, т.к. стадия _git latest patch_ выполняется обычно при каждом коммите, применяя появившиеся изменения к файлам. Однако *артефакт* рекомендуется использовать как образ с высокой вероятностью кэширования, который обновляется редко или нечасто (например, при изменении специальных файлов).

Пример: нужно импортировать в артефакт данные из git, и пересобирать ассеты только тогда, когда изменяются влияющие на сборку ассетов файлы. Т.е. в случае, изменения каких-либо других файлов в git, ассеты пересобираться не должны.

Конечно, существуют случаи когда необходимо включать изменения любых файлов git-репозитория в _образ артефакта_ (например, если в артефакте происходит сборка приложения на Go). В этом случае необходимо указать зависимость относительно стадии (сборку которой необходимо выполнять при изменениях в git) с помощью `git.stageDependencies` и `*` в качестве шаблона. Пример:

```yaml
git:
- add: /
  to: /app
  stageDependencies:
    setup:
    - "*"
```

В этом случае любые изменения файлов в git-репозитории будут приводить к пересборке _образа артефакта_, и всех _образов_, в которых определен импорт этого артефакта.

**Замечание:** Если вы используете какие-либо файлы и при сборке _артефакта_ и при сборке [*обычного образа*]({{ "advanced/building_images_with_stapel/assembly_instructions.html" | true_relative_url }}), правильный путь — использовать директиву `git.add` при описании каждого образа, где это необходимо, т.е. несколько раз. **Не рекомендуемый** вариант — добавить файлы при сборке артефакта, а потом импортировать их используя директиву `import` в другой образ.


# Интеграция с SSH-агентом

werf необходим ssh-ключ пользователя в следующих случаях:

1. Клонирование удаленного git-репозитория, указанного в файле конфигурации `werf.yaml`.
1. Инструкции сборки образа требуют доступа к внешним данным по ssh.

По умолчанию (без указания каких-либо параметров) werf пытается использовать ssh-agent запущенный в системе, проверяя его доступность с помощью переменной окружения `SSH_AUTH_SOCK`.

В случае отсутствия в системе запущенного ssh-агента, werf пытается выступать в качестве ssh-клиента, для чего использует ssh-ключ пользователя по умолчанию, т.е. (`~/.ssh/id_rsa|id_dsa`). Если werf обнаруживает один из этих файлов, то выполняется запуск временного ssh-агента с добавлением найденных ключей.

Для использования только конкретных ssh-ключей, необходимо указывать опцию запуска `--ssh-key PRIVATE_KEY_FILE_PATH` (может быть указана несколько раз, для указания нескольких ssh-ключей). В этом случае werf выполняет запуск временного ssh-агента и добавляет ему только указанные ssh-ключи.

## Как werf работает с ssh-агентом

При работе с удаленными git-репозиториями используется UNIX-сокет `SSH_AUTH_SOCK`, который монтируется во все сборочные контейнеры. Таким образом, сборочные инструкции могут использовать ssh-агент через указанный UNIX-сокет.

**ЗАМЕЧАНИЕ** Существует ограничение, из-за которого только пользователь `root` внутри сборочного контейнера имеет доступ к UNIX-сокету из переменной окружения `SSH_AUTH_SOCK`.

## Временный ssh-агент

werf может запускать временный ssh-агент для работы некоторых команд. Такой ssh-агент завершает работу при завершении работы соответствующей команды werf.
В случае если в системе есть запущенный ssh-агент, то запускаемый werf временный ssh-агент не конфликтует с запущенным в системе ssh-агентом.
