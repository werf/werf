
- [Обзор](#обзор)
- [Конфигурация образов](#конфигурация-образов)
- [Сборочный процесс](#сборочный-процесс)
- [Организация хранилища](#организация-хранилища)
- [Stapel](#stapel)

## Обзор

## Конфигурация образов

## Сборочный процесс

## Организация хранилища

<!-- ## OLD

#### Стадии и хранилище

Мы разделили сборочный процесс образов, описанных в файле конфигурации [werf.yaml]({{ "reference/werf_yaml.html" | true_relative_url }}) на этапы, [с четкими функциями и назначением](#зависимости-стадии). Каждый такой этап соответствует промежуточному образу. В werf такой этап называется [стадией](#конвеер-стадий), а **конечный образ** соответствует последней собранной стадии для определённого состояния git и конфигурации werf.yaml.

Стадии — это этапы сборочного процесса. ***Стадия*** определяется группой инструкций, указанных в конфигурации. Причем группировка этих инструкций не случайна, имеет определенную логику и учитывает условия и правила сборки. С каждой _стадией_ связан конкретный Docker-образ. Все стадии хранятся в [хранилище](#хранилище).

##### Конвеер стадий

_Конвейер стадий_ — набор условий и правил выполнения стадий, подразумевающий также четко определенный порядок выполнения стадий. werf использует не один, а несколько _конвейеров стадий_ в своей работе, по-разному собирая образы в зависимости от их описанной конфигурации.

<div class="tabs">
  <a href="javascript:void(0)" class="tabs__btn active" onclick="openTab(event, 'tabs__btn', 'tabs__content', 'dockerfile-image-tab')">Dockerfile-образ</a>
  <a href="javascript:void(0)" class="tabs__btn" onclick="openTab(event, 'tabs__btn', 'tabs__content', 'stapel-image-tab')">Stapel-образ</a>
  <a href="javascript:void(0)" class="tabs__btn" onclick="openTab(event, 'tabs__btn', 'tabs__content', 'stapel-artifact-tab')">Stapel-артефакт</a>
</div>

<div id="dockerfile-image-tab" class="tabs__content active">
<a class="google-drawings" href="{{ "images/reference/stages_and_images1.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/reference/stages_and_images1_preview.png" | true_relative_url }}">
</a>
</div>

<div id="stapel-image-tab" class="tabs__content">
<a class="google-drawings" href="{{ "images/reference/stages_and_images2.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/reference/stages_and_images2_preview.png" | true_relative_url }}" >
</a>
</div>

<div id="stapel-artifact-tab" class="tabs__content">
<a class="google-drawings" href="{{ "images/reference/stages_and_images3.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/reference/stages_and_images3_preview.png" | true_relative_url }}">
</a>
</div>

Пользователю нужно только написать правильную конфигурацию, остальная работа со стадиями выполняется werf.

Для каждой _стадии_, werf подсчитывает уникальный сборочный идентификатор — [дайджест стадии](#дайджест-стадии).

$('.tabs').on('click', '.dependencies-btn', function() {
  $(this).toggleClass('active').siblings().removeClass('active');
  application()
});

application();
$.noConflict();
</script>

# Процесс сборки

Сборочный процесс werf для образов, описанных в [werf.yaml]({{ "reference/werf_yaml.html" | true_relative_url }}), подразумевает [последовательную сборку стадий]({{ "internals/stages_and_storage.html" | true_relative_url }}#конвеер-стадий) для описанных образов.

Несмотря на то, что [_конвейеры стадий_]({{ "internals/stages_and_storage.html#конвеер-стадий" | true_relative_url }}) для Dockerfile-образа, Stapel-образа и Stapel-артефакта отличаются, каждая стадия подчиняется общим правилам [выборки из хранилища](#выборка-стадий), [сохранения](#сохранение-стадий-в-хранилище), а также [работы кеша и блокировок]({{ "advanced/synchronization.html" | true_relative_url }}) в параллельных запусках.

## Сборка стадии Dockerfile-образа

Для сборки Dockerfile-образа werf создает единственную [стадию]({{ "internals/stages_and_storage.html#конвеер-стадий" | true_relative_url }}) — `dockerfile`.

В настоящий момент, при сборке стадии werf использует стандартные команды встроенного в Docker клиента (это аналогично выполнению команды `docker build`), а также аргументы, которые пользователь описывает в `werf.yaml`. Кэш, создаваемый при сборке, используется, как и при обычной сборке, без помощи werf.

Интересной особенностью werf является то, что в качестве сборочного контекста используются файлы не из директории проекта, а из git-репозитория. Все файлы, которые содержатся в директории, заданной директивой `context` (по умолчанию это директория проекта), берутся из текущего коммита репозитория проекта (подробнее про гитерминизм можно почитать [в отдельной статье]({{ "advanced/giterminism.html#dockerfile-образ" | true_relative_url }})).

В итоге сборку стадии `dockerfile` можно представить следующим образом:

```shell
docker build --file=Dockerfile - < ~/.werf/service/tmp/context/4b9d6bc2-a549-42f9-86b8-4032c146f888
```

Подробнее о файле конфигурации сборки `werf.yaml` в [соответствующем разделе]({{ "reference/werf_yaml.html#сборщик-dockerfile" | true_relative_url }}).




## Сборка стадии Stapel-образа и Stapel-артефакта

При сборке стадии предполагается, что инструкции стадии будут запускаться в контейнере, основанном на предыдущей собранной стадии или на [базовом образе]({{ "advanced/building_images_with_stapel/base_image.html#from-fromlatest" | true_relative_url }}). Такой контейнер будет упоминаться далее как **сборочный контейнер**.

Перед запуском _сборочного контейнера_ werf подготавливает набор инструкций, который зависит от типа стадии и содержит как служебные команды werf, так и [пользовательские]({{ "advanced/building_images_with_stapel/assembly_instructions.html" | true_relative_url }}), указанные в конфигурации `werf.yaml`. Например, среди служебных команд может быть добавление файлов, наложение патчей, запуск ansible заданий и т.п.

Stapel-сборщик использует свой набор инструментов и библиотек и никак не зависит от базового образа. При запуске _сборочного контейнера_ werf монтирует всё необходимое из специального служебного образа `registry.werf.io/werf/stapel`. Подробнее об образе можно прочитать [в соответствующей статье]({{ "internals/development/stapel_image.html" | true_relative_url }}).

В _сборочный контейнер_ [пробрасывается сокет ssh-агента с хоста]({{ "internals/integration_with_ssh_agent.html" | true_relative_url }}), а также могут использоваться [пользовательские маунты]({{ "advanced/building_images_with_stapel/mount_directive.html" | true_relative_url }}).

Также стоит отметить, что при сборке werf игнорирует некоторые параметры манифеста базового образа, перетирая их определёнными значениями:
- `--user=0:0`;
- `--workdir=/`;
- `--entrypoint=/.werf/stapel/embedded/bin/bash`.

В итоге запуск _сборочного контейнера_ произвольной стадии можно представить следующим образом:
```shell
docker run \
  --volume=/tmp/ssh-ln8yCMlFLZob/agent.17554:/.werf/tmp/ssh-auth-sock \
  --volumes-from=stapel_0.6.1 \
  --env=SSH_AUTH_SOCK=/.werf/tmp/ssh-auth-sock \
  --user=0:0 \
  --workdir=/ \
  --entrypoint=/.werf/stapel/embedded/bin/bash \
  sha256:d6e46aa2470df1d32034c6707c8041158b652f38d2a9ae3d7ad7e7532d22ebe0 \
  -ec eval $(echo c2V0IC14 | /.werf/stapel/embedded/bin/base64 --decode)
```

Подробнее о файле конфигурации сборки `werf.yaml` в [соответствующем разделе]({{ "reference/werf_yaml.html#stapel-сборщик" | true_relative_url }}).

### Как Stapel-сборщик работает с CMD и ENTRYPOINT

Для сборки стадии werf запускает контейнер со служебными значениями `CMD` и `ENTRYPOINT` а затем, заменяет их значениями [базового образа]({{ "advanced/building_images_with_stapel/base_image.html" | true_relative_url }}). Если в базовом образе эти значения не установлены, werf сбрасывает их следующим образом:
- `[]` для `CMD`;
- `[""]` для `ENTRYPOINT`.

Также werf сбрасывает (использует специальные пустые значения) значение `ENTRYPOINT` базового образа, если указано значение `CMD` в конфигурации (`docker.CMD`).

В противном случае поведение werf аналогично [поведению Docker](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).

<< Как это работает



>> Закрытый контур (не важно)

### Как использовать Stapel-сборщик в закрытом контуре

При запуске _сборочного контейнера_ werf монтирует инструментарий из специального образа, имя и тег которого зашиты в коде.

Для сборки со Stapel в закрытом контуре (без доступа к служебному образу) необходимо загрузить образ в доступный container registry и переопределить имя с помощью переменных окружения `WERF_STAPEL_IMAGE_NAME` и `WERF_STAPEL_IMAGE_VERSION` (например, `WERF_STAPEL_IMAGE_NAME=localhost:5000/stapel` и `WERF_STAPEL_IMAGE_VERSION=0.6.2`).

<< Закрытый контур (не важно)




>> Как это работает

## Выборка стадий

Алгоритм выборки стадии в werf можно представить следующим образом:

1. Рассчитывается [дайджест стадии]({{ "internals/stages_and_storage.html#дайджест-стадии" | true_relative_url }}).
2. Выбираются все стадии, подходящие под дайджест, т.к. с одним дайджестом может быть связанно несколько стадий в [хранилище]({{ "internals/stages_and_storage.html#хранилище" | true_relative_url }}).
3. Выбирается старейший по времени `TIMESTAMP_MILLISEC` (подробнее про именование стадий [здесь]({{ "internals/stages_and_storage.html#именование-стадий" | true_relative_url }})).

### Дополнение для Stapel-образов и Stapel-артефактов

К основному алгоритму добавляется проверка родства git-коммитов. После шага **2** выполняется дополнительный отсев с использованием истории git: если текущая стадия связана с git (стадия git-архив, пользовательская стадия с git-патчами или стадия git latest patch), тогда выбираются только те стадии, которые связаны с коммитами, являющимися предками текущего коммита. Таким образом, коммиты соседних веток будут отброшены.

Возможна ситуация когда существует несколько собранных образов с одинаковым дайджестом. Более того, стадии для разных git-веток могут иметь одинаковую дайджест. Однако werf гарантированно предотвращает переиспользование кеша между несвязанными ветками. Кеш в разных ветках может быть переиспользован только если этот кеш относится к коммиту, который является базовым, как для одной ветки, так и для другой.




# Git worktree

Для корректной работы сборщика stapel werf-у требуется полная git-история проекта, чтобы работать в наиболее эффективном режиме. Поэтому по умолчанию werf выполняет fetch истории для текущего git проекта, когда это требуется. Это означает, что werf может автоматически сконвертировать shallow-clone репозитория в полный clone и скачать обновлённый список веток и тегов из origin в процессе очистки образов.

Поведение по умолчанию описывается следующими настройками:

```yaml
gitWorktree:
  forceShallowClone: false
  allowUnshallow: true
  allowFetchOriginBranchesAndTags: true
```

Чтобы, например, выключить автоматический unshallow рабочей директории git, необходимы следующие настройки:

```yaml
gitWorktree:
  forceShallowClone: true
  allowUnshallow: false
```

<< Как это работает



>> Дизайн стапеля

# Интеграция с SSH-агентом

werf необходим ssh-ключ пользователя в следующих случаях:

1. Клонирование удаленного git-репозитория, указанного в файле конфигурации `werf.yaml`.
1. Инструкции сборки образа требуют доступа к внешним данным по ssh.

По умолчанию (без указания каких-либо параметров) werf пытается использовать ssh-agent запущенный в системе, проверяя его доступность с помощью переменной окружения `SSH_AUTH_SOCK`.

В случае отсутствия в системе запущенного ssh-агента, werf пытается выступать в качестве ssh-клиента, для чего использует ssh-ключ пользователя по умолчанию, т.е. (`~/.ssh/id_rsa|id_dsa`). Если werf обнаруживает один из этих файлов, то выполняется запуск временного ssh-агента с добавлением найденных ключей.

Для использования только конкретных ssh-ключей, необходимо указывать опцию запуска `--ssh-key PRIVATE_KEY_FILE_PATH` (может быть указана несколько раз, для указания нескольких ssh-ключей). В этом случае werf выполняет запуск временного ssh-агента и добавляет ему только указанные ssh-ключи.

## Как werf работает с ssh-агентом

При работе с удаленными git-репозиториями используется UNIX-сокет `SSH_AUTH_SOCK`, который монтируется во все сборочные контейнеры. Таким образом, сборочные инструкции могут использовать ssh-агент через указанный UNIX-сокет.

**ЗАМЕЧАНИЕ** Существует ограничение, из-за которого только пользователь `root` внутри сборочного контейнера имеет доступ к UNIX-сокету из переменной окружения `SSH_AUTH_SOCK`.

## Временный ssh-агент

werf может запускать временный ssh-агент для работы некоторых команд. Такой ssh-агент завершает работу при завершении работы соответствующей команды werf.
В случае если в системе есть запущенный ssh-агент, то запускаемый werf временный ssh-агент не конфликтует с запущенным в системе ssh-агентом. -->

## Stapel
