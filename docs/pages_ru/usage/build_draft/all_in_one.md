
- [Обзор](#обзор)
- [Конфигурация образов](#конфигурация-образов)
- [Сборочный процесс](#сборочный-процесс)
- [Организация хранилища](#организация-хранилища)
- [Stapel](#stapel)

## Обзор

## Конфигурация образов

## Сборочный процесс

## Организация хранилища

<!-- ## OLD

#### Стадии и хранилище

Мы разделили сборочный процесс образов, описанных в файле конфигурации [werf.yaml]({{ "reference/werf_yaml.html" | true_relative_url }}) на этапы, [с четкими функциями и назначением](#зависимости-стадии). Каждый такой этап соответствует промежуточному образу. В werf такой этап называется [стадией](#конвеер-стадий), а **конечный образ** соответствует последней собранной стадии для определённого состояния git и конфигурации werf.yaml.

Стадии — это этапы сборочного процесса. ***Стадия*** определяется группой инструкций, указанных в конфигурации. Причем группировка этих инструкций не случайна, имеет определенную логику и учитывает условия и правила сборки. С каждой _стадией_ связан конкретный Docker-образ. Все стадии хранятся в [хранилище](#хранилище).

##### Конвеер стадий

_Конвейер стадий_ — набор условий и правил выполнения стадий, подразумевающий также четко определенный порядок выполнения стадий. werf использует не один, а несколько _конвейеров стадий_ в своей работе, по-разному собирая образы в зависимости от их описанной конфигурации.

<div class="tabs">
  <a href="javascript:void(0)" class="tabs__btn active" onclick="openTab(event, 'tabs__btn', 'tabs__content', 'dockerfile-image-tab')">Dockerfile-образ</a>
  <a href="javascript:void(0)" class="tabs__btn" onclick="openTab(event, 'tabs__btn', 'tabs__content', 'stapel-image-tab')">Stapel-образ</a>
  <a href="javascript:void(0)" class="tabs__btn" onclick="openTab(event, 'tabs__btn', 'tabs__content', 'stapel-artifact-tab')">Stapel-артефакт</a>
</div>

<div id="dockerfile-image-tab" class="tabs__content active">
<a class="google-drawings" href="{{ "images/reference/stages_and_images1.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/reference/stages_and_images1_preview.png" | true_relative_url }}">
</a>
</div>

<div id="stapel-image-tab" class="tabs__content">
<a class="google-drawings" href="{{ "images/reference/stages_and_images2.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/reference/stages_and_images2_preview.png" | true_relative_url }}" >
</a>
</div>

<div id="stapel-artifact-tab" class="tabs__content">
<a class="google-drawings" href="{{ "images/reference/stages_and_images3.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/reference/stages_and_images3_preview.png" | true_relative_url }}">
</a>
</div>

Пользователю нужно только написать правильную конфигурацию, остальная работа со стадиями выполняется werf.

Для каждой _стадии_, werf подсчитывает уникальный сборочный идентификатор — [дайджест стадии](#дайджест-стадии).

В случае отсутствия у стадии [зависимостей стадии](#зависимости-стадии), она пропускается, и, соответственно, _конвейер стадий_ уменьшается на одну стадию. Таким образом конвейер стадий может уменьшаться, вплоть до единственной стадии _from_.

<a class="google-drawings" href="{{ "images/reference/stages_and_images4.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/reference/stages_and_images4_preview.png" | true_relative_url }}">
</a>

#### Дайджест стадии

_Дайджест стадии_ используется для [тегирования](#именование-стадий) _стадии_ (дайджест является только частью тега) в _хранилище_.
werf не собирает стадию, если стадия с таким же _дайджестом_ уже находится в _хранилище_ (это поведение похоже на кэширование в Docker, только имеет более сложную логику).

***Дайджест стадии*** — это контрольная сумма от:
- контрольной суммы [зависимостей стадии](#зависимости-стадии).
- дайджеста предыдущей стадии;
- идентификатора git коммита связанного с предыдущей стадией (если эта стадия связана с git).

_Дайджест_ стадии идентифицирует содержимое стадии и зависит от истории правок в git, которые привели к этому коммиту.

#### Зависимости стадии

_Зависимости стадии_ — это данные, которые напрямую связаны и влияют на [дайджест стадии](#дайджест-стадии). К зависимостям стадии относятся:

- файлы (и их содержимое) из git-репозиториев;
- инструкции сборки стадии из файла `werf.yaml`;
- произвольные строки указанные пользователем в `werf.yaml`
- и т.п.

Большинство _зависимостей стадии_ определяется в файле конфигурации `werf.yaml`, остальные — во время запуска.

Следующая таблица иллюстрирует зависимости в Dockerfile-образе, Stapel-образе и [Stapel-артефакте]({{ "advanced/building_images_with_stapel/artifacts.html" | true_relative_url }}).
Каждая строка таблицы описывает зависимости для определенной стадии. Левая колонка содержит краткое описание зависимостей, правая содержит соответствующую часть `werf.yaml` и ссылки на разделы с более подробной информацией.

<div class="tabs">
  <a href="javascript:void(0)" id="image-from-dockerfile-dependencies" class="tabs__btn dependencies-btn active">Dockerfile-образ</a>
  <a href="javascript:void(0)" id="image-dependencies" class="tabs__btn dependencies-btn">Stapel-образ</a>
  <a href="javascript:void(0)" id="artifact-dependencies" class="tabs__btn dependencies-btn">Stapel-артефакт</a>
</div>

<div id="dependencies">
{% for stage in site.data.stages.ru.entries %}
<div class="stage {{stage.type}}">
  <div class="stage-body">
    <div class="stage-base">
      <p>stage {{ stage.name | escape }}</p>

      {% if stage.dependencies %}
      <div class="dependencies">
        {% for dependency in stage.dependencies %}
        <div class="dependency">
          {{ dependency | escape }}
        </div>
        {% endfor %}
      </div>
      {% endif %}
    </div>

<div class="werf-config" markdown="1">

{% if stage.werf_config %}
```yaml
{{ stage.werf_config }}
```
{% endif %}

{% if stage.references %}
<div class="references">
    Подробнее:
    <ul>
    {% for reference in stage.references %}
        <li><a href="{{ reference.link | true_relative_url }}">{{ reference.name }}</a></li>
    {% endfor %}
    </ul>
</div>
{% endif %}

</div>

    </div>
</div>
{% endfor %}
</div>

<link rel="stylesheet" type="text/css" href="{{ assets["stages.css"].digest_path | true_relative_url }}" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script>
function application() {
  if ($("a[id=image-from-dockerfile-dependencies]").hasClass('active')) {
    $(".image").addClass('hidden');
    $(".artifact").addClass('hidden');
    $(".image-from-dockerfile").removeClass('hidden')
  }
  else if ($("a[id=image-dependencies]").hasClass('active')) {
    $(".image-from-dockerfile").addClass('hidden');
    $(".artifact").addClass('hidden');
    $(".image").removeClass('hidden')
  }
  else if ($("a[id=artifact-dependencies]").hasClass('active')) {
    $(".image-from-dockerfile").addClass('hidden');
    $(".image").addClass('hidden');
    $(".artifact").removeClass('hidden')
  }
  else {
    $(".image-from-dockerfile").addClass('hidden');
    $(".image").addClass('hidden');
    $(".artifact").addClass('hidden')
  }
}

$('.tabs').on('click', '.dependencies-btn', function() {
  $(this).toggleClass('active').siblings().removeClass('active');
  application()
});

application();
$.noConflict();
</script>

# Процесс сборки

Сборочный процесс werf для образов, описанных в [werf.yaml]({{ "reference/werf_yaml.html" | true_relative_url }}), подразумевает [последовательную сборку стадий]({{ "internals/stages_and_storage.html" | true_relative_url }}#конвеер-стадий) для описанных образов.

Несмотря на то, что [_конвейеры стадий_]({{ "internals/stages_and_storage.html#конвеер-стадий" | true_relative_url }}) для Dockerfile-образа, Stapel-образа и Stapel-артефакта отличаются, каждая стадия подчиняется общим правилам [выборки из хранилища](#выборка-стадий), [сохранения](#сохранение-стадий-в-хранилище), а также [работы кеша и блокировок]({{ "advanced/synchronization.html" | true_relative_url }}) в параллельных запусках.

## Сборка стадии Dockerfile-образа

Для сборки Dockerfile-образа werf создает единственную [стадию]({{ "internals/stages_and_storage.html#конвеер-стадий" | true_relative_url }}) — `dockerfile`.

В настоящий момент, при сборке стадии werf использует стандартные команды встроенного в Docker клиента (это аналогично выполнению команды `docker build`), а также аргументы, которые пользователь описывает в `werf.yaml`. Кэш, создаваемый при сборке, используется, как и при обычной сборке, без помощи werf.

Интересной особенностью werf является то, что в качестве сборочного контекста используются файлы не из директории проекта, а из git-репозитория. Все файлы, которые содержатся в директории, заданной директивой `context` (по умолчанию это директория проекта), берутся из текущего коммита репозитория проекта (подробнее про гитерминизм можно почитать [в отдельной статье]({{ "advanced/giterminism.html#dockerfile-образ" | true_relative_url }})).

В итоге сборку стадии `dockerfile` можно представить следующим образом:

```shell
docker build --file=Dockerfile - < ~/.werf/service/tmp/context/4b9d6bc2-a549-42f9-86b8-4032c146f888
```

Подробнее о файле конфигурации сборки `werf.yaml` в [соответствующем разделе]({{ "reference/werf_yaml.html#сборщик-dockerfile" | true_relative_url }}).




## Сборка стадии Stapel-образа и Stapel-артефакта

При сборке стадии предполагается, что инструкции стадии будут запускаться в контейнере, основанном на предыдущей собранной стадии или на [базовом образе]({{ "advanced/building_images_with_stapel/base_image.html#from-fromlatest" | true_relative_url }}). Такой контейнер будет упоминаться далее как **сборочный контейнер**.

Перед запуском _сборочного контейнера_ werf подготавливает набор инструкций, который зависит от типа стадии и содержит как служебные команды werf, так и [пользовательские]({{ "advanced/building_images_with_stapel/assembly_instructions.html" | true_relative_url }}), указанные в конфигурации `werf.yaml`. Например, среди служебных команд может быть добавление файлов, наложение патчей, запуск ansible заданий и т.п.

Stapel-сборщик использует свой набор инструментов и библиотек и никак не зависит от базового образа. При запуске _сборочного контейнера_ werf монтирует всё необходимое из специального служебного образа `registry.werf.io/werf/stapel`. Подробнее об образе можно прочитать [в соответствующей статье]({{ "internals/development/stapel_image.html" | true_relative_url }}).

В _сборочный контейнер_ [пробрасывается сокет ssh-агента с хоста]({{ "internals/integration_with_ssh_agent.html" | true_relative_url }}), а также могут использоваться [пользовательские маунты]({{ "advanced/building_images_with_stapel/mount_directive.html" | true_relative_url }}).

Также стоит отметить, что при сборке werf игнорирует некоторые параметры манифеста базового образа, перетирая их определёнными значениями:
- `--user=0:0`;
- `--workdir=/`;
- `--entrypoint=/.werf/stapel/embedded/bin/bash`.

В итоге запуск _сборочного контейнера_ произвольной стадии можно представить следующим образом:
```shell
docker run \
  --volume=/tmp/ssh-ln8yCMlFLZob/agent.17554:/.werf/tmp/ssh-auth-sock \
  --volumes-from=stapel_0.6.1 \
  --env=SSH_AUTH_SOCK=/.werf/tmp/ssh-auth-sock \
  --user=0:0 \
  --workdir=/ \
  --entrypoint=/.werf/stapel/embedded/bin/bash \
  sha256:d6e46aa2470df1d32034c6707c8041158b652f38d2a9ae3d7ad7e7532d22ebe0 \
  -ec eval $(echo c2V0IC14 | /.werf/stapel/embedded/bin/base64 --decode)
```

Подробнее о файле конфигурации сборки `werf.yaml` в [соответствующем разделе]({{ "reference/werf_yaml.html#stapel-сборщик" | true_relative_url }}).

### Как Stapel-сборщик работает с CMD и ENTRYPOINT

Для сборки стадии werf запускает контейнер со служебными значениями `CMD` и `ENTRYPOINT` а затем, заменяет их значениями [базового образа]({{ "advanced/building_images_with_stapel/base_image.html" | true_relative_url }}). Если в базовом образе эти значения не установлены, werf сбрасывает их следующим образом:
- `[]` для `CMD`;
- `[""]` для `ENTRYPOINT`.

Также werf сбрасывает (использует специальные пустые значения) значение `ENTRYPOINT` базового образа, если указано значение `CMD` в конфигурации (`docker.CMD`).

В противном случае поведение werf аналогично [поведению Docker](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).

<< Как это работает



>> Закрытый контур (не важно)

### Как использовать Stapel-сборщик в закрытом контуре

При запуске _сборочного контейнера_ werf монтирует инструментарий из специального образа, имя и тег которого зашиты в коде.

Для сборки со Stapel в закрытом контуре (без доступа к служебному образу) необходимо загрузить образ в доступный container registry и переопределить имя с помощью переменных окружения `WERF_STAPEL_IMAGE_NAME` и `WERF_STAPEL_IMAGE_VERSION` (например, `WERF_STAPEL_IMAGE_NAME=localhost:5000/stapel` и `WERF_STAPEL_IMAGE_VERSION=0.6.2`).

<< Закрытый контур (не важно)




>> Как это работает

## Выборка стадий

Алгоритм выборки стадии в werf можно представить следующим образом:

1. Рассчитывается [дайджест стадии]({{ "internals/stages_and_storage.html#дайджест-стадии" | true_relative_url }}).
2. Выбираются все стадии, подходящие под дайджест, т.к. с одним дайджестом может быть связанно несколько стадий в [хранилище]({{ "internals/stages_and_storage.html#хранилище" | true_relative_url }}).
3. Выбирается старейший по времени `TIMESTAMP_MILLISEC` (подробнее про именование стадий [здесь]({{ "internals/stages_and_storage.html#именование-стадий" | true_relative_url }})).

### Дополнение для Stapel-образов и Stapel-артефактов

К основному алгоритму добавляется проверка родства git-коммитов. После шага **2** выполняется дополнительный отсев с использованием истории git: если текущая стадия связана с git (стадия git-архив, пользовательская стадия с git-патчами или стадия git latest patch), тогда выбираются только те стадии, которые связаны с коммитами, являющимися предками текущего коммита. Таким образом, коммиты соседних веток будут отброшены.

Возможна ситуация когда существует несколько собранных образов с одинаковым дайджестом. Более того, стадии для разных git-веток могут иметь одинаковую дайджест. Однако werf гарантированно предотвращает переиспользование кеша между несвязанными ветками. Кеш в разных ветках может быть переиспользован только если этот кеш относится к коммиту, который является базовым, как для одной ветки, так и для другой.

## Сохранение стадий в хранилище

Множество процессов werf (на одном хосте или на нескольких хостах) могут инициировать сборку одной и той же стадии в один момент времени, потому что этой стадии еще нет в хранилище.

werf использует алгоритм оптимистичных блокировок в процессе сохранения свежесобранного образа в хранилище. Когда сборка нового образа закончена, werf блокирует хранилище на любые операции с целевым дайджестом:
- Если за время сборки подходящего образа не появилось в хранилище, то werf сохраняет новый образ, сгенерировав гарантированно уникальный идентификатор `TIMESTAMP_MILLISEC`.
- Если за время сборки подходящий образ появился в хранилище, то werf отбрасывает свежесобранный образ, а вместо него использует появившийся в хранилище образ.

Другими словами: первый процесс, который закончит сборку новой стадии (самый быстрый процесс) получит шанс сохранить собранный образ в хранилище. Медленный процесс сборки не будет блокировать более быстрые процессы в параллельной и распределенной среде.

В процессе выборки и сохранения новых стадий в хранилище werf использует [менеджер блокировок]({{ "advanced/synchronization.html" | true_relative_url }}) для координации работы нескольких процессов werf.

<< Как это работает

>> Конфигурация сборщика

<< Конфигурация сборщика


>> Как это работает => перенести в конфигурацию

# Git worktree

Для корректной работы сборщика stapel werf-у требуется полная git-история проекта, чтобы работать в наиболее эффективном режиме. Поэтому по умолчанию werf выполняет fetch истории для текущего git проекта, когда это требуется. Это означает, что werf может автоматически сконвертировать shallow-clone репозитория в полный clone и скачать обновлённый список веток и тегов из origin в процессе очистки образов.

Поведение по умолчанию описывается следующими настройками:

```yaml
gitWorktree:
  forceShallowClone: false
  allowUnshallow: true
  allowFetchOriginBranchesAndTags: true
```

Чтобы, например, выключить автоматический unshallow рабочей директории git, необходимы следующие настройки:

```yaml
gitWorktree:
  forceShallowClone: true
  allowUnshallow: false
```

<< Как это работает


>> Как это работает

# Синхронизация в werf

Синхронизация — это группа сервисных компонентов werf, предназначенных для координации нескольких процессов werf при выборке и сохранении стадий в хранилище, а также при публикации образов в репозиторий образов. Существует 2 таких компонента для синхронизации:

1. _Кеш хранилища_ — это внутренний служебный кеш werf, который существенно повышает производительность фазы расчёта стадий в случае, если эти стадии уже есть в хранилище. Кеш хранилища содержит соответствие существующих в хранилище с дайджестом (или другими словами: содержит предварительно рассчитанный шаг алгоритма выборки стадий по дайджесту). Данный кеш является когерентным и werf автоматически сбрасывает его, если будет замечена несостыковка между хранилищем стадий и кешом хранилища.
2. _Менеджер блокировок_. Блокировки требуются для корректной публикации новых стадий в хранилище, публикации новых образов в репозиторий образов и для организации параллельных процессов выката в Kubernetes (блокируется имя релиза).

Все команды, использующие параметры хранилища (`--repo=...`) также требуют указания адреса менеджера блокировок, который задается опцией `--synchronization=...` или переменной окружения `WERF_SYNCHRONIZATION=...`.

Существует 2 типа наборов компонентов для синхронизации:
1. Локальный. Включается опцией `--synchronization=:local`.
- Локальный _кеш хранилища_ располагается по умолчанию в файлах `~/.werf/shared_context/storage/stages_storage_cache/1/PROJECT_NAME/DIGEST`, каждый из которых хранит соответствие существующих в хранилище по некоторому дайджесту.
- Локальный _менеджер блокировок_ использует файловые блокировки, предоставляемые операционной системой.
2. Kubernetes. Включается опцией `--synchronization=kubernetes://NAMESPACE[:CONTEXT][@(base64:CONFIG_DATA)|CONFIG_PATH]`.
- _Кеш хранилища_ в Kubernetes использует для каждого проекта отдельный ConfigMap `cm/PROJECT_NAME`, который создается в указанном `NAMESPACE`.
- _Менеджер блокировок_ в Kubernetes использует ConfigMap по имени проекта `cm/PROJECT_NAME` (тот же самый что и для кеша хранилища) для хранения распределённых блокировок в аннотациях этого ConfigMap. werf использует [библиотека lockgate](https://github.com/werf/lockgate), которая реализует распределённые блокировки с помощью обновления аннотаций в ресурсах Kubernetes.
3. Http. Включается опцией `--synchronization=http[s]://DOMAIN`.
- Есть публичный сервер синхронизации доступный по домену `https://synchronization.werf.io`.
- Собственный http сервер синхронизации может быть запущен командой `werf synchronization`.

werf использует `--synchronization=:local` (локальный _кеш хранилища_ и локальный _менеджер блокировок_) по умолчанию, если используется локальное хранилище.

werf использует `--synchronization=https://synchronization.werf.io` по умолчанию, если используется удалённое хранилище (`--repo=CONTAINER_REGISTRY_REPO`).

Пользователь может принудительно указать произвольный адрес компонентов для синхронизации, если это необходимо, с помощью явного указания опции `--synchronization=:local|(kubernetes://NAMESPACE[:CONTEXT][@(base64:CONFIG_DATA)|CONFIG_PATH])|(http[s]://DOMAIN)`.

**ЗАМЕЧАНИЕ:** Множество процессов werf, работающих с одним и тем же проектом обязаны использовать одинаковое хранилище и адрес набора компонентов синхронизации.

<< Как это работает

>> Дизайн стапеля

# Интеграция с SSH-агентом

werf необходим ssh-ключ пользователя в следующих случаях:

1. Клонирование удаленного git-репозитория, указанного в файле конфигурации `werf.yaml`.
1. Инструкции сборки образа требуют доступа к внешним данным по ssh.

По умолчанию (без указания каких-либо параметров) werf пытается использовать ssh-agent запущенный в системе, проверяя его доступность с помощью переменной окружения `SSH_AUTH_SOCK`.

В случае отсутствия в системе запущенного ssh-агента, werf пытается выступать в качестве ssh-клиента, для чего использует ssh-ключ пользователя по умолчанию, т.е. (`~/.ssh/id_rsa|id_dsa`). Если werf обнаруживает один из этих файлов, то выполняется запуск временного ssh-агента с добавлением найденных ключей.

Для использования только конкретных ssh-ключей, необходимо указывать опцию запуска `--ssh-key PRIVATE_KEY_FILE_PATH` (может быть указана несколько раз, для указания нескольких ssh-ключей). В этом случае werf выполняет запуск временного ssh-агента и добавляет ему только указанные ssh-ключи.

## Как werf работает с ssh-агентом

При работе с удаленными git-репозиториями используется UNIX-сокет `SSH_AUTH_SOCK`, который монтируется во все сборочные контейнеры. Таким образом, сборочные инструкции могут использовать ssh-агент через указанный UNIX-сокет.

**ЗАМЕЧАНИЕ** Существует ограничение, из-за которого только пользователь `root` внутри сборочного контейнера имеет доступ к UNIX-сокету из переменной окружения `SSH_AUTH_SOCK`.

## Временный ssh-агент

werf может запускать временный ssh-агент для работы некоторых команд. Такой ssh-агент завершает работу при завершении работы соответствующей команды werf.
В случае если в системе есть запущенный ssh-агент, то запускаемый werf временный ssh-агент не конфликтует с запущенным в системе ssh-агентом. -->

## Stapel
