---
title: Организация хранения образов в Container Registry
permalink: usage/build_draft/storage.html
---

<!-- прим. для перевода: на основе https://werf.io/documentation/v1.2/advanced/storage_layouts.html -->

В данной статье описано, как организовать хранение собираемых образов в Container Registry, какие бывают типы репозиториев, какие функции выполняют эти репозитории, а также различные варианты организации репозиториев проекта.

werf предоставляет несколько типов репозиториев: первичный (`--repo`), вторичный (`--secondary-repo`), финальный (`--final-repo`) и кэширующий (`--cache-repo`). Эти параметры доступны для основных команд werf (`werf build`, `werf converge` и т.п.).

## Используем один репозиторий для всего

В этом случае используется единый репозиторий в Container Registry, который называется **первичным** и задаётся параметром `--repo`:

```shell
werf converge --repo registry.mycompany.org/project
```

Указанный адрес Container Registry должен быть доступен со всех сборочных хостов, а также из кластера Kubernetes:
- При сборке образов сборочный кэш будет скачиваться и загружаться в этот репозиторий.
- При выкате, runtime Kubernetes будет скачивать финальные образы приложения из данного репозитория.

**Первичный** репозиторий объединяет в себе несколько функций и хранит соответствующие данные:

1. История проекта.
  - Хранилище метаданных, связанных с Git-репозиторием, для собираемых образов и стадий.
  - История проекта позволяет реализовать продвинутый алгоритм безопасной очистки старых стадий на основе истории Git-репозитория (команда `werf cleanup`).
2. Синхронизация сборки в распределённом окружении.
  - Данное хранилище позволяет запускать сборку в распределённом окружении и эффективно переиспользовать собираемые стадии в таком окружении. Это возможно за счёт механизмов распределённой синхронизации, встроенных в werf. Эти механизмы работают исключительно с первичным репозиторием.
  - Как только стадия попадает в первичный репозиторий, эта стадия может быть переиспользована другими сборочными процессами, которые могут быть запущены с произвольного хоста.
3. Сборочный кэш ранее собранных стадий.
  - Ранее собранные стадии по возможности переиспользуются вместо того, чтобы собираться заново.
  - Данная функция схожа с привычным локальным сборочным кэшом в Docker server, однако в случае werf этот кэш находится в container registry.
4. Хранилище финальных образов, используемых при запуске приложения в Kubernetes.
  - Kubernetes будет скачивать образы из этого репозитория для запуска контейнеров приложения.
  - В качестве финальных образов напрямую используются те же стадии, из которых состоит собранный образ.

> **Очистка (ВАЖНО!).** Для корректной и полноценной работы werf первичный репозиторий должен быть надёжным (persistent) хранилищем, образы из которого удаляются лишь специальной командой очистки `werf cleanup`. Первичный репозиторий — это не просто сборочный кэш проекта, но и хранилище его истории, похожее на историю коммитов в Git-репозитории и необходимое для корректной работы werf.

Помимо первичного репозитория в werf есть другие типы репозиториев, которые могут выполнять часть его функций. Они будут рассмотрены далее. Стоит помнить, что **без первичного репозитория werf не работает, а все другие репозитории — дополнительные**; они были созданы, чтобы снять часть функций первичного репозитория в вашей инсталляции проекта.

## Использование дополнительного репозитория для финальных образов

Первичный репозиторий сохраняет помимо финальных образов также и теги промежуточных слоёв кеша и некоторые метаданные, необходимые для работы очистки и сборки. В случае если требуется хранить в репозитории только финальные образы, которые выкатываются в Kubernetes, то необходимо использовать **финальный** репозиторий, задаваемый параметом `--final-repo`:

```shell
werf build --final-repo registry.mycompany.org/project-final --repo registry.mycompany.org/project
```

В данной схеме первичный репозиторий выполняет [все свои основные функции](#используем-один-репозиторий-для-всего), но дополнительно появляется финальный репозиторий, который забирает на себя функцию хранения образов, используемых при запуске приложения в Kubernetes.

> **ЗАМЕЧАНИЕ:** При использовании финального репозитория `--final-repo` также обязательным является указание и первичного репозитория параметром `--repo`.

## Использование дополнительного кешируюшего репозитория

С помощью параметра `--cache-repo` можно указать один или несколько т.н. **кеширующих** репозиториев.

```shell
# дополнительный кэширующий репозиторий в локальной сети
werf build --repo registry.mycompany.org/project --cache-repo localhost:5000/project
```

Кеширующий репозиторий как правило должен быть расположен близко к сборочному раннеру (как правило в локальной сети). При сборке образов сборочный кэш загружается и в первичный репозиторий, и в кэширующий репозиторий. Стадии образов, требуемые для сборки других стадий, будут скачиваться из кэширующего репозитория при наличии. Кэширующий репозиторий никогда не используется при запуске приложения в Kubernetes.

Очистка кэширующего репозитория осуществляется путём его полного удаления. После очистки такой репозиторий будет вновь наполнен актуальными часто используемыми данными.

> **ЗАМЕЧАНИЕ:** При использовании кэширующего репозитория `--cache-repo` необходимо также указывать и первичный репозиторий параметром `--repo`.

## Миграция между разными Container Registry

Чтобы осуществить миграцию на другой Container Registry с сохранением данных можно указать адрес старого registry в качестве **вторичного** репозитория, а адрес нового репозитория в качестве **первичного** для команды `werf build`:

```shell
werf build --secondary-repo registry.mydomain.org/project --repo newregistry.mydomain.org/project
```

Особенность вторичного репозитория (`--secondary-repo`) в том, что он используется в режиме только для чтения. Если в первичном репозитории не хватает какого-то образа, то прежде чем собирать его, werf проверит вторичный репозиторий и если найдёт, то перекачает недостающий образ оттуда в первичный репозиторий.

`werf build` при этом запускается на том коммите, кеш которого необходимо перенести в новый репозиторий.

Данную технику также можно использовать для переключения между 2-мя инсталляциями Container Registry, когда необходимо полностью очистить один из Container Registry.

## Используем кэш CI/CD на локальной машине

Например есть проект, который при сборке через CI/CD pipeline использует первичный репозиторий `registry.mycompany.org/project`. Разработчик может переиспользовать сборочный кеш из репозитория доступного в режиме только для чтения с помощью параметра `--secondary-repo`, указав этот репозиторий в качестве **вторичного**:

```shell
# локальная сборка, но сборочный кеш подгружается из репозитория
werf build --secondary-repo registry.mycompany.org/project
```
