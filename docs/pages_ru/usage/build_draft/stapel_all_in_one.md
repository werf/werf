<!-- - [Обзор](#обзор)
- [Базовый образ](#базовый-образ)
  - [from, fromLatest](#from-fromlatest)
  - [fromImage и fromArtifact](#fromimage-и-fromartifact)
  - [fromCacheVersion](#fromcacheversion)
- [Пользовательские стадии](#пользовательские-стадии)
  - [Использование пользовательских стадий](#использование-пользовательских-стадий)
  - [beforeInstall](#beforeinstall)
  - [install](#install)
  - [beforeSetup](#beforesetup)
  - [setup](#setup)
- [Shell и Ansible](#shell-и-ansible)
  - [Ansible config и stage playbook](#ansible-config-и-stage-playbook)
  - [Поддерживаемые модули Ansible](#поддерживаемые-модули-ansible)
  - [Копирование файлов в Ansible](#копирование-файлов-в-ansible)
  - [Шаблоны Jinja](#шаблоны-jinja)
  - [Troubleshooting](#troubleshooting)
- [Стадия Dockerfile-инструкций](#стадия-dockerfile-инструкций)
- [Добавление исходного кода из git-репозиториев](#добавление-исходного-кода-из-git-репозиториев)
  - [Что такое git mapping?](#что-такое-git-mapping)
  - [Синтаксис](#синтаксис)
  - [Копирование директорий](#копирование-директорий)
  - [Изменение владельца](#изменение-владельца)
  - [Использование фильтров](#использование-фильтров)
  - [Наложение путей копирования](#наложение-путей-копирования)
  - [Добавление репозитория по протоколу HTTPS](#добавление-репозитория-по-протоколу-https)
  - [Добавление репозитория по протоколу SSH](#добавление-репозитория-по-протоколу-ssh)
  - [Работа с SSH-ключами](#работа-с-ssh-ключами)
  - [Подробнее про gitArchive, gitCache, gitLatestPatch](#подробнее-про-gitarchive-gitcache-gitlatestpatch)
  - [Rebase и _git-стадии_](#rebase-и-git-стадии)
- [Переменные окружения сборочного контейнера](#переменные-окружения-сборочного-контейнера)
- [Зависимости пользовательских стадий](#зависимости-пользовательских-стадий)
- [Зависимость от изменений в инструкциях сборки](#зависимость-от-изменений-в-инструкциях-сборки)
- [Зависимость от изменений в Git-репозитории](#зависимость-от-изменений-в-git-репозитории)
- [Зависимость от значения CacheVersion](#зависимость-от-значения-cacheversion)
  - [Пример: Общий образ для нескольких приложений](#пример-общий-образ-для-нескольких-приложений)
  - [Пример использования внешних зависимостей](#пример-использования-внешних-зависимостей)
- [Ускорение сборки и уменьшение размера за счёт монтирования](#ускорение-сборки-и-уменьшение-размера-за-счёт-монтирования)
- [Импорт из артефактов и образов](#импорт-из-артефактов-и-образов)

## Обзор

Альтернативный способ сборки образов с использованием т.н. сборщика stapel. Его особенности:

* Обеспечивает интеграцию с git и инкрементальную пересборку с учетом истории git-репозитория.
* Позволяет использовать golang-шаблонизацию для описания сборочных инструкций.

## Базовый образ

```yaml
image: example
from: alpine
```

Приведенная конфигурация описывает _образ_ `example`, _базовым образом_ для которого является образ из DockerHub с именем `alpine`. _Базовый образ_ может быть указан с помощью директив `from`, `fromImage` или `fromArtifact`.

### from, fromLatest

Директива `from` определяет имя и тег _базового образа_. Если тег не указан, то по умолчанию — `latest`.

```yaml
from: <image>[:<tag>]
```

По умолчанию процесс сборки не зависит от digest _базового образа_, а зависит только от значения директивы `from`.
Поэтому изменение _базового образа_ в локальном хранилище или в container registry не будет влиять на сборку, пока стадия _from_, с указанным значением образа, находится в _stages storage_.

Если вам нужна проверка digest образа, чтобы всегда использовать актуальный _базовый образ_, вы можете использовать директиву `fromLatest`.
Это приведет к тому, что при каждом запуске werf будет проверяться актуальный digest _базового образа_ в container registry.

Пример использования директивы `fromLatest`:

```yaml
fromLatest: true
```

> По умолчанию, использование директивы `fromLatest` запрещено гитерминизмом (подробнее об этом в [статье]({{ "advanced/giterminism.html" | true_relative_url }}))

### fromImage и fromArtifact

В качестве _базового образа_ можно указывать не только образ из локального хранилища или container registry, но и имя другого _образа_ или [_артефакта_]({{ "advanced/building_images_with_stapel/artifacts.html" | true_relative_url }}), описанного в том же файле `werf.yaml`. В этом случае необходимо использовать директивы `fromImage` и `fromArtifact` соответственно.

```yaml
fromImage: <image name>
fromArtifact: <artifact name>
```

Если _базовый образ_ уникален для конкретного приложения, то рекомендуемый способ — хранить его описание в конфигурации приложения (в файле `werf.yaml`) как отдельный _образ_ или _артефакт_, вместо того, чтобы ссылаться на Docker-образ.

Также эта рекомендация будет полезной, если вам, по каким-либо причинам, не хватает существующего _конвейера стадий_.
Используя в качестве _базового образа_ образ, описанный в том же `werf.yaml`, вы по сути можете построить свой _конвейер стадий_.

<a class="google-drawings" href="{{ "images/configuration/base_image2.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/configuration/base_image2_preview.png" | true_relative_url }}">
</a>

### fromCacheVersion

Как описано выше, в обычном случае процесс сборки активно использует кэширование.
При сборке выполняется проверка — изменился ли _базовый образ_.
В зависимости от используемых директив эта проверка на изменение digest или имени и тега образа.
Если образ не изменился, то дайджест стадии `from` остается прежней, и если в _stages storage_ есть образ с таким дайджестом, то он и будет использован при сборке.

С помощью директивы `fromCacheVersion` вы можете влиять на дайджест стадии `from` (т.к. значение `fromCacheVersion` — это часть дайджеста стадии) и, таким образом, управлять принудительной пересборкой образа.
Если вы измените значение, указанное в директиве `fromCacheVersion`, то независимо от того, менялся _базовый образ_ (или его digest) или остался прежним, при сборке изменится дайджест стадии `from` и, соответственно, всех последующих стадий.
Это приведет к тому, что сборка всех стадий будет выполнена повторно.

```yaml
fromCacheVersion: <string>
```

## Пользовательские стадии

***Пользовательские стадии*** — это [_стадии_]({{ "internals/stages_and_storage.html" | true_relative_url }}) со сборочными инструкциями из [конфигурации]({{ "reference/werf_yaml.html#секция-image" | true_relative_url }}). Другими словами — это стадии, конфигурируемые пользователем (существуют также служебные стадии, которые пользователь конфигурировать не может). В настоящее время существует два вида сборочных инструкций: _shell_ и _ansible_.

werf поддерживает четыре _пользовательские стадии_, которые выполняются последовательно в следующем порядке: _beforeInstall_, _install_, _beforeSetup_ и _setup_. В результате выполнения инструкций пользовательской стадии создается один слой образа. Т.е. по одному слою на каждую стадию вне зависимости от количества инструкций.

### Использование пользовательских стадий

werf позволяет определять до четырех _пользовательских стадий_ с инструкциями сборки. На содержание самих инструкций сборки werf не накладывает каких-либо ограничений, т.е. вы можете указывать все те же инструкции, которые указывали в Dockerfile в директиве `RUN`. Однако важно не просто перенести инструкции из Dockerfile, а правильно разбить их на _пользовательские стадии_. Исходя из опыта работы с реальными приложениями, мы пришли к заключению, что сборка большинства приложений проходит следующие этапы:

- установка системных пакетов;
- установка системных зависимостей;
- установка зависимостей приложения;
- настройка системных пакетов;
- настройка приложения.

Какая может быть наилучшая стратегия выполнения этих этапов?

Первая мысль — лучше выполнять эти этапы последовательно, кэшируя промежуточные результаты, а с другой стороны – разбивать инструкции по файловым зависимостям.

Подход с _пользовательскими стадиями_ предлагает следующую стратегию:
- использовать стадию _beforeInstall_ для инсталляции системных пакетов;
- использовать стадию _install_ для инсталляции системных зависимостей и зависимостей приложения;
- использовать стадию _beforeSetup_ для настройки системных параметров и установки приложения;
- использовать стадию _setup_ для настройки приложения.

Несмотря на изложенную четкую стратегию шаблона _пользовательских стадий_ и функции каждой стадии, по сути для пользователя нет никаких ограничений. Предложенное использование стадий является лишь рекомендацией, которая основана на нашем опыте с реальными приложениями. Вы можете использовать только одну пользовательскую стадию, либо определить свою стратегию группировки инструкций, чтобы получить преимущества кэширования и зависимостей от изменений в Git-репозиториях с учетом особенностей сборки вашего приложения.

### beforeInstall

```yaml
shell:
  beforeInstall:
    - apt update -q
    - apt install -y curl mysql-client libmysqlclient-dev g++ build-essential libcurl4
  beforeInstallCacheVersion: "1"
```

Данная стадия предназначена для выполнения инструкций перед установкой приложения.
Этот этап предназначен для системных приложений, которые редко изменяются, но требуют много времени для установки.
Примером таких приложений могут быть языковые пакеты или инструменты сборки, такие как Composer, Java, Gradle и т.д.
Также сюда можно добавлять инструкции настройки системы, которые редко изменяются.
Например, языковые настройки, настройки часового пояса, добавление пользователей и групп.

Поскольку эти компоненты меняются редко, они будут кэшироваться в рамках стадии _beforeInstall_ на длительный период.

`beforeInstallCacheVersion: <string>` — опциональная директива, которая позволяет инвалидировать сборочный кеш данной стадии детерминированным способом через git.

### install

```yaml
shell:
  install:
    - bundle install
    - npm ci
  installCacheVersion: "1"
```

Данная стадия предназначена для установки приложения и его зависимостей, а также выполнения базовых настроек.

На данной стадии появляется доступ к исходному коду используемых Git-репозиториев (директива `git`) и появляется возможность установки зависимостей на основе manifest-файлов с использованием таких инструментов, как Composer, Gradle, npm и т.д. Поскольку сборка стадии зависит от manifest-файла, для достижения наилучшего результата важно добавить зависимость от изменений в manifest-файлах репозитория для этой стадии. Например, если в проекте используется Composer, то добавление файла `composer.lock` в зависимости стадии _beforeInstall_ позволит пересобирать стадию при изменении файла `composer.lock`.

`installCacheVersion: <string>` — опциональная директива, которая позволяет инвалидировать сборочный кеш данной стадии детерминированным способом через git.

### beforeSetup

```yaml
shell:
  beforeSetup:
    - rake assets:precompile
  beforeSetupCacheVersion: "1"
```

Данная стадия предназначена для подготовки приложения перед настройкой.

На данной стадии рекомендуется выполнять разного рода компиляцию и обработку.
Например, компиляция jar-файлов, бинарных файлов, файлов библиотек, создание ассетов web-приложений, минификация, шифрование и т.п.
Перечисленные операции, как правило, зависят от изменений в исходном коде, и на данной стадии также важно определить достаточные зависимости от изменений в репозитории. Логично, что стадия будет зависеть от большего числа файлов в репозитории, чем на предыдущей стадии, и, соответственно, ее пересборка будет выполняться чаще.

При правильно определенных зависимостях изменения в коде приложения должны приводить к пересборке стадии _beforeSetup_, а изменение manifest-файла к стадии _install_ и последующих стадий.

`beforeSetupCacheVersion: <string>` — опциональная директива, которая позволяет инвалидировать сборочный кеш данной стадии детерминированным способом через git.

### setup

```yaml
shell:
  setup:
    - npm run build
  setupCacheVersion: "1"
```

Данная стадия предназначена для настройки приложения.

Обычно на данной стадии выполняется копирование файлов конфигурации (например, в папку `/etc`), создание файлов текущей версии приложения и т.д.
Такого рода операции не должны быть затратными по времени, т.к. они, скорее всего, будут выполняться в большинстве сборок.

`setupCacheVersion: <string>` — опциональная директива, которая позволяет инвалидировать сборочный кеш данной стадии детерминированным способом через git.

## Shell и Ansible

Пользовательские стадии и инструкции сборки определяются внутри двух взаимоисключающих директив — `shell` и `ansible`. Каждый образ может собираться либо используя сборочные инструкции ***shell***, либо задачи ***ansible***, описанные в соответствующих директивах.

Синтаксис описания _пользовательских стадий_ при использовании сборочных инструкций _shell_:

```yaml
shell:
  beforeInstall:
    - <shell command>
  install:
    - <shell command>
  beforeSetup:
    - <shell command>
  setup:
    - <shell command>
  cacheVersion: <version>
  beforeInstallCacheVersion: <version>
  installCacheVersion: <version>
  beforeSetupCacheVersion: <version>
  setupCacheVersion: <version>
```

Синтаксис описания _пользовательских стадий_ при использовании сборочных инструкций _ansible_:

```yaml
ansible:
  beforeInstall:
    - <ansible task>
  install:
    - <ansible task>
  beforeSetup:
    - <ansible task>
  setup:
    - <ansible task>
  cacheVersion: <version>
  beforeInstallCacheVersion: <version>
  installCacheVersion: <version>
  beforeSetupCacheVersion: <version>
  setupCacheVersion: <version>
```

### Ansible config и stage playbook

Сборочные инструкции _ansible_ — это массив Ansible-заданий для соответствующей _пользовательской стадии_.

Сгенерированный `ansible.cfg` содержит настройки для Ansible:
- использование локального транспорта (transport = local);
- подключение callback плагина werf для удобного логирования (stdout_callback = werf);
- включение режима цвета (force_color = 1);
- установка использования `sudo` для повышения привилегий (чтобы не было необходимости использовать `become` в Ansible-заданиях).

Сгенерированный `playbook.yml` — playbook, содержащий все задания соответствующей _пользовательской стадии_. Пример `werf.yaml` с описанием стадии _install_:

```yaml
ansible:
  install:
  - debug: msg='Start install'
  - file: path=/etc mode=0777
  - copy:
      src: /bin/sh
      dest: /bin/sh.orig
  - apk:
      name: curl
      update_cache: yes
```

Исполняемые файлы и библиотеки `ansible` и `python` находятся внутри Docker-тома _stapel_. Подробнее про эту концепцию можно узнать [в этой статье](https://habr.com/company/flant/blog/352432/) (упоминаемый в статье `dappdeps` был переименован в `stapel`, но принцип сохранился)

### Поддерживаемые модули Ansible

Одной из концепций, которую использует werf, является идемпотентность сборки. Это значит, что если «ничего не изменилось», то werf при повторном и последующих запусках сборки должен создавать бинарно идентичные образы. В werf эта задача решается с помощью подсчета _дайджестов стадий_.

Многие модули Ansible не являются идемпотентными, т.е. они могут давать разный результат запусков при неизменных входных параметрах. Это, конечно, не дает возможность корректно высчитывать _дайджест_ стадии, чтобы определять реальную необходимость её пересборки из-за изменений. Это привело к тому, что список поддерживаемых модулей был ограничен.

На текущий момент, список поддерживаемых модулей Ansible следующий:

- [Commands modules](https://docs.ansible.com/ansible/2.5/modules/list_of_commands_modules.html): command, shell, raw, script.
- [Crypto modules](https://docs.ansible.com/ansible/2.5/modules/list_of_crypto_modules.html): openssl_certificate и другие.
- [Files modules](https://docs.ansible.com/ansible/2.5/modules/list_of_files_modules.html): acl, archive, copy, stat, tempfile и другие.
- [Net Tools Modules](https://docs.ansible.com/ansible/2.5/modules/list_of_net_tools_modules.html): get_url, slurp, uri.
- [Packaging/Language modules](https://docs.ansible.com/ansible/2.5/modules/list_of_packaging_modules.html#language): composer, gem, npm, pip и другие.
- [Packaging/OS modules](https://docs.ansible.com/ansible/2.5/modules/list_of_packaging_modules.html#os): apt, apk, yum и другие.
- [System modules](https://docs.ansible.com/ansible/2.5/modules/list_of_system_modules.html): user, group, getent, locale_gen, timezone, cron и другие.
- [Utilities modules](https://docs.ansible.com/ansible/2.5/modules/list_of_utilities_modules.html): assert, debug, set_fact, wait_for.

При указании в _конфигурации сборки_ модуля, отсутствующего в приведенном списке, сборка прервется с ошибкой. Не стесняйтесь [сообщать](https://github.com/werf/werf/issues/new) нам, если вы считаете что какой-либо модуль должен быть включен в список поддерживаемых.

### Копирование файлов в Ansible

Предпочтительный способ копирования файлов в образ — использование [_git mapping_]({{ "advanced/building_images_with_stapel/git_directive.html" | true_relative_url }}).
werf не может определять изменения в копируемых файлах при использовании модуля `copy`.
Единственный вариант копирования внешнего файла в образ на текущий момент — использовать метод `.Files.Get` Go-шаблона.
Данный метод возвращает содержимое файла как строку, что дает возможность использовать содержимое как часть _пользовательской стадии_.
Таким образом, при изменении содержимого файла изменится дайджест соответствующей стадии, что приведет к пересборке всей стадии.

Пример копирования файла `nginx.conf` в образ:

{% raw %}
```yaml
ansible:
  install:
  - copy:
      content: |
{{ .Files.Get "/conf/etc/nginx.conf" | indent 8}}
      dest: /etc/nginx/nginx.conf
```
{% endraw %}

В результате получится подобный `playbook.yml`:

```yaml
- hosts: all
  gather_facts: no
  tasks:
    install:
    - copy:
        content: |
          http {
            sendfile on;
            tcp_nopush on;
            tcp_nodelay on;
            ...
```

### Шаблоны Jinja

В Ansible реализована поддержка шаблонов [Jinja](https://docs.ansible.com/ansible/2.5/user_guide/playbooks_templating.html) в playbook'ах. Однако у Go-шаблонов и Jinja-шаблонов одинаковый разделитель: {% raw %}`{{` и `}}`{% endraw %}. Чтобы использовать Jinja-шаблоны в конфигурации werf, их нужно экранировать. Для этого есть два варианта: экранировать только {% raw %}`{{`{% endraw %}, либо экранировать все выражение шаблона Jinja.

Например, у вас есть следующая задача Ansible:

{% raw %}
```yaml
- copy:
    src: {{item}}
    dest: /etc/nginx
    with_files:
    - /app/conf/etc/nginx.conf
    - /app/conf/etc/server.conf
```
{% endraw %}

{% raw %}
Тогда, выражение Jinja-шаблона `{{item}}` должно быть экранировано:
{% endraw %}

{% raw %}
```yaml
# Экранируем только {{.
src: {{"{{"}} item }}
```
либо
```yaml
# Экранируем все выражение.
src: {{`{{item}}`}}
```
{% endraw %}

### Troubleshooting

- Live-вывод реализован только для модулей `raw` и `command`. Остальные модули отображают вывод каналов `stdout` и `stderr` после выполнения, что приводит к задержкам и скачкообразному выводу.
- Модуль `apt` подвисает на некоторых версиях Debian и Ubuntu. Проявляется также на наследуемых образах ([issue #645](https://github.com/werf/werf/issues/645)).

## Стадия Dockerfile-инструкций

Инструкции в [Dockerfile](https://docs.docker.com/engine/reference/builder/) можно условно разделить на две группы: сборочные инструкции и инструкции, которые влияют на manifest Docker-образа.
Так как werf сборщик использует свой синтаксис для описания сборки, поддерживаются только следующие Dockerfile-инструкции второй группы:

* `USER` — имя пользователя (или UID) и опционально пользовательская группа (или GID) ([подробнее](https://docs.docker.com/engine/reference/builder/#user))
* `WORKDIR` — рабочая директория ([подробнее](https://docs.docker.com/engine/reference/builder/#workdir))
* `VOLUME` — точка монтирования ([подробнее](https://docs.docker.com/engine/reference/builder/#volume))
* `ENV` — переменные окружения ([подробнее](https://docs.docker.com/engine/reference/builder/#env))
* `LABEL` — метаданные ([подробнее](https://docs.docker.com/engine/reference/builder/#label))
* `EXPOSE` — описание сетевых портов, которые будут прослушиваться в запущенном контейнере ([подробнее](https://docs.docker.com/engine/reference/builder/#expose))
* `ENTRYPOINT` — команда по умолчанию, которая будет выполнена при запуске контейнера ([подробнее](https://docs.docker.com/engine/reference/builder/#entrypoint))
* `CMD` — аргументы по умолчанию для `ENTRYPOINT` ([подробнее](https://docs.docker.com/engine/reference/builder/#cmd))
* `HEALTHCHECK` — инструкции, которые Docker может использовать для проверки работоспособности запущенного контейнера ([подробнее](https://docs.docker.com/engine/reference/builder/#healthcheck))

Эти инструкции могут быть указаны с помощью директивы `docker` в конфигурации.

Пример:

```yaml
docker:
  WORKDIR: /app
  CMD: ["python", "./index.py"]
  EXPOSE: '5000'
  ENV:
    TERM: xterm
    LC_ALL: en_US.UTF-8
```

Указанные в конфигурации Dockerfile-инструкции применяются на последней стадии конвейера стадий, стадии `docker_instructions`.
Поэтому указание Dockerfile-инструкций в `werf.yaml` никак не влияет на сам процесс сборки, а только добавляет данные к уже собранному образу.

Если вам требуются определённые переменные окружения во время сборки (например, `TERM`), то вам необходимо использовать [базовый образ]({{ "advanced/building_images_with_stapel/base_image.html" | true_relative_url }}), в котором эти переменные окружения установлен или экспортировать их в [_пользовательской стадии_]({{ "advanced/building_images_with_stapel/assembly_instructions.html#пользовательские-стадии" | true_relative_url }}).

## Добавление исходного кода из git-репозиториев

### Что такое git mapping?

***Git mapping*** определяет, какой файл или папка из Git-репозитория должны быть добавлены в конкретное место образа.
Git-репозиторий может быть как локальным репозиторием, в котором находится файл конфигурации сборки (`werf.yaml`), так и удаленным.
В этом случае указывается адрес репозитория и версия кода — ветка, тег или конкретный коммит.

werf добавляет файлы из Git-репозитория в образ, копируя их с помощью [git archive](https://git-scm.com/docs/git-archive), либо накладывая Git-патч.
При повторных сборках и появлении изменений в Git-репозитории werf добавляет patch к собранному ранее образу, чтобы в конечном образе отразить изменения файлов и папок. Более подробно механизм переноса файлов и накладывания патчей рассматриваются [в следующей секции](#подробнее-про-gitarchive-gitcache-gitlatestpatch).

Конфигурация _git mapping_ поддерживает фильтры, что позволяет сформировать практически любую файловую структуру в образе, используя произвольное количество _git mappings_.
Также вы можете указать группу и владельца конечных файлов в образе, что освобождает от необходимости делать это отдельной командой (`chown`).

В werf реализована поддержка сабмодулей Git (git submodules) и если werf определяет, что какая-то часть _git mapping_ является сабмодулем, то принимаются соответствующие меры, чтобы обрабатывать изменения в сабмодулях корректно.

> Все Git-сабмодули проекта связаны с конкретным коммитом, поэтому все разработчики, работающие с репозиторием с сабмодулями, получают одинаковое содержимое.
> werf не инициализирует и не обновляет сабмодули, а использует соответствующие связанные коммиты.

Пример добавления файлов из папки `/src` локального Git-репозитория в папку `/app` собираемого образа и добавления кода PhantomJS из удаленного репозитория в папку `/src/phantomjs` собираемого образа:

```yaml
git:
- add: /src
  to: /app
- url: https://github.com/ariya/phantomjs
  add: /
  to: /src/phantomjs
```

### Синтаксис

Для добавления кода из локального Git-репозитория используется следующий синтаксис:

- `add` — (не обязательный параметр) путь к директории или файлу, содержимое которого (которой) нужно добавить в образ. Указывается абсолютный путь *относительно корня* репозитория, т.е. он должен начинаться с `/`. По умолчанию копируется все содержимое репозитория, отсутствие параметра `add` равносильно указанию `add: /`;
- `to` — путь внутри образа, куда будет скопировано соответствующее содержимое;
- `owner` — имя или id пользователя-владельца файлов в образе;
- `group` — имя или id группы-владельца файлов в образе;
- `excludePaths` — список исключений (маска) при рекурсивном копировании файлов и папок. Указывается относительно пути, указанного в `add`;
- `includePaths` — список масок файлов и папок для рекурсивного копирования. Указывается относительно пути, указанного в `add`;
- `stageDependencies` — список масок файлов и папок для указания зависимости пересборки стадии от их изменений. Позволяет указать, при изменении каких файлов и папок необходимо принудительно пересобирать конкретную пользовательскую стадию. Более подробно рассматривается [здесь]({{ "advanced/building_images_with_stapel/assembly_instructions.html" | true_relative_url }}).

При использовании удаленных репозиториев дополнительно используются следующие параметры:
- `url` — адрес удаленного репозитория;
- `branch`, `tag`, `commit` — имя ветки, тега или коммита соответственно. По умолчанию — ветка master.

> По умолчанию использование директивы `branch` запрещено гитерминизмом (подробнее об этом [в статье]({{ "advanced/giterminism.html" | true_relative_url }})).

### Копирование директорий

Параметр `add` определяет источник, путь в Git-репозитории, откуда файлы рекурсивно копируются в образ и помещаются по адресу, указанному в параметре `to`. Если параметр не определен, то по умолчанию используется значение `/`, т.е. копируется весь репозиторий.
Пример простейшей конфигурации, добавляющей содержимое всего локального Git-репозитория в образ в папку `/app`.

```yaml
git:
- add: /
  to: /app
```

<div class="tabs">
  <a href="javascript:void(0)" class="tabs__btn btn__example1 active" onclick="openTab(event, 'btn__example1', 'tab__example1', 'git-mapping-01-source')">Структура в репозитории</a>
  <a href="javascript:void(0)" class="tabs__btn btn__example1" onclick="openTab(event, 'btn__example1', 'tab__example1', 'git-mapping-01-dest')">Структура в конечном образе</a>
</div>
<div id="git-mapping-01-source" class="tabs__content tab__example1 active">
  <img src="{{ "images/build/git_mapping_01.png" | true_relative_url }}" alt="git repository files tree" />
</div>
<div id="git-mapping-01-dest" class="tabs__content tab__example1">
  <img src="{{ "images/build/git_mapping_02.png" | true_relative_url }}" alt="image files tree" />
</div>

Также можно указать несколько _git mappings_:

```yaml
git:
- add: /src
  to: /app/src
- add: /assets
  to: /static
```

<div class="tabs">
  <a href="javascript:void(0)" class="tabs__btn btn__example2 active" onclick="openTab(event, 'btn__example2', 'tab__example2', 'git-mapping-02-source')">Структура в репозитории</a>
  <a href="javascript:void(0)" class="tabs__btn btn__example2" onclick="openTab(event, 'btn__example2', 'tab__example2', 'git-mapping-02-dest')">Структура в конечном образе</a>
</div>
<div id="git-mapping-02-source" class="tabs__content tab__example2 active">
  <img src="{{ "images/build/git_mapping_03.png" | true_relative_url }}" alt="git repository files tree" />
</div>
<div id="git-mapping-02-dest" class="tabs__content tab__example2">
  <img src="{{ "images/build/git_mapping_04.png" | true_relative_url }}" alt="image files tree" />
</div>

Следует отметить, что конфигурация _git mapping_ не похожа, например, на копирование типа `cp -r /src /app`.
Параметр `add` указывает на *содержимое* каталога, которое будет рекурсивно копироваться из репозитория.
Поэтому, если папка `/assets` со всем содержимым из репозитория должна быть скопирована в папку `/app/assets` образа, то имя *assets* вы должны указать два раза.
Либо, как вариант, вы можете использовать [фильтр](#использование-фильтров) (например, параметр `includePaths`).

Примеры обоих вариантов, которые вы можете использовать для достижения одинакового результата:
```yaml
git:
- add: /assets
  to: /app/assets
```

либо

```yaml
git:
- add: /
  to: /app
  includePaths: [assets]
```

### Изменение владельца

При добавлении файла из Git-репозитория вы можете указать имя и/или группу владельца файлов в образе.
Добавляемым файлам и папкам в образе при копировании будут установлены соответствующие права.
Пользователь и группа могут быть указаны как именем, так и числовым id (userid, groupid).

Пример использования:

```yaml
git:
- add: /src/index.php
  to: /app/index.php
  owner: www-data
```

Если указан только параметр `owner`, как в приведенном примере, то группой-владельцем устанавливается основная группа указанного пользователя в системе.

В результате в папку `/app` образа будет добавлен файл `index.php` и ему будут установлены следующие права:

![index.php owned by www-data user and group]({{ "images/build/git_mapping_05.png" | true_relative_url }})

Если значения параметра `owner` или `group` не числовые id, а текстовые (т.е. названия соответственно пользователя и группы), то соответствующие пользователь и группа должны существовать в системе. Их нужно добавить заранее при необходимости (к примеру, на стадии _beforeInstall_), иначе при сборке возникнет ошибка.

```yaml
git:
- add: /src/index.php
  to: /app/index.php
  owner: wwwdata
```

### Использование фильтров

Парамеры фильтров, `includePaths` и `excludePaths`, используются при составлении списка файлов для добавления.
Эти параметры содержат набор путей или масок, применяемых соответственно для включения и исключения файлов и папок при добавлении в образ.

Фильтр `excludePaths` работает следующим образом: каждая маска списка применяется к каждому файлу, найденному по пути `add`.
Если файл удовлетворяет хотя бы одной маске, то он исключается из списка файлов на добавление.
Если файл не удовлетворяет ни одной маске, то он добавляется в образ.

Фильтр `includePaths` работает наоборот — если файл удовлетворяет хотя бы одной маске, то он добавляется в образ.

Конфигурация _git mapping_ может содержать оба фильтра.
В этом случае файл добавляется в образ, если его путь удовлетворяет хотя бы одной маске `includePaths` и не удовлетворяет ни одной маске `excludePaths`.

Пример:

```yaml
git:
- add: /src
  to: /app
  includePaths:
  - '**/*.php'
  - '**/*.js'
  excludePaths:
  - '**/*-dev.*'
  - '**/*-test.*'
```

В приведенном примере добавляются `.php` и `.js` файлы из папки  `/src` исключая файлы с суффиксом `-dev.` или `-test.` в имени файла.

> Последний шаг в алгоритме с добавлением суффикса`**/*` сделан для удобства — вам достаточно указать название папки в параметрах _git mapping_, чтобы все ее содержимое удовлетворяло шаблону параметра

Маска может содержать следующие шаблоны:

- `*` — Удовлетворяет любому файлу. Шаблон включает `.` и исключает `/`.
- `**` — Удовлетворяет директории со всем ее содержимым, рекурсивно.
- `?` — Удовлетворяет любому **одному** символу в имени файла (аналогично regexp-шаблону `/.{1}/`).
- `[set]` — Удовлетворяет любому символу из указанного набора символов. Аналогично использованию в regexp-шаблонах, включая указание диапазонов типа `[^a-z]`.
- `\` — Экранирует следующий символ.

Маска, которая начинается с шаблона `*` или `**`, должна быть взята в одинарные или двойные кавычки в `werf.yaml`:
- `"*.rb"` — двойные кавычки;
- `'**/*'` — одинарные кавычки.

Примеры фильтров:

```yaml
add: /src
to: /app
includePaths:
# Удовлетворяет всем php файлам, расположенным конкретно в папке /src.
- '*.php'

# Удовлетворяет всем php файлам рекурсивно, начиная с папки /src
# (также удовлетворяет файлам *.php, т.к. '.' включается шаблон **).
- '**/*.php'

# Удовлетворяет всем файлам в папке /src/module1 рекурсивно.
- module1
```

Фильтр `includePaths` может применяться для копирования одного файла без изменения имени. Пример:
```yaml
git:
- add: /src
  to: /app
  includePaths: index.php
```

### Наложение путей копирования

Если вы определяете несколько _git mappings_, вы должны учитывать, что при наложении путей в образе в параметре `to` вы можете столкнуться с невозможностью добавления файлов. Пример:

```yaml
git:
- add: /src
  to: /app
- add: /assets
  to: /app/assets
```

Чтобы избежать ошибок сборки, werf определяет возможные наложения касающиеся фильтров `includePaths` и `excludePaths`, и если такое наложение присутствует, то werf пытается разрешить самые простые конфликты, неявно добавляя соответствующий параметр `excludePaths` в _git mapping_.
Однако, такое поведение может все-таки привести к неожиданным результатам, поэтому лучше всего избегать наложения путей при определении _git mappings_.

В примере выше werf в итоге неявно добавит параметр  `excludePaths`, и итоговая конфигурация будет следующей:

```yaml
git:
- add: /src
  to: /app
  excludePaths:  # werf добавил этот фильтр, чтобы исключить конфликт наложения результирующих путей
  - assets       # между /src/assets и /assets
- add: /assets
  to: /app/assets
```

### Добавление репозитория по протоколу HTTPS

Синтаксис для работы по протоколу `https`:

{% raw %}
```yaml
git:
- url: https://[USERNAME[:PASSWORD]@]repo_host/repo_path[.git/]
```
{% endraw %}

Указание логина и пароля при доступе по `https` опционально.

Пример доступа к репозиторию из pipeline GitLab CI с использованием переменных окружения:

{% raw %}
```yaml
git:
- url: https://{{ env "CI_REGISTRY_USER" }}:{{ env "CI_JOB_TOKEN" }}@registry.gitlab.company.name/common/helper-utils.git
```
{% endraw %}

В приведенном примере используется метод [env](http://masterminds.github.io/sprig/os.html) библиотеки [Sprig](http://masterminds.github.io/sprig/) для доступа к переменным окружения.

### Добавление репозитория по протоколу SSH

Доступ к удаленному репозиторию с помощью протокола `git` защищается с использованием доступа поверх SSH. Это распространенная практика, используемая в частности GitHub, Bitbucket, GitLab, Gogs, Gitolite и т.д. Обычно адрес репозитория выглядит следующим образом:

```yaml
git:
- url: git@gitlab.company.name:project_group/project.git
```

Для работы с удаленными репозиториями по SSH необходимо понимать, как werf находит SSH-ключи (читай далее подробнее).

### Работа с SSH-ключами

SSH-ключи для доступа предоставляются через SSH-agent. SSH-agent — это демон, который работает через файловый сокет, путь к которому хранится в переменной окружения `SSH_AUTH_SOCK`. werf монтирует этот файловый сокет во все _сборочные контейнеры_ и устанавливает переменную окружения `SSH_AUTH_SOCK`. Т.e. соединение с удаленным Git-репозиторием устанавливается с использованием ключей, зарегистрированных в запущенном SSH-агенте.

werf использует следующий алгоритм для определения запущенного SSH-агента:

- werf запущен с ключом `--ssh-key` (одним или несколькими):
  - Запускается временный SSH-агент, в который добавляются указанные при запуске werf ключи. Эти ключи используются при всех операциях с удаленными репозиториями.
  - Уже запущенный SSH-агент игнорируется.
- werf запущен без указания ключа `--ssh-key` и есть запущенный SSH-агент:
  - Используется переменная окружения `SSH_AUTH_SOCK`, ключи добавляются в соответствующий SSH-агент и используются далее при всех операциях работы с удаленными репозиториями.
- werf запущен без указания ключа `--ssh-key` и нет запущенного SSH-агента:
  - Если существует файл `~/.ssh/id_rsa`, запускается временный SSH-агент, в который добавляется ключ из файла `~/.ssh/id_rsa`.
- Если ни один из вариантов не применим, то SSH-агент не запускается и при операциях с внешними Git-репозиториями не используются никакие SSH-ключи. Сборка образа, с объявленными удаленными репозиториями в _git mapping_, завершится с ошибкой.

### Подробнее про gitArchive, gitCache, gitLatestPatch

Далее будет более подробно рассмотрен процесс добавления файлов в конечный образ. Как упоминалось ранее, Docker-образ состоит из набора слоёв. Чтобы понимать, какие слои создает werf, представим последовательную сборку трех коммитов: `1`, `2` и `3`:

- Сборка коммита 1. Исходя из конфигурации _git mapping_, все соответствующие файлы добавляются в один слой. Сам процесс добавления выполняется с помощью `git archive`. Получившийся слой соответствует стадии _gitArchive_.
- Сборка коммита 2. Накладывается патч с изменениями файлов, в результате чего получается еще один слой. Получившийся слой соответствует стадии _gitLatestPatch_.
- Сборка коммита 3. Файлы уже добавлены, и werf накладывает патч, обновляя слой _gitLatestPatch_.

Сборки для этих коммитов можно представить ​​следующим образом:

|                                      |        gitArchive        |      gitLatestPatch      |
| ------------------------------------ | :----------------------: | :----------------------: |
| Commit No. 1 is made, build at 10:00 | files as in commit No. 1 |            -             |
| Commit No. 2 is made, build at 10:05 | files as in commit No. 1 | files as in commit No. 2 |
| Commit No. 3 is made, build at 10:15 | files as in commit No. 1 | files as in commit No. 3 |

Со временем количество коммитов растет, и размер патча между коммитом №1 и текущим может стать довольно большим. Это еще больше увеличит размер последнего слоя и общий размер стадий. Чтобы предотвратить неконтролируемый рост последнего слоя, werf предоставляет дополнительный промежуточный этап — _gitCache_. Когда _gitLatestPatch_ diff становится слишком большим, большая часть его diff объединяется с _gitCache_ diff, тем самым уменьшая размер стадии _gitLatestPatch_.

### Rebase и _git-стадии_

Каждая Git-стадия хранит служебные лейблы с SHA коммитами, которые использовались при сборке стадии.
Эти коммиты будут использоваться при сборке следующей Git-стадии при создании патчей (по сути это `git diff COMMIT_FROM_PREVIOUS_GIT_STAGE LATEST_COMMIT` для каждого _git-mapping_).

Если в стадии сохранён коммит, который отсутствует в Git-репозитории (например, после выполнения rebase), werf пересоберёт эту стадию, используя актуальный коммит.

## Переменные окружения сборочного контейнера

Вы можете использовать сервисные переменные окружения, которые доступны в сборочном контейнере, и, соответственно, доступны в инструкциях сборки. Их использование не приведёт к изменению инструкций сборки и вытекающим из этого пересборкам, даже если сами значения сервисных переменных меняются.

Доступны следующие переменные:
- `WERF_COMMIT_HASH`. Пример значения: `cda9d17265d174c62424e8f7b5e5640bf749c565`.
- `WERF_COMMIT_TIME_HUMAN`. Пример значения: `2022-01-24 17:26:19 +0300 +0300`.
- `WERF_COMMIT_TIME_UNIX`. Пример значения: `1643034379`.

Пример использования:
{% raw %}
```yaml
shell:
  install:
  - echo "Commands on the Install stage for $WERF_COMMIT_HASH"
```
{% endraw %}

В примере выше хэш текущего коммита будет подставлен в команду `echo ...`, но произойдет это в самый последний момент — на этапе выполнения инструкций shell'ом. Таким образом пересборок слоя install на каждом коммите происходить не будет.

## Зависимости пользовательских стадий

Одна из особенностей stapel — возможность определять зависимости, при которых происходит пересборка _стадии_.
Как указано [в статье]({{ "internals/stages_and_storage.html" | true_relative_url }}), сборка _стадий_ выполняется последовательно, одна за другой, и для каждой _стадии_ высчитывается _дайджест стадии_. У _дайджестов_ есть ряд зависимостей, при изменении которых _дайджест стадии_ меняется, что служит для werf сигналом для пересборки стадии с измененным _дайджестом_. Поскольку каждая следующая _стадия_ имеет зависимость, в том числе и от предыдущей _стадии_ согласно _конвейеру стадий_, при изменении дайджеста какой-либо _стадии_ произойдет пересборка и _стадии_ с изменённым дайджестом и всех последующих _стадий_.

_Дайджест пользовательских стадий_ и, соответственно, пересборка _пользовательских стадий_ зависят от изменений:
- в инструкциях сборки;
- в директивах семейства _cacheVersion_;
- в Git-репозитории (или Git-репозиториях);
- в файлах, импортируемых из [артефактов]({{ "advanced/building_images_with_stapel/artifacts.html" | true_relative_url }}).

Первые три описанных варианта зависимостей рассматриваются подробно далее.

## Зависимость от изменений в инструкциях сборки

_Дайджест пользовательской стадии_ зависит от итогового текста инструкций, т.е. после применения шаблонизатора. Любые изменения в тексте инструкций с учетом применения шаблонизатора Go или Jinja (в случае Ansible) в _пользовательской стадии_ приводят к пересборке _стадии_. Например, вы используете следующие _shell-инструкции_:

```yaml
shell:
  beforeInstall:
  - echo "Commands on the Before Install stage"
  install:
  - echo "Commands on the Install stage"
  beforeSetup:
  - echo "Commands on the Before Setup stage"
  setup:
  - echo "Commands on the Setup stage"
```

При первой сборке этого образа будут выполнены инструкции всех четырех _пользовательских стадий_.
В данной конфигурации нет _git mapping_, так что последующие сборки не приведут к повторному выполнению инструкций — _дайджест пользовательских стадий_ не изменилась, сборочный кэш содержит актуальную информацию.

Изменим инструкцию сборки для стадии _install_:

```yaml
shell:
  beforeInstall:
  - echo "Commands on the Before Install stage"
  install:
  - echo "Commands on the Install stage"
  - echo "Installing ..."
  beforeSetup:
  - echo "Commands on the Before Setup stage"
  setup:
  - echo "Commands on the Setup stage"
```

Дайджест стадии _install_ изменилась, и запуск werf для сборки приведет к выполнению всех инструкций стадии _install_ и инструкций последующих _стадий_, т.е. _beforeSetup_ и _setup_.

Дайджест стадии может меняться также из-за использования переменных окружения и Go-шаблонов.
Если не уделять этому достаточное внимание при написании конфигурации, можно столкнуться с неожиданными пересборками стадий. Например:

{% raw %}
```yaml
shell:
  beforeInstall:
  - echo "Commands on the Before Install stage for {{ env "CI_COMMIT_SHA” }}"
  install:
  - echo "Commands on the Install stage"
  ...
```
{% endraw %}

Первая сборка высчитает дайджест стадии _beforeInstall_ на основе команды (хэш коммита, конечно, будет другой):
```shell
echo "Commands on the Before Install stage for 0a8463e2ed7e7f1aa015f55a8e8730752206311b"
```

После очередного коммита, при сборке дайджест стадии _beforeInstall_ уже будет другой (с других хешем коммита):

```shell
echo "Commands on the Before Install stage for 36e907f8b6a639bd99b4ea812dae7a290e84df27"
```

Соответственно, используя переменную `CI_COMMIT_SHA` дайджест стадии _beforeInstall_ будет меняться после каждого коммита, что будет приводить к пересборке.

## Зависимость от изменений в Git-репозитории

<a class="google-drawings" href="{{ "images/configuration/assembly_instructions3.png" | true_relative_url }}" data-featherlight="image">
<img src="{{ "images/configuration/assembly_instructions3_preview.png" | true_relative_url }}" alt="Зависимость от изменений в git-репозитории">
</a>

Как описывалось в статье [про _git mapping_]({{ "advanced/building_images_with_stapel/git_directive.html" | true_relative_url }}), существуют специальные стадии _gitArchive_ и _gitLatestPatch_.
Стадия _gitArchive_ выполняется после пользовательской стадии _beforeInstall_, а стадия _gitLatestPatch_ после пользовательской стадии _setup_, если в локальном Git-репозитории есть изменения.
Таким образом, чтобы выполнить сборку с последней версией исходного кода, можно пересобрать стадию _beforeInstall_, изменив значение директивы _cacheVersion_ либо изменив сами инструкции стадии _beforeInstall_.

Пользовательские стадии _install_, _beforeSetup_ и _setup_ также могут зависеть от изменений в Git-репозитории. В этом случае (если такая зависимость определена) Git-патч применяется перед выполнением инструкций _пользовательской стадии_, чтобы сборочные инструкции выполнялись с актуальной версией кода приложения.

> Во время процесса сборки исходный код обновляется **только в рамках одной стадии**, последующие стадии, зависящие последовательно друг от друга, будут использовать также обновленную версию файлов.
> Первая сборка добавляет файлы из Git-репозитория на стадии _gitArchive_. Все последующие сборки обновляют файлы на стадии _gitCache_, _gitLatestPatch_ или на одной из следующих пользовательских стадий: _install_, _beforeSetup_, _setup_.
<br />
<br />
Пример этого этапа (фаза подсчета дайджестов, _calculating digests_):
![git files actualized on specific stage]({{ "images/build/git_mapping_updated_on_stage.png" | true_relative_url }})

Зависимость _пользовательской стадии_ от изменений в Git-репозитории указывается с помощью параметра `git.stageDependencies`. Синтаксис:

```yaml
git:
- ...
  stageDependencies:
    install:
    - <mask 1>
    ...
    - <mask N>
    beforeSetup:
    - <mask>
    ...
    setup:
    - <mask>
```

У параметра `git.stageDependencies` возможно указывать 3 ключа: `install`, `beforeSetup` и `setup`.
Значение каждого ключа — массив масок файлов, относящихся к соответствующей стадии. Соответствующая _пользовательская стадия_ пересобирается, если в Git-репозитории происходят изменения подпадающие под указанную маску.

Для каждой _пользовательской стадии_ werf создает список подпадающих под маску файлов и вычисляет контрольную сумму каждого файла с учетом его аттрибутов и содержимого. Эти контрольные суммы являются частью _дайджеста стадии_, поэтому любое изменение файлов в репозитории, подпадающее под маску, приводит к изменениям _дайджеста стадии_. К этим изменениям относятся: изменение атрибутов файла, изменение содержимого файла, добавление или удаление подпадающего под маску файла и т.п.

При применении маски, указанной в `git.stageDependencies`, учитываются значения параметров `git.includePaths` и `git.excludePaths` (смотри подробнее про них [в соответствующем разделе]({{ "advanced/building_images_with_stapel/git_directive.html#использование-фильтров" | true_relative_url }})). werf считает подпадающими под маску только файлы, удовлетворяющие фильтру `includePaths` и подпадающие под маску `stageDependencies`. Аналогично werf считает подпадающими под маску только файлы, не удовлетворяющие фильтру `excludePaths` и не подпадающие под маску `stageDependencies`.

Правила описания маски в параметре `stageDependencies` аналогичны описанию параметров `includePaths` и `excludePaths`. Маска определяет шаблон для файлов и путей и может содержать следующие шаблоны:

- `*` — Удовлетворяет любому файлу. Шаблон включает `.` и исключает `/`.
- `**` — Удовлетворяет директории со всем ее содержимым, рекурсивно.
- `?` — Удовлетворяет любому одному символу в имени файла (аналогично regexp-шаблону `/.{1}/`).
- `[set]` — Удовлетворяет любому символу из указанного набора символов. Аналогично использованию в regexp-шаблонах, включая указание диапазонов типа `[^a-z]`.
- `\` — Экранирует следующий символ.


Маска, которая начинается с шаблона `*` или `**`, должна быть взята в одинарные или двойные кавычки в `werf.yaml`:

```
# * в начале маски, используем двойные кавычки
- "*.rb"
# одинарные также работают
- '**/*'
# нет * в начале, можно не использовать кавычки
- src/**/*.js
```

Факт изменения файлов в Git-репозитории werf определяет, подсчитывая их контрольные суммы. Для _пользовательской стадии_ и для каждой маски применяется следующий алгоритм:

- werf создает список всех файлов согласно пути, определенному в параметре `add`, и применяет фильтры `excludePaths` и `includePaths`;
- К каждому файлу с учетом его пути применяется маска, согласно правилам применения шаблонов;
- Если под маску подпадает каталог, то все содержимое этого каталога считается подпадающей под маску рекурсивно;
- У получившегося списка файлов werf подсчитывает контрольные суммы с учетом аттрибутов файлов и их содержимого.

Контрольные суммы подсчитываются вначале сборочного процесса перед запуском какой-либо стадии.

Пример:

```yaml
image: app
git:
- add: /src
  to: /app
  stageDependencies:
    beforeSetup:
    - "*"
shell:
  install:
  - echo "install stage"
  beforeSetup:
  - echo "beforeSetup stage"
  setup:
  - echo "setup stage"
```

В приведенном файле конфигурации `werf.yaml` указан _git mapping_, согласно которому содержимое папки `/src` локального Git-репозитория копируется в папку `/app` собираемого образа.
Во время первой сборки файлы кэшируются в стадии _gitArchive_ и выполняются сборочные инструкции стадий _install_, _beforeSetup_ и _setup_.

Сборка следующего коммита, в котором будут только изменения файлов за пределами папки `/src`, не приведет к выполнению инструкций каких-либо стадий. Если коммит будет содержать изменение внутри папки `/src`, контрольные суммы файлов подпадающих под маску изменятся, werf применит Git-патч и пересоберёт все пользовательские стадии, начиная со стадии _beforeSetup_, а именно — _beforeSetup_ и _setup_. Применение Git-патча будет выполнено один раз на стадии _beforeSetup_.

## Зависимость от значения CacheVersion

Существуют ситуации, когда необходимо принудительно пересобрать все или какую-то конкретную _пользовательскую стадию_. Этого можно достичь, изменяя параметры `cacheVersion` или `<user stage name>CacheVersion`.

Дайджест пользовательской стадии _install_ зависит от значения параметра `installCacheVersion`. Чтобы пересобрать пользовательскую стадию _install_ (и все последующие стадии), можно изменить значение параметра `installCacheVersion`.

> Обратите внимание, что параметры `cacheVersion` и `beforeInstallCacheVersion` имеют одинаковый эффект — при изменении этих параметров возникает пересборка стадии _beforeInstall_ и всех последующих стадий.

### Пример: Общий образ для нескольких приложений

Вы можете определить образ, содержащий общие системные пакеты в отдельном файле `werf.yaml`. Изменение параметра `cacheVersion` может быть использовано для пересборки этого образа, чтобы обновить версии системных пакетов.

```yaml
image: ~
from: ubuntu:latest
shell:
  beforeInstallCacheVersion: 2
  beforeInstall:
  - apt update
  - apt install ...
```

Этот образ может быть использован как базовый образ для нескольких приложений (например, если образ с hub.docker.com не удовлетворяет вашим требованиям).

### Пример использования внешних зависимостей

Параметры _CacheVersion_ можно использовать совместно [с шаблонами Go-шаблонизатора]({{ "reference/werf_yaml_template_engine.html" | true_relative_url }}), чтобы определить зависимость _пользовательской стадии_ от файлов, не находящихся в Git-репозитории.

{% raw %}
```yaml
image: ~
from: ubuntu:latest
shell:
  installCacheVersion: {{.Files.Get "some-library-latest.tar.gz" | sha256sum}}
  install:
  - tar zxf some-library-latest.tar.gz
  - <build application>
```
{% endraw %}

Если использовать, например, скрипт загрузки файла `some-library-latest.tar.gz` и запускать werf для сборки уже после скачивания файла, то пересборка пользовательской стадии _install_ (и всех последующих) будет происходить в случае, если скачан новый (измененный) файл.

## Ускорение сборки и уменьшение размера за счёт монтирования

Довольно часто бывают случаи, когда при сборке у вас появляются файлы которые нет необходимости оставлять в образе, и их нужно исключить. Например:
- Большинство пакетных менеджеров создают в системе кэш пакетов и служебных файлов.
  - [APT](https://wiki.debian.org/Apt) хранит список пакетов в директории `/var/lib/apt/lists/`.
  - APT также хранит сами пакеты в директории `/var/cache/apt/`.
  - [YUM](http://yum.baseurl.org/) может оставлять скачанные пакеты в директории `/var/cache/yum/.../packages/`.
- Менеджеры пакетов, используемые разработчиками, такие как, ​npm (Node.js), Glide (Go), pip (Python), хранят файлы в директории кэша.
- Компиляция приложений на C/C++ и т.п. языках оставляет объектные файлы и т.п.

Такого рода файлы:
- не нужны в образе;
- могут значительно увеличивать размер образа;
- могут быть полезны при повторной сборке образа или других образов.

Если монтировать такого рода файлы в сборочный контейнер, то можно добиться не только уменьшения размера образа, но и ускорения процесса сборки. В Docker такой механизм реализуется с помощью [томов](https://docs.docker.com/storage/volumes/).

Для указания тома используется директива `mount`. Директории узла сборки монтируются в сборочный контейнер согласно директивам `from`/`fromPath` и `to` описания томов. Для указания в качестве точки монтирования на сборочном узле любого файла или директории, вы можете использовать директиву `fromPath`. Либо, используя директиву `from`, вы можете указать одну из следующих служебных директорий:
- `tmp_dir` временная директория, индивидуальная для каждого описанного образа, создаваемая заново при каждой сборке;
- `build_dir` общая директория, доступная всем образам проекта и сохраняемая между сборками (находится по пути `~/.werf/shared_context/mounts/projects/<project name>/<mount id>/`). Вы можете использовать эту директорию для хранения, например, кэша и т.п.

> werf монтирует служебные директории с возможностью чтения и записи при каждой сборке, но в образе содержимого этих директорий не будет. Если вам необходимо сохранить какие-либо данные из этих директорий непосредственно в образе, то вы должны их скопировать при сборке

На стадии `from`, werf добавляет специальные лейблы к образу стадии, согласно описанных точек монтирования. Затем, на каждой стадии, werf использует эти лейблы при монтировании директорий в сборочный контейнер. Такая реализация позволяет наследовать точки монтирования от [базового образа]({{ "advanced/building_images_with_stapel/base_image.html" | true_relative_url }}).

Также, нужно иметь в виду, что на стадии `from` werf очищает точки монтирования в [базовом образе]({{ "advanced/building_images_with_stapel/base_image.html" | true_relative_url }}) (т.е. эти папки будут пусты).

> По умолчанию, использование директивы `fromPath` и `from: build_dir` запрещено гитерминизмом (подробнее об этом в [статье]({{ "/advanced/giterminism.html#mount" | true_relative_url }}))

## Импорт из артефактов и образов

Из-за используемых инструментов сборки, либо просто из-за исходных файлов, размер конечного образа может увеличиваться в несколько раз. Зачастую эти файлы не нужны в конечном образе. Для решения таких проблем, сообщество Docker предлагает выполнять установки инструментов, сборку и удаление ненужных файлов за один шаг.

Условный пример:
```
RUN “download-source && cmd && cmd2 && remove-source”
```

> Аналогичный пример может быть реализован и в werf. Для этого достаточно описать инструкции в одной _пользовательской стадии_. Пример при использовании _shell-сборщика_ для стадии _install_ (аналогичен и для _ansible-сборщика_):
```yaml
shell:
  install:
  - "download-source"
  - "cmd"
  - "cmd2"
  - "remove-source"
```

Однако при использовании такого метода кэширование работать не будет, и установка инструментов сборки будет выполняться каждый раз.

Другой способ — использование multi-stage сборки, которая поддерживается начиная с версии 17.05 Docker.

```
FROM node:latest AS storefront
WORKDIR /app
COPY react-app .
RUN npm install
RUN npm run build

FROM maven:latest AS appserver
WORKDIR /app
COPY . .
RUN mvn package

FROM java:8-jdk-alpine
COPY --from=storefront /app/react-app/build/ /static
COPY --from=appserver /app/target/AtSea-0.0.1-SNAPSHOT.jar /app/AtSea.jar
```

Смысл такого подхода в следующем — описать несколько вспомогательных образов и выборочно копировать артефакты из одного образа в другой, оставляя все то, что не нужно в конечном образе.

werf предлагает такой-же подход, но с использованием [_образов_]({{ "reference/werf_yaml.html#секция-image" | true_relative_url }}) и _артефактов_.

> Почему werf не использует multi-stage сборку?
* Исторически, возможность _импорта_ появилась значительно раньше чем в Docker появилась multi-stage сборка.
* werf дает больше гибкости при работе со вспомогательными образами

Импорт _ресурсов_ из _образов_ и _артефактов_ должен быть описан в директиве `import` в конфигурации [_образа_]({{ "reference/werf_yaml.html#секция-image" | true_relative_url }}) или _артефакта_ куда импортируются файлы. `import` — массив записей, каждая из которых должна содержать следующие параметры:

- `image: <image name>` или `artifact: <artifact name>`: _исходный образ_, имя образа из которого вы хотите копировать файлы или папки.
- `stage: <stage name>`: _стадия исходного образа_, определённая стадия _исходного образа_ из которого вы хотите копировать файлы или папки.
- `add: <absolute path>`: _исходный путь_, абсолютный путь к файлу или папке в _исходном образе_ для копирования.
- `to: <absolute path>`: _путь назначения_, абсолютный путь в _образе назначения_ (куда импортируются файлы или папки). В случае отсутствия считается равным значению указанному в параметре `add`.
- `before: <install || setup>` or `after: <install || setup>`: _стадия образа назначения_ для импорта. В настоящий момент возможен импорт только до/после стадии _install_ или _setup_.

Пример:
```yaml
import:
- artifact: application-assets
  add: /app/public/assets
  to: /var/www/site/assets
  after: install
- image: frontend
  add: /app/assets
  after: setup
```

Так же как и при конфигурации _git mappings_ поддерживаются маски включения и исключения файлов и папок.
Для указания маски включения файлов используется параметр `include_paths: []`, а для исключения `exclude_paths: []`. Маски указываются относительно пути источника (параметр `add`).
Вы также можете указывать владельца и группу для импортируемых ресурсов с помощью параметров `owner: <owner>` и `group: <group>` соответственно.
Это поведение аналогично используемому при добавлении кода из git-репозиториев, и вы можете подробнее почитать об этом в [соответствующем разделе]({{ "advanced/building_images_with_stapel/git_directive.html" | true_relative_url }}).

> Обратите внимание, что путь импортируемых ресурсов и путь указанный в _git mappings_ не должны пересекаться

Подробнее об использовании _артефактов_ можно узнать в [отдельной статье]({{ "advanced/building_images_with_stapel/artifacts.html" | true_relative_url }}). -->
