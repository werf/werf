---
title: Шаблоны
permalink: usage/deploy/templates.html
---

## Шаблонизация

Механизм шаблонизации в werf ничем не отличается от Helm. Используется движок шаблонов [Go text/template](https://pkg.go.dev/text/template), расширенный готовым набором функций [Sprig](https://masterminds.github.io/sprig/) и Helm.

## Файлы шаблонов

В директории `templates` чарта находятся файлы шаблонов.

Файлы шаблонов `templates/*.yaml` формируют конечные Kubernetes-манифесты для развертывания. Каждый из этих файлов может формировать сразу несколько манифестов Kubernetes-ресурсов. Для этого манифесты должны быть разделены строкой `---`.

Файлы шаблонов `templates/_*.tpl` содержат только именованные шаблоны для использования в других файлах. Файлы `*.tpl` не формируют Kubernetes-манифесты сами по себе.

## Действия

Главный элемент шаблонизации — действие. Действие может возвращать только строки. Действие заключается в двойные фигурные скобки:

{% raw %}

```
{{ print "hello" }}
```

{% endraw %}

Результат:

```
hello
```

## Переменные

Переменные используются для хранения или указания на данные любого типа.

Объявление и присваивание переменной:

{% raw %}

```
{{ $myvar := "hello" }}
```

{% endraw %}

Присваивание нового значения существующей переменной:

{% raw %}

```
{{ $myvar = "helloworld" }}
```

{% endraw %}

Использование переменной:

{% raw %}

```
{{ $myvar }}
```

{% endraw %}

Результат:

```
helloworld
```

Использование предопределенных переменных:

{% raw %}

```
{{ $.Values.werf.env }}
```

{% endraw %}

Данные можно подставлять и без объявления переменных:

{% raw %}

```
labels:
  app: {{ "myapp" }}
```

{% endraw %}

Результат:

```yaml
labels:
  app: myapp
```

Также в переменные можно сохранять результат выполнения функций или конвейеров:

{% raw %}

```
{{ $myvar := 1 | add 1 1 }}
{{ $myvar }} 
```

{% endraw %}

Результат:

```
3
```

## Области видимости переменных

Область видимости ограничивает видимость переменных. По умолчанию область видимости переменных ограничена файлом-шаблоном.

Область видимости может меняться при использовании некоторых блоков и функций. К примеру, блок `if` создаёт новую область видимости, а переменные, объявленные в блоке `if`, будут недоступны снаружи:

{% raw %}

```
{{ if true }}
  {{ $myvar := "hello" }}
{{ end }}

{{ $myvar }}
```

{% endraw %}

Результат:

```
Error: ... undefined variable "$myvar"
```

Чтобы обойти это ограничение, объявите переменную за пределами блока, а значение присвойте ей внутри блока:

{% raw %}

```
{{ $myvar := "" }}
{{ if true }}
  {{ $myvar = "hello" }}
{{ end }}

{{ $myvar }}
```

{% endraw %}

Результат:

```
hello
```

## Типы данных

Доступные типы данных:

| Тип данных                                                           | Пример                                              |
| -------------------------------------------------------------------- | --------------------------------------------------- |
| Логический                                                           | {% raw %}`{{ true }}`{% endraw %}                   |
| Строка                                                               | {% raw %}`{{ "hello" }}`{% endraw %}                |
| Целое число                                                          | {% raw %}`{{ 1 }}`{% endraw %}                      |
| Число с плавающей точкой                                             | {% raw %}`{{ 1.1 }}`{% endraw %}                    |
| Список с элементами любого типа, упорядоченный                       | {% raw %}`{{ list 1 2 3 }}`{% endraw %}             |
| Словарь с ключами-строками и значениями любого типа, неупорядоченный | {% raw %}`{{ dict "key1" 1 "key2" 2 }}`{% endraw %} |
| Специальные объекты                                                  | {% raw %}`{{ $.Files }}`{% endraw %}                |
| Нуль                                                                 | {% raw %}`{{ nil }}`{% endraw %}                    |

## Функции

В werf встроена обширная библиотека функций для использования в шаблонах. Основная их часть — функции Helm.

Функции можно использовать только в действиях. Функции *могут* иметь аргументы и *могут* возвращать данные любого типа. Например, приведенная ниже функция сложения принимает три аргумента-числа и возвращает число:

{% raw %}

```
{{ add 3 2 1 }}
```

{% endraw %}

Результат:

```
6
```

Обратите внимание, что **результат выполнения действия всегда конвертируется в строку** независимо от возвращаемого функцией типа данных.

Аргументами функций могут быть:

- простые значения: `1`;

- вызовы других функций: `add 1 1`;

- конвейеры: `1 | add 1`;

- комбинации вышеперечисленных типов: `1 | add (add 1 1)`.

Если аргумент — не простое значение, а вызов другой функции или конвейер, заключите его в круглые скобки `()`:

{% raw %}

```
{{ add 3 (add 1 1) (1 | add 1) }}
```

{% endraw %}

Чтобы игнорировать возвращаемый функцией результат, просто сохраните его в переменную `$_`:

{% raw %}

```
{{ $_ := set $myDict "mykey" "myvalue"}}
```

{% endraw %}

## Конвейеры

Конвейеры позволяют передать результат выполнения первой функции как последний аргумент во вторую функцию, а результат второй функции — как последний аргумент в третью и так далее:

{% raw %}

```
{{ now | unixEpoch | quote }}
```

{% endraw %}

Здесь результат выполнения функции `now` (получить текущую дату) передаётся как аргумент в функцию `unixEpoch` (преобразует дату в Unix time), после чего полученное значение передаётся в функцию `quote` (оборачивает в кавычки).

Итоговый результат:

```
"1671466310"
```

Использование конвейеров не обязательно, и при желании их можно переписать следующим образом:

{% raw %}

```
{{ quote (unixEpoch (now)) }}
```

{% endraw %}

... однако рекомендуется использовать именно конвейеры.

## Логические операции и сравнения

Логические операции реализуются следующими функциями:

| Операция | Функция                        | Пример                                     |
| -------- | ------------------------------ | ------------------------------------------ |
| НЕ       | `not <arg>`                    | {% raw %}`{{ not false }}`{% endraw %}     |
| И        | `and <arg> <arg> [<arg>, ...]` | {% raw %}`{{ and true true }}`{% endraw %} |
| ИЛИ      | `or <arg> <arg> [<arg>, ...]`  | {% raw %}`{{ or false true }}`{% endraw %} |

Сравнения реализуются следующими функциями:

| Сравнение               | Функция                        | Пример                                           |
| ----------------------- | ------------------------------ | ------------------------------------------------ |
| Эквивалентно            | `eq <arg> <arg> [<arg>, ...]`  | {% raw %}`{{ eq "hello" "hello" }}`{% endraw %}  |
| Не эквивалентно         | `neq <arg> <arg> [<arg>, ...]` | {% raw %}`{{ neq "hello" "world" }}`{% endraw %} |
| Меньше                  | `lt <arg> <arg>`               | {% raw %}`{{ lt 1 2 }}`{% endraw %}              |
| Больше                  | `gt <arg> <arg>`               | {% raw %}`{{ gt 2 1 }}`{% endraw %}              |
| Меньше или эквивалентно | `le <arg> <arg>`               | {% raw %}`{{ le 1 2 }}`{% endraw %}              |
| Больше или эквивалентно | `ge <arg> <arg>`               | {% raw %}`{{ ge 2 1 }}`{% endraw %}              |

Пример комбинирования:

{% raw %}

```
{{ and (eq true true) (neq true false) (not (empty "hello")) }}
```

{% endraw %}

## Ветвления

Ветвления `if/else` позволяют выполнять шаблонизацию только при выполнении/невыполнении определенных условий. Пример:

{% raw %}

```
{{ if $.Values.app.enabled }}
# ...
{{ end }}
```

{% endraw %}

Условие считается *невыполненным*, если результатом его вычисления является:

* логическое `false`;

* число `0`;

* пустая строка `""`;

* пустой список `[]`;

* пустой словарь `{}`;

* нуль: `nil`.

В остальных случаях условие считается выполненным. Условием могут быть данные, переменная, функция или конвейер.

Полный пример:

{% raw %}

```
{{ if eq $appName "backend" }}
app: mybackend
{{ else if eq $appName "frontend" }}
app: myfrontend
{{ else }}
app: {{ $appName }}
{{ end }}
```

{% endraw %}

Простые ветвления можно реализовывать не только с `if/else`, но и с функцией `ternary`. Например, следующее выражение с `ternary`:

{% raw %}

```
{{ ternary "mybackend" $appName (eq $appName "backend") }}
```

{% endraw %}

... аналогично приведенной ниже конструкции `if/else`:

{% raw %}

```
{{ if eq $appName "backend" }}
app: mybackend
{{ else }}
app: {{ $appName }}
{{ end }}
```

{% endraw %}

## Циклы

### Циклы по спискам

Циклы `range` позволяют перебирать элементы списка и выполнять нужную шаблонизацию на каждой итерации:

{% raw %}

```
{{ range $urls }}
{{ . }}
{{ end }}
```

{% endraw %}

Результат:

```
https://example.org
https://sub.example.org
```

Относительный контекст `.` всегда указывает на элемент списка, соответствующий текущей итерации, хотя указатель можно сохранить и в произвольную переменную:

{% raw %}

```
{{ range $elem := $urls }}
{{ $elem }}
{{ end }}
```

{% endraw %}

Результат будет таким же:

```
https://example.org
https://sub.example.org
```

Получить индекс элемента в списке можно следующим образом:

{% raw %}

```
{{ range $i, $elem := $urls }}
{{ $elem }} имеет индекс {{ $i }}
{{ end }}
```

{% endraw %}

Результат:

```
https://example.org имеет индекс 0
https://sub.example.org имеет индекс 1
```

### Циклы по словарям

Циклы `range` позволяют перебирать ключи и значения словарей и выполнять нужную шаблонизацию на каждой итерации:

```yaml
# values.yaml:
apps:
  backend:
    image: openjdk
  frontend:
    image: node
```

{% raw %}

```
# templates/app.yaml:
{{ range $.Values.apps }}
{{ .image }}
{{ end }}
```

{% endraw %}

Результат:

```
openjdk
node
```

Относительный контекст `.` всегда указывает на значение элемента словаря, соответствующего текущей итерации, при этом указатель можно сохранить и в произвольную переменную:

{% raw %}

```
{{ range $app := $.Values.apps }}
{{ $app.image }}
{{ end }}
```

{% endraw %}

Результат будет таким же:

```
openjdk
node
```

Получить ключ элемента словаря можно так:

{% raw %}

```
{{ range $appName, $app := $.Values.apps }}
{{ $appName }}: {{ $app.image }}
{{ end }}
```

{% endraw %}

Результат:

```yaml
backend: openjdk
frontend: node
```

### Контроль выполнения цикла

Специальное действие `continue` позволяет пропустить текущую итерацию цикла. В качестве примера пропустим итерацию для элемента `https://example.org`:

{% raw %}

```
{{ range $url := $urls }}
{{ if eq $url "https://example.org" }}{{ continue }}{{ end }}
{{ $url }}
{{ end }}
```

{% endraw %}

Специальное действие `break` позволяет не только пропустить текущую итерацию, но и прервать весь цикл:

{% raw %}

```
{{ range $url := $urls }}
{{ if eq $url "https://example.org" }}{{ break }}{{ end }}
{{ $url }}
{{ end }}
```

{% endraw %}

## Контекст

### Корневой контекст ($)

Корневой контекст — словарь, на который ссылается переменная `$`. Через него доступны values и некоторые специальные объекты. Корневой контекст имеет глобальную видимость в пределах файла-шаблона (исключение — блок `define` и некоторые функции).

Пример использования:

{% raw %}

```
{{ $.Values.mykey }}
```

{% endraw %}

Результат:

```
myvalue
```

К корневому контексту можно добавлять произвольные ключи/значения, которые также станут доступны из любого места файла-шаблона:

{% raw %}

```
{{ $_ := set $ "mykey" "myvalue"}}
{{ $.mykey }}
```

{% endraw %}

Результат:

```
myvalue
```

Корневой контекст остаётся неизменным даже в блоках, изменяющих относительный контекст (исключение — `define`):

{% raw %}

```
{{ with $.Values.backend }}
- command: {{ .command }}
  image: {{ $.Values.werf.image.backend }}
{{ end }}
```

{% endraw %}

Некоторые функции вроде `tpl` или `include` могут терять корневой контекст. Для сохранения доступа к корневому контексту многим из них можно передать корневой контекст аргументом:

{% raw %}

```
{{ tpl "{{ .Values.mykey }}" $ }}
```

{% endraw %}

Результат:

```
myvalue
```

### Относительный контекст (.)

Относительный контекст — данные любого типа, на которые ссылается переменная `.`. По умолчанию относительный контекст указывает на корневой контекст.

Некоторые блоки и функции могут менять относительный контекст. В примере ниже в первой строке относительный контекст указывает на корневой контекст `$`, а во второй строке — уже на `$.Values.containers`:

{% raw %}

```
{{ range .Values.containers }}
{{ . }}
{{ end }}
```

{% endraw %}

Для смены относительного контекста можно использовать блок `with`:

{% raw %}

```
{{ with $.Values.app }}
image: {{ .image }}
{{ end }}
```

{% endraw %}

## Переиспользование шаблонов

### Именованные шаблоны

Для переиспользования шаблонизации объявите *именованные шаблоны* в блоках `define` в файлах `templates/_*.tpl`:

{% raw %}

```
# templates/_helpers.tpl:
{{ define "labels" }}
app: myapp
team: alpha
{{ end }}
```

{% endraw %}

Далее подставляйте именованные шаблоны в файлы `templates/*.(yaml|tpl)` функцией `include`:

{% raw %}

```
# templates/deployment.yaml:
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  selector:
    matchLabels: {{ include "labels" nil | nindent 6 }}
  template:
    metadata:
      labels: {{ include "labels" nil | nindent 8 }}
```

{% endraw %}

Результат:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  selector:
    matchLabels:
      app: myapp
      team: alpha
  template:
    metadata:
      labels:
        app: myapp
        team: alpha
```

Имя именованного шаблона для функции `include` может быть динамическим:

{% raw %}

```
{{ include (printf "%s.labels" $prefix) nil }}
```

{% endraw %}

**Именованные шаблоны обладают глобальной видимостью** — единожды объявленный в родительском или любом дочернем чарте именованный шаблон становится доступен сразу во всех чартах — и в родительском, и в дочерних. Убедитесь, что в подключенных родительском и дочерних чартах нет именованных шаблонов с одинаковыми именами.

### Параметризация именованных шаблонов

Функция `include`, подставляющая именованные шаблоны, принимает один произвольный аргумент. Этот аргумент можно использовать для параметризации именованного шаблона, где этот аргумент станет относительным контекстом `.`:

{% raw %}

```
{{ include "labels" "myapp" }}
```

{% endraw %}

{% raw %}

```
{{ define "labels" }}
app: {{ . }}
{{ end }}
```

{% endraw %}

Результат:

```yaml
app: myapp
```

Для передачи сразу нескольких аргументов используйте список с несколькими аргументами:

{% raw %}

```
{{ include "labels" (list "myapp" "alpha") }}
```

{% endraw %}

{% raw %}

```
{{ define "labels" }}
app: {{ index . 0 }}
team: {{ index . 1 }}
{{ end }}
```

{% endraw %}

... или словарь:

{% raw %}

```
{{ include "labels" (dict "app" "myapp" "team" "alpha") }}
```

{% endraw %}

{% raw %}

```
{{ define "labels" }}
app: {{ .app }}
team: {{ .team }}
{{ end }}
```

{% endraw %}

Необязательные позиционные аргументы можно реализовать так:

{% raw %}

```
{{ include "labels" (list "myapp") }}
{{ include "labels" (list "myapp" "alpha") }}
```

{% endraw %}

{% raw %}

```
{{ define "labels" }}
app: {{ index . 0 }}
{{ if gt (len .) 1 }}
team: {{ index . 1 }}
{{ end }}
{{ end }}
```

{% endraw %}

А необязательные непозиционные аргументы — так:

{% raw %}

```
{{ include "labels" (dict "app" "myapp") }}
{{ include "labels" (dict "team" "alpha" "app" "myapp") }}
```

{% endraw %}

{% raw %}

```
{{ define "labels" }}
app: {{ .app }}
{{ if hasKey . "team" }}
team: {{ .team }}
{{ end }}
{{ end }}
```

{% endraw %}

Именованному шаблону, не требующему параметризации, просто передайте `nil`:

{% raw %}

```
{{ include "labels" nil }}
```

{% endraw %}

### Результат выполнения include

Функция `include`, подставляющая именованный шаблон, **всегда возвращает только текст**. Для возврата структурированных данных нужно *десериализовать* результат выполнения `include` с помощью функции `fromYaml`:

{% raw %}

```
{{ define "commonLabels" }}
app: myapp
{{ end }}
```

{% endraw %}

{% raw %}

```
{{ $labels := include "commonLabels" nil | fromYaml }}
{{ $labels.app }}
```

{% endraw %}

Результат:

```
myapp
```

> Обратите внимание, что `fromYaml` не работает для списков. Специально для них (и только для них) предназначена функция `fromYamlArray`.

Для явной сериализации данных можно воспользоваться функциями `toYaml` и `toJson`, для десериализации — функциями `fromYaml/fromYamlArray` и `fromJson/fromJsonArray`.

### Контекст именованных шаблонов

Объявленные в `templates/_*.tpl` именованные шаблоны теряют доступ к корневому и относительному контекстам файла, в который они включаются функцией `include`. Исправить это можно, передав корневой и/или относительный контекст в виде аргументов `include`:

{% raw %}

```
{{ include "labels" $ }}
{{ include "labels" . }}
{{ include "labels" (list $ .) }}
{{ include "labels" (list $ . "myapp") }}
```

{% endraw %}

### include в include

В блоках `define` тоже можно использовать функцию `include` для включения именованных шаблонов:

{% raw %}

```
{{ define "doSomething" }}
{{ include "doSomethingElse" . }}
{{ end }}
```

{% endraw %}

Через `include` можно вызвать даже тот именованный шаблон, из которого и происходит вызов, т. е. вызвать его рекурсивно:

{% raw %}

```
{{ define "doRecursively" }}
{{ if ... }}
{{ include "doRecursively" . }}
{{ end }}
{{ end }}
```

{% endraw %}

## Шаблонизация с tpl

Функция `tpl` позволяет выполнить шаблонизацию любой строки и тут же получить результат. Она принимает один аргумент, который должен быть корневым контекстом.

Пример шаблонизации values:

{% raw %}

```yaml
# values.yaml:
appName: "myapp"
deploymentName: "{{ .Values.appName }}-deployment"
```

{% endraw %}

{% raw %}

```
# templates/app.yaml:
{{ tpl $.Values.deploymentName $ }}
```

{% endraw %}

Результат:

```
myapp-deployment
```

Пример шаблонизации произвольных файлов, которые сами по себе не поддерживают Helm-шаблонизацию:

{% raw %}

```
{{ tpl ($.Files.Get "nginx.conf") $ }}
```

{% endraw %}

Для передачи дополнительных аргументов в функцию `tpl` можно добавить аргументы как новые ключи корневого контекста:

{% raw %}

```
{{ $_ := set $ "myarg" "myvalue"}}
{{ tpl "{{ $.myarg }}" $ }}
```

{% endraw %}

## Контроль отступов

Используйте функцию `nindent` для выставления отступов:

{% raw %}

```
       containers: {{ .Values.app.containers | nindent 6 }}
```

{% endraw %}

Результат:

```yaml
      containers:
      - name: backend
        image: openjdk
```

Пример комбинации с другими данными:

{% raw %}

```
       containers:
       {{ .Values.app.containers | nindent 6 }}
       - name: frontend
         image: node
```

{% endraw %}

Результат:

```yaml
      containers:
      - name: backend
        image: openjdk
      - name: frontend
        image: node
```

Используйте `-` после {% raw %}`{{`{% endraw %} и/или до {% raw %}`}}`{% endraw %} для удаления лишних пробелов до и/или после результата выполнения действия, например:

{% raw %}

```
  {{- "hello" -}} {{ "world" }}
```

{% endraw %}

Результат:

```
helloworld
```

## Комментарии

Поддерживаются два типа комментариев — комментарии шаблонизации {% raw %}`{{ /* */ }}`{% endraw %} и комментарии манифестов `#`.

### Комментарии шаблонизации

Комментарии шаблонизации скрываются при формировании манифестов:

{% raw %}

```
{{ /* Этот комментарий пропадёт */ }}
app: myApp
```

{% endraw %}

Комментарии могут быть многострочными:

{% raw %}

```
{{ /*
Hello
World
/* }}
```

{% endraw %}

Шаблоны в них игнорируются:

{% raw %}

```
{{ /*
{{ print "Эта шаблонизация игнорируется" }}
/* }}
```

{% endraw %}

### Комментарии манифестов

Комментарии манифестов сохраняются при формировании манифестов:

```yaml
# Этот комментарий сохранится
app: myApp
```

Комментарии могут быть только однострочнными:

```yaml
# Для многострочных комментариев используйте
# несколько однострочных комментариев подряд
```

Шаблоны в них выполняются:

{% raw %}

```
# {{ print "Эта шаблонизация выполняется" }}
```

{% endraw %}

## Отладка

Используйте `werf render`, чтобы полностью сформировать и отобразить конечные Kubernetes-манифесты. Укажите опцию `--debug`, чтобы увидеть манифесты, даже если они не являются корректным YAML.

Отобразить содержимое переменной:

{% raw %}

```
output: {{ $appName | toYaml }}
```

{% endraw %}

Отобразить содержимое переменной-списка или словаря:

{% raw %}

```
output: {{ $dictOrList | toYaml | nindent 2 }}
```

{% endraw %}

Отобразить тип данных у переменной:

{% raw %}

```
output: {{ kindOf $myvar }}
```

{% endraw %}

Отобразить произвольную строку, остановив дальнейшее формирование шаблонов:

{% raw %}

```
{{ fail (printf "Тип данных: %s" (kindOf $myvar)) }}
```

{% endraw %}
