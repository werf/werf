---
title: Запуск инструкций сборки
permalink: usage/build/stapel/instructions.html
directive_summary: shell_and_ansible
---

## Пользовательские стадии

***Пользовательские стадии*** — это стадии со сборочными инструкциями из конфигурации. Другими словами — это стадии, конфигурируемые пользователем (существуют также служебные стадии, которые пользователь конфигурировать не может). В настоящее время существует два вида сборочных инструкций: _shell_ и _ansible_.

werf поддерживает четыре _пользовательские стадии_, которые выполняются последовательно в следующем порядке: _beforeInstall_, _install_, _beforeSetup_ и _setup_. В результате выполнения инструкций пользовательской стадии создается один Docker-слой. Т.е. по одному слою на каждую стадию вне зависимости от количества инструкций.

## Использование пользовательских стадий

werf позволяет определять до четырех _пользовательских стадий_ с инструкциями сборки. На содержание самих инструкций сборки werf не накладывает каких-либо ограничений, т.е. вы можете указывать все те же инструкции, которые указывали в Dockerfile в директиве `RUN`. Однако важно не просто перенести инструкции из Dockerfile, а правильно разбить их на _пользовательские стадии_. Исходя из опыта работы с реальными приложениями, мы пришли к заключению, что сборка большинства приложений проходит следующие этапы:

- установка системных пакетов;
- установка системных зависимостей;
- установка зависимостей приложения;
- настройка системных пакетов;
- настройка приложения.

Какая может быть наилучшая стратегия выполнения этих этапов?

Первая мысль — лучше выполнять эти этапы последовательно, кэшируя промежуточные результаты, а с другой стороны – разбивать инструкции по файловым зависимостям.

Подход с _пользовательскими стадиями_ предлагает следующую стратегию:
- использовать стадию _beforeInstall_ для инсталляции системных пакетов;
- использовать стадию _install_ для инсталляции системных зависимостей и зависимостей приложения;
- использовать стадию _beforeSetup_ для настройки системных параметров и установки приложения;
- использовать стадию _setup_ для настройки приложения.

<div class="details">
<a href="javascript:void(0)" class="details__summary">Как работает сборка стадий stapel</a>
<div class="details__content" markdown="1">

При сборке стадии предполагается, что инструкции стадии будут запускаться в контейнере, основанном на предыдущей собранной стадии или [на базовом образе]({{ "usage/build/stapel/base.html#from-fromlatest" | true_relative_url }}). Такой контейнер будет упоминаться далее как **сборочный контейнер**.

Перед запуском _сборочного контейнера_ werf подготавливает набор инструкций, который зависит от типа стадии и содержит как служебные команды werf, так и пользовательские, указанные в конфигурации `werf.yaml`. Например, среди служебных команд может быть добавление файлов, наложение патчей, запуск ansible заданий и т.п.

Stapel-сборщик использует свой набор инструментов и библиотек и никак не зависит от базового образа. При запуске _сборочного контейнера_ werf монтирует всё необходимое из специального служебного образа `registry.werf.io/werf/stapel`.

В _сборочный контейнер_ [пробрасывается сокет SSH-агента с хоста](#как-использовать-ssh-агент-в-сборочных-инструкциях), а также могут использоваться [пользовательские маунты]({{ "usage/build/stapel/mounts.html" | true_relative_url }}).

Также стоит отметить, что при сборке werf игнорирует некоторые параметры манифеста базового образа, заменяя их определёнными значениями:
- `--user=0:0`;
- `--workdir=/`;
- `--entrypoint=/.werf/stapel/embedded/bin/bash`.

В итоге запуск _сборочного контейнера_ произвольной стадии можно представить следующим образом:
```shell
docker run \
  --volume=/tmp/ssh-ln8yCMlFLZob/agent.17554:/.werf/tmp/ssh-auth-sock \
  --volumes-from=stapel_0.6.1 \
  --env=SSH_AUTH_SOCK=/.werf/tmp/ssh-auth-sock \
  --user=0:0 \
  --workdir=/ \
  --entrypoint=/.werf/stapel/embedded/bin/bash \
  sha256:d6e46aa2470df1d32034c6707c8041158b652f38d2a9ae3d7ad7e7532d22ebe0 \
  -ec eval $(echo c2V0IC14 | /.werf/stapel/embedded/bin/base64 --decode)
```

</div>
</div>

### beforeInstall

```yaml
shell:
  beforeInstall:
    - apt update -q
    - apt install -y curl mysql-client libmysqlclient-dev g++ build-essential libcurl4
  beforeInstallCacheVersion: "1"
```

Данная стадия предназначена для выполнения инструкций перед установкой приложения.
Этот этап предназначен для системных приложений, которые редко изменяются, но требуют много времени для установки.
Примером таких приложений могут быть языковые пакеты или инструменты сборки, такие как Composer, Java, Gradle и т.д.
Также сюда можно добавлять инструкции настройки системы, которые редко изменяются.
Например, языковые настройки, настройки часового пояса, добавление пользователей и групп.

Поскольку эти компоненты меняются редко, они будут кэшироваться в рамках стадии _beforeInstall_ на длительный период.

`beforeInstallCacheVersion: <string>` — опциональная директива, которая позволяет инвалидировать сборочный кеш данной стадии детерминированным способом через Git.

### install

```yaml
shell:
  install:
    - bundle install
    - npm ci
  installCacheVersion: "1"
```

Данная стадия предназначена для установки приложения и его зависимостей, а также выполнения базовых настроек.

На данной стадии появляется доступ к исходному коду используемых Git-репозиториев (директива `git`) и появляется возможность установки зависимостей на основе manifest-файлов с использованием таких инструментов, как Composer, Gradle, npm и т.д. Поскольку сборка стадии зависит от manifest-файла, для достижения наилучшего результата важно добавить зависимость от изменений в manifest-файлах репозитория для этой стадии. Например, если в проекте используется Composer, то добавление файла `composer.lock` в зависимости стадии _beforeInstall_ позволит пересобирать стадию при изменении файла `composer.lock`.

`installCacheVersion: <string>` — опциональная директива, которая позволяет инвалидировать сборочный кеш данной стадии детерминированным способом через Git.

### beforeSetup

```yaml
shell:
  beforeSetup:
    - rake assets:precompile
  beforeSetupCacheVersion: "1"
```

Данная стадия предназначена для подготовки приложения перед настройкой.

На данной стадии рекомендуется выполнять разного рода компиляцию и обработку.
Например, компиляция jar-файлов, бинарных файлов, файлов библиотек, создание ассетов web-приложений, минификация, шифрование и т.п.
Перечисленные операции, как правило, зависят от изменений в исходном коде, и на данной стадии также важно определить достаточные зависимости от изменений в репозитории. Логично, что стадия будет зависеть от большего числа файлов в репозитории, чем на предыдущей стадии, и, соответственно, ее пересборка будет выполняться чаще.

При правильно определенных зависимостях изменения в коде приложения должны приводить к пересборке стадии _beforeSetup_, а изменение manifest-файла к стадии _install_ и последующих стадий.

`beforeSetupCacheVersion: <string>` — опциональная директива, которая позволяет инвалидировать сборочный кеш данной стадии детерминированным способом через Git.

### setup

```yaml
shell:
  setup:
    - npm run build
  setupCacheVersion: "1"
```

Данная стадия предназначена для настройки приложения.

Обычно на данной стадии выполняется копирование файлов конфигурации (например, в каталог `/etc`), создание файлов текущей версии приложения и т.д.
Такого рода операции не должны быть затратными по времени, т.к. они, скорее всего, будут выполняться в большинстве сборок.

`setupCacheVersion: <string>` — опциональная директива, которая позволяет инвалидировать сборочный кеш данной стадии детерминированным способом через Git.

### Пользовательская стратегия

Несмотря на изложенную четкую стратегию шаблона _пользовательских стадий_ и функции каждой стадии, по сути для пользователя нет никаких ограничений. Предложенное использование стадий является лишь рекомендацией, которая основана на нашем опыте с реальными приложениями. Вы можете использовать только одну пользовательскую стадию, либо определить свою стратегию группировки инструкций, чтобы получить преимущества кэширования и зависимостей от изменений в Git-репозиториях с учетом особенностей сборки вашего приложения.

## Синтаксис

Пользовательские стадии и инструкции сборки определяются внутри двух взаимоисключающих директив — `shell` и `ansible`. Каждый образ может собираться либо используя сборочные инструкции ***shell***, либо задачи ***ansible***, описанные в соответствующих директивах.

В каждой директиве можно описывать инструкции для _пользовательских стадий_, соответственно:
- `beforeInstall`;
- `install`;
- `beforeSetup`;
- `setup`.

Также можно указывать директивы версий кэша (***cacheVersion***), которые по сути являются частью дайджеста каждой _пользовательской стадии_. Более подробно [в соответствующем разделе](#зависимость-от-значения-cacheversion).

## Shell

Синтаксис описания _пользовательских стадий_ при использовании сборочных инструкций _shell_:

```yaml
shell:
  beforeInstall:
  - <bash_command 1>
  - <bash_command 2>
  # ...
  - <bash_command N>
  install:
  - bash command
  # ...
  beforeSetup:
  - bash command
  # ...
  setup:
  - bash command
  # ...
  cacheVersion: <version>
  beforeInstallCacheVersion: <version>
  installCacheVersion: <version>
  beforeSetupCacheVersion: <version>
  setupCacheVersion: <version>
```

Сборочные инструкции _shell_ — это массив Bash-команд для соответствующей _пользовательской стадии_. Все команды одной стадии выполняются как одна инструкция `RUN` в Dockerfile, т.е. в результате создается один слой на каждую _пользовательскую стадию_.

werf при сборке использует собственный исполняемый файл `bash`, и вам не нужно отдельно добавлять его в образ (или [базовый образ]({{ "usage/build/stapel/base.html" | true_relative_url }})) при сборке.

Пример описания стадии _beforeInstall_, содержащей команды `apt-get update` и `apt-get install`:

```yaml
beforeInstall:
- apt-get update
- apt-get install -y build-essential g++ libcurl4
```

Исполняемый файл `bash` находится внутри Docker-тома _stapel_. Подробнее про эту концепцию можно узнать [в этой статье](https://habr.com/company/flant/blog/352432/) (упоминаемый в статье `dappdeps` был переименован в `stapel`, но принцип сохранился)

## Ansible

Синтаксис описания _пользовательских стадий_ при использовании сборочных инструкций _ansible_:

```yaml
ansible:
  beforeInstall:
  - <ansible task 1>
  - <ansible task 2>
  # ...
  - <ansible task N>
  install:
  - ansible task
  # ...
  beforeSetup:
  - ansible task
  # ...
  setup:
  - ansible task
  # ...
  cacheVersion: <version>
  beforeInstallCacheVersion: <version>
  installCacheVersion: <version>
  beforeSetupCacheVersion: <version>
  setupCacheVersion: <version>
```

> **Примечание:** синтаксис ansible не доступен для использования при использовании сборочного бекэнда Buildah.

### Ansible config и stage playbook

Сборочные инструкции _ansible_ — это массив Ansible-заданий для соответствующей _пользовательской стадии_.

Сгенерированный `ansible.cfg` содержит настройки для Ansible:
- использование локального транспорта (transport = local);
- подключение callback плагина werf для удобного логирования (stdout_callback = werf);
- включение режима цвета (force_color = 1);
- установка использования `sudo` для повышения привилегий (чтобы не было необходимости использовать `become` в Ansible-заданиях).

Сгенерированный `playbook.yml` — playbook, содержащий все задания соответствующей _пользовательской стадии_. Пример `werf.yaml` с описанием стадии _install_:

```yaml
ansible:
  install:
  - debug: msg='Start install'
  - file: path=/etc mode=0777
  - copy:
      src: /bin/sh
      dest: /bin/sh.orig
  - apk:
      name: curl
      update_cache: yes
  # ...
```

Исполняемые файлы и библиотеки `ansible` и `python` находятся внутри Docker-тома _stapel_. Подробнее про эту концепцию можно узнать [в этой статье](https://habr.com/company/flant/blog/352432/) (упоминаемый в статье `dappdeps` был переименован в `stapel`, но принцип сохранился)

### Поддерживаемые модули

Одной из концепций, которую использует werf, является идемпотентность сборки. Это значит, что если «ничего не изменилось», то werf при повторном и последующих запусках сборки должен создавать бинарно идентичные образы. В werf эта задача решается с помощью подсчета _дайджестов стадий_.

Многие модули Ansible не являются идемпотентными, т.е. они могут давать разный результат запусков при неизменных входных параметрах. Это, конечно, не дает возможность корректно высчитывать _дайджест_ стадии, чтобы определять реальную необходимость её пересборки из-за изменений. Это привело к тому, что список поддерживаемых модулей был ограничен.

На текущий момент, список поддерживаемых модулей Ansible следующий:

- Command modules: command, shell, raw, script.
- Crypto modules: openssl_certificate и другие.
- Files modules: acl, archive, copy, stat, tempfile и другие.
- Net Tools Modules: get_url, slurp, uri.
- Packaging/Language modules: composer, gem, npm, pip и другие.
- Packaging/OS modules: apt, apk, yum и другие.
- System modules: user, group, getent, locale_gen, timezone, cron и другие.
- Utilities modules: assert, debug, set_fact, wait_for.

При указании в _конфигурации сборки_ модуля, отсутствующего в приведенном списке, сборка прервется с ошибкой. Не стесняйтесь [сообщать](https://github.com/werf/werf/issues/new) нам, если вы считаете что какой-либо модуль должен быть включен в список поддерживаемых.

### Копирование файлов

Предпочтительный способ копирования файлов в образ — использование [_git mapping_]({{ "usage/build/stapel/git.html" | true_relative_url }}).
werf не может определять изменения в копируемых файлах при использовании модуля `copy`.
Единственный вариант копирования внешнего файла в образ на текущий момент — использовать метод `.Files.Get` Go-шаблона.
Данный метод возвращает содержимое файла как строку, что дает возможность использовать содержимое как часть _пользовательской стадии_.
Таким образом, при изменении содержимого файла изменится дайджест соответствующей стадии, что приведет к пересборке всей стадии.

Пример копирования файла `nginx.conf` в образ:

{% raw %}
```yaml
ansible:
  install:
  - copy:
      content: |
{{ .Files.Get "/conf/etc/nginx.conf" | indent 8}}
      dest: /etc/nginx/nginx.conf
```
{% endraw %}

В результате получится подобный `playbook.yml`:

```yaml
- hosts: all
  gather_facts: no
  tasks:
    install:
    - copy:
        content: |
          http {
            sendfile on;
            tcp_nopush on;
            tcp_nodelay on;
            # ...
```

### Шаблоны Jinja

В Ansible реализована поддержка шаблонов [Jinja](https://docs.ansible.com/ansible/2.5/user_guide/playbooks_templating.html) в playbook'ах. Однако у Go-шаблонов и Jinja-шаблонов одинаковый разделитель: {% raw %}`{{` и `}}`{% endraw %}. Чтобы использовать Jinja-шаблоны в конфигурации werf, их нужно экранировать. Для этого есть два варианта: экранировать только {% raw %}`{{`{% endraw %}, либо экранировать все выражение шаблона Jinja.

Например, у вас есть следующая задача Ansible:

{% raw %}
```yaml
- copy:
    src: {{item}}
    dest: /etc/nginx
    with_files:
    - /app/conf/etc/nginx.conf
    - /app/conf/etc/server.conf
```
{% endraw %}

{% raw %}
Тогда, выражение Jinja-шаблона `{{item}}` должно быть экранировано:
{% endraw %}

{% raw %}
```yaml
# Экранируем только {{.
src: {{"{{"}} item }}
```
либо
```yaml
# Экранируем все выражение.
src: {{`{{item}}`}}
```
{% endraw %}

### Проблемы с Ansible

- Live-вывод реализован только для модулей `raw` и `command`. Остальные модули отображают вывод каналов `stdout` и `stderr` после выполнения, что приводит к задержкам и скачкообразному выводу.
- Модуль `apt` подвисает на некоторых версиях Debian и Ubuntu. Проявляется также на наследуемых образах ([issue #645](https://github.com/werf/werf/issues/645)).

## Переменные окружения сборочного контейнера

Вы можете использовать сервисные переменные окружения, которые доступны в сборочном контейнере, и, соответственно, доступны в инструкциях сборки. Их использование не приведёт к изменению инструкций сборки и вытекающим из этого пересборкам, даже если сами значения сервисных переменных меняются.

Доступны следующие переменные:
- `WERF_COMMIT_HASH`. Пример значения: `cda9d17265d174c62424e8f7b5e5640bf749c565`.
- `WERF_COMMIT_TIME_HUMAN`. Пример значения: `2022-01-24 17:26:19 +0300 +0300`.
- `WERF_COMMIT_TIME_UNIX`. Пример значения: `1643034379`.

Пример использования:
{% raw %}
```yaml
shell:
  install:
  - echo "Commands on the Install stage for $WERF_COMMIT_HASH"
```
{% endraw %}

В примере выше хэш текущего коммита будет подставлен в команду `echo ...`, но произойдет это в самый последний момент — на этапе выполнения инструкций shell'ом. Таким образом пересборок слоя install на каждом коммите происходить не будет.

## Зависимости пользовательских стадий

Одна из особенностей werf — возможность определять зависимости, при которых происходит пересборка _стадии_. Сборка _стадий_ выполняется последовательно, одна за другой, и для каждой _стадии_ высчитывается _дайджест стадии_. У _дайджестов_ есть ряд зависимостей, при изменении которых _дайджест стадии_ меняется, что служит для werf сигналом для пересборки стадии с измененным _дайджестом_. Поскольку каждая следующая _стадия_ имеет зависимость, в том числе и от предыдущей _стадии_ согласно _конвейеру стадий_, при изменении дайджеста какой-либо _стадии_ произойдет пересборка и _стадии_ с изменённым дайджестом и всех последующих _стадий_.

_Дайджест пользовательских стадий_ и, соответственно, пересборка _пользовательских стадий_ зависят от изменений:
- в инструкциях сборки;
- в директивах семейства _cacheVersion_;
- в Git-репозитории (или Git-репозиториях);
- в файлах, импортируемых [из артефактов]({{ "usage/build/stapel/imports.html#что-такое-артефакты" | true_relative_url }}).

Первые три описанных варианта зависимостей рассматриваются подробно далее.

## Зависимость от изменений в инструкциях сборки

_Дайджест пользовательской стадии_ зависит от итогового текста инструкций, т.е. после применения шаблонизатора. Любые изменения в тексте инструкций с учетом применения шаблонизатора Go или Jinja (в случае Ansible) в _пользовательской стадии_ приводят к пересборке _стадии_. Например, вы используете следующие _shell-инструкции_:

```yaml
shell:
  beforeInstall:
  - echo "Commands on the Before Install stage"
  install:
  - echo "Commands on the Install stage"
  beforeSetup:
  - echo "Commands on the Before Setup stage"
  setup:
  - echo "Commands on the Setup stage"
```

При первой сборке этого образа будут выполнены инструкции всех четырех _пользовательских стадий_.
В данной конфигурации нет _git mapping_, так что последующие сборки не приведут к повторному выполнению инструкций — _дайджест пользовательских стадий_ не изменилась, сборочный кэш содержит актуальную информацию.

Изменим инструкцию сборки для стадии _install_:

```yaml
shell:
  beforeInstall:
  - echo "Commands on the Before Install stage"
  install:
  - echo "Commands on the Install stage"
  - echo "Installing ..."
  beforeSetup:
  - echo "Commands on the Before Setup stage"
  setup:
  - echo "Commands on the Setup stage"
```

Дайджест стадии _install_ изменилась, и запуск werf для сборки приведет к выполнению всех инструкций стадии _install_ и инструкций последующих _стадий_, т.е. _beforeSetup_ и _setup_.

Дайджест стадии может меняться также из-за использования переменных окружения и Go-шаблонов.
Если не уделять этому достаточное внимание при написании конфигурации, можно столкнуться с неожиданными пересборками стадий. Например:

{% raw %}
```yaml
shell:
  beforeInstall:
  - echo "Commands on the Before Install stage for {{ env "CI_COMMIT_SHA” }}"
  install:
  - echo "Commands on the Install stage"
  # ...
```
{% endraw %}

Первая сборка высчитает дайджест стадии _beforeInstall_ на основе команды (хэш коммита, конечно, будет другой):
```shell
echo "Commands on the Before Install stage for 0a8463e2ed7e7f1aa015f55a8e8730752206311b"
```

После очередного коммита при сборке дайджест стадии _beforeInstall_ уже будет другой (с другим хешем коммита):

```shell
echo "Commands on the Before Install stage for 36e907f8b6a639bd99b4ea812dae7a290e84df27"
```

Соответственно, используя переменную `CI_COMMIT_SHA` дайджест стадии _beforeInstall_ будет меняться после каждого коммита, что будет приводить к пересборке.

## Зависимость от изменений в Git-репозитории

<a class="google-drawings" href="{{ "images/configuration/assembly_instructions3.svg" | true_relative_url }}" data-featherlight="image">
    <img src="{{ "images/configuration/assembly_instructions3.svg" | true_relative_url }}" alt="Зависимость от изменений в git-репозитории">
  </a>

Как описывалось в статье [про _git mapping_]({{ "usage/build/stapel/git.html" | true_relative_url }}), существуют специальные стадии _gitArchive_ и _gitLatestPatch_.
Стадия _gitArchive_ выполняется после пользовательской стадии _beforeInstall_, а стадия _gitLatestPatch_ после пользовательской стадии _setup_, если в локальном Git-репозитории есть изменения.
Таким образом, чтобы выполнить сборку с последней версией исходного кода, можно пересобрать стадию _beforeInstall_, изменив значение директивы _cacheVersion_ либо изменив сами инструкции стадии _beforeInstall_.

Пользовательские стадии _install_, _beforeSetup_ и _setup_ также могут зависеть от изменений в Git-репозитории. В этом случае (если такая зависимость определена) Git-патч применяется перед выполнением инструкций _пользовательской стадии_, чтобы сборочные инструкции выполнялись с актуальной версией кода приложения.

> Во время процесса сборки исходный код обновляется **только в рамках одной стадии**, последующие стадии, зависящие последовательно друг от друга, будут использовать также обновленную версию файлов.
> Первая сборка добавляет файлы из Git-репозитория на стадии _gitArchive_. Все последующие сборки обновляют файлы на стадии _gitCache_, _gitLatestPatch_ или на одной из следующих пользовательских стадий: _install_, _beforeSetup_, _setup_.
<br />
<br />
Пример этого этапа (фаза подсчета дайджестов, _calculating digests_):
![git files actualized on specific stage]({{ "images/build/git_mapping_updated_on_stage.png" | true_relative_url }})

Зависимость _пользовательской стадии_ от изменений в Git-репозитории указывается с помощью параметра `git.stageDependencies`. Синтаксис:

```yaml
git:
- ...
  stageDependencies:
    install:
    - <mask 1>
    # ...
    - <mask N>
    beforeSetup:
    - <mask>
    # ...
    setup:
    - <mask>
```

У параметра `git.stageDependencies` возможно указывать 3 ключа: `install`, `beforeSetup` и `setup`.
Значение каждого ключа — массив масок файлов, относящихся к соответствующей стадии. Соответствующая _пользовательская стадия_ пересобирается, если в Git-репозитории происходят изменения подпадающие под указанную маску.

Для каждой _пользовательской стадии_ werf создает список подпадающих под маску файлов и вычисляет контрольную сумму каждого файла с учетом его аттрибутов и содержимого. Эти контрольные суммы являются частью _дайджеста стадии_, поэтому любое изменение файлов в репозитории, подпадающее под маску, приводит к изменениям _дайджеста стадии_. К этим изменениям относятся: изменение атрибутов файла, изменение содержимого файла, добавление или удаление подпадающего под маску файла и т.п.

При применении маски, указанной в `git.stageDependencies`, учитываются значения параметров `git.includePaths` и `git.excludePaths` (смотри подробнее про них [в соответствующем разделе]({{ "usage/build/stapel/git.html#использование-фильтров" | true_relative_url }})). werf считает подпадающими под маску только файлы, удовлетворяющие фильтру `includePaths` и подпадающие под маску `stageDependencies`. Аналогично werf считает подпадающими под маску только файлы, не удовлетворяющие фильтру `excludePaths` и не подпадающие под маску `stageDependencies`.

Правила описания маски в параметре `stageDependencies` аналогичны описанию параметров `includePaths` и `excludePaths`. Маска определяет шаблон для файлов и путей и может содержать следующие шаблоны:

- `*` — удовлетворяет любому файлу. Шаблон включает `.` и исключает `/`.
- `**` — удовлетворяет директории со всем ее содержимым, рекурсивно.
- `?` — удовлетворяет любому одному символу в имени файла (аналогично regexp-шаблону `/.{1}/`).
- `[set]` — удовлетворяет любому символу из указанного набора символов. Аналогично использованию в regexp-шаблонах, включая указание диапазонов типа `[^a-z]`.
- `\` — экранирует следующий символ.


Маска, которая начинается с шаблона `*` или `**`, должна быть взята в одинарные или двойные кавычки в `werf.yaml`:

```
# * в начале маски, используем двойные кавычки.
- "*.rb"
# Одинарные также работают.
- '**/*'
# Нет * в начале, можно не использовать кавычки.
- src/**/*.js
```

Факт изменения файлов в Git-репозитории werf определяет, подсчитывая их контрольные суммы. Для _пользовательской стадии_ и для каждой маски применяется следующий алгоритм:

- werf создает список всех файлов согласно пути, определенному в параметре `add`, и применяет фильтры `excludePaths` и `includePaths`;
- К каждому файлу с учетом его пути применяется маска, согласно правилам применения шаблонов;
- Если под маску подпадает каталог, то все содержимое этого каталога считается подпадающей под маску рекурсивно;
- У получившегося списка файлов werf подсчитывает контрольные суммы с учетом аттрибутов файлов и их содержимого.

Контрольные суммы подсчитываются вначале сборочного процесса перед запуском какой-либо стадии.

Пример:

```yaml
image: app
git:
- add: /src
  to: /app
  stageDependencies:
    beforeSetup:
    - "*"
shell:
  install:
  - echo "install stage"
  beforeSetup:
  - echo "beforeSetup stage"
  setup:
  - echo "setup stage"
```

В приведенном файле конфигурации `werf.yaml` указан _git mapping_, согласно которому содержимое каталога `/src` локального Git-репозитория копируется в каталог `/app` собираемого образа.
Во время первой сборки файлы кэшируются в стадии _gitArchive_ и выполняются сборочные инструкции стадий _install_, _beforeSetup_ и _setup_.

Сборка следующего коммита, в котором будут только изменения файлов за пределами каталога `/src`, не приведет к выполнению инструкций каких-либо стадий. Если коммит будет содержать изменение внутри каталога `/src`, контрольные суммы файлов подпадающих под маску изменятся, werf применит Git-патч и пересоберёт все пользовательские стадии, начиная со стадии _beforeSetup_, а именно — _beforeSetup_ и _setup_. Применение Git-патча будет выполнено один раз на стадии _beforeSetup_.

## Зависимость от значения CacheVersion

Существуют ситуации, когда необходимо принудительно пересобрать все или какую-то конкретную _пользовательскую стадию_. Этого можно достичь, изменяя параметры `cacheVersion` или `<user stage name>CacheVersion`.

Дайджест пользовательской стадии _install_ зависит от значения параметра `installCacheVersion`. Чтобы пересобрать пользовательскую стадию _install_ (и все последующие стадии), можно изменить значение параметра `installCacheVersion`.

> Обратите внимание, что параметры `cacheVersion` и `beforeInstallCacheVersion` имеют одинаковый эффект — при изменении этих параметров возникает пересборка стадии _beforeInstall_ и всех последующих стадий.

### Пример: общий образ для нескольких приложений

Вы можете определить образ, содержащий общие системные пакеты в отдельном файле `werf.yaml`. Изменение параметра `cacheVersion` может быть использовано для пересборки этого образа, чтобы обновить версии системных пакетов.

```yaml
image: ~
from: ubuntu:latest
shell:
  beforeInstallCacheVersion: 2
  beforeInstall:
  - apt update
  - apt install ...
```

Этот образ может быть использован как базовый образ для нескольких приложений (например, если образ с hub.docker.com не удовлетворяет вашим требованиям).

### Пример использования внешних зависимостей

Параметры _CacheVersion_ можно использовать совместно [с шаблонами Go-шаблонизатора]({{ "reference/werf_yaml_template_engine.html" | true_relative_url }}), чтобы определить зависимость _пользовательской стадии_ от файлов, не находящихся в Git-репозитории.

{% raw %}
```yaml
image: ~
from: ubuntu:latest
shell:
  installCacheVersion: {{.Files.Get "some-library-latest.tar.gz" | sha256sum}}
  install:
  - tar zxf some-library-latest.tar.gz
  - <build application>
```
{% endraw %}

Если использовать, например, скрипт загрузки файла `some-library-latest.tar.gz` и запускать werf для сборки уже после скачивания файла, то пересборка пользовательской стадии _install_ (и всех последующих) будет происходить в случае, если скачан новый (измененный) файл.

## Как использовать SSH-агент в сборочных инструкциях

При работе с удаленными Git-репозиториями используется UNIX-сокет `SSH_AUTH_SOCK`, который монтируется во все сборочные контейнеры. Таким образом, сборочные инструкции могут использовать SSH-агент через указанный UNIX-сокет.

> **ЗАМЕЧАНИЕ:** Существует ограничение, из-за которого только пользователь `root` внутри сборочного контейнера имеет доступ к UNIX-сокету из переменной окружения `SSH_AUTH_SOCK`.

По умолчанию (без указания каких-либо параметров) werf пытается использовать SSH-agent, запущенный в системе, проверяя его доступность с помощью переменной окружения `SSH_AUTH_SOCK`.

В случае отсутствия в системе запущенного SSH-агента, werf пытается выступать в качестве SSH-клиента, для чего использует SSH-ключ пользователя по умолчанию, т.е. (`~/.ssh/id_rsa|id_dsa`). Если werf обнаруживает один из этих файлов, то выполняется запуск временного SSH-агента с добавлением найденных ключей.

Для использования только конкретных SSH-ключей необходимо указывать опцию запуска `--ssh-key PRIVATE_KEY_FILE_PATH` (может быть указана несколько раз, для указания нескольких SSH-ключей). В этом случае werf выполняет запуск временного SSH-агента и добавляет ему только указанные SSH-ключи.

### Временный SSH-агент

werf может запускать временный SSH-агент для работы некоторых команд. Такой SSH-агент завершает работу при завершении работы соответствующей команды werf.
В случае, если в системе есть запущенный SSH-агент, то запускаемый werf временный SSH-агент не конфликтует с запущенным в системе SSH-агентом.
