---
title: Добавление исходного кода из git-репозиториев
permalink: usage/build/stapel/git.html
directive_summary: git
---

## Что такое git mapping?

***Git mapping*** определяет, какой файл или папка из Git-репозитория должны быть добавлены в конкретное место образа.
Git-репозиторий может быть как локальным репозиторием, в котором находится файл конфигурации сборки (`werf.yaml`), так и удаленным.
В этом случае указывается адрес репозитория и версия кода — ветка, тег или конкретный коммит.

werf добавляет файлы из Git-репозитория в образ, копируя их с помощью [git archive](https://git-scm.com/docs/git-archive), либо накладывая Git-патч.
При повторных сборках и появлении изменений в Git-репозитории werf добавляет patch к собранному ранее образу, чтобы в конечном образе отразить изменения файлов и папок. Более подробно механизм переноса файлов и накладывания патчей рассматриваются [в следующей секции](#подробнее-про-gitarchive-gitcache-gitlatestpatch).

Конфигурация _git mapping_ поддерживает фильтры, что позволяет сформировать практически любую файловую структуру в образе, используя произвольное количество _git mappings_.
Также вы можете указать группу и владельца конечных файлов в образе, что освобождает от необходимости делать это отдельной командой (`chown`).

В werf реализована поддержка сабмодулей Git (git submodules) и если werf определяет, что какая-то часть _git mapping_ является сабмодулем, то принимаются соответствующие меры, чтобы обрабатывать изменения в сабмодулях корректно.

> Все Git-сабмодули проекта связаны с конкретным коммитом, поэтому все разработчики, работающие с репозиторием с сабмодулями, получают одинаковое содержимое.
> werf не инициализирует и не обновляет сабмодули, а использует соответствующие связанные коммиты.

Пример добавления файлов из папки `/src` локального Git-репозитория в папку `/app` собираемого образа и добавления кода PhantomJS из удаленного репозитория в папку `/src/phantomjs` собираемого образа:

```yaml
git:
- add: /src
  to: /app
- url: https://github.com/ariya/phantomjs
  add: /
  to: /src/phantomjs
```

## Синтаксис

Для добавления кода из локального Git-репозитория используется следующий синтаксис:

- `add` — (не обязательный параметр) путь к директории или файлу, содержимое которого (которой) нужно добавить в образ. Указывается абсолютный путь *относительно корня* репозитория, т.е. он должен начинаться с `/`. По умолчанию копируется все содержимое репозитория, отсутствие параметра `add` равносильно указанию `add: /`;
- `to` — путь внутри образа, куда будет скопировано соответствующее содержимое;
- `owner` — имя или id пользователя-владельца файлов в образе;
- `group` — имя или id группы-владельца файлов в образе;
- `excludePaths` — список исключений (маска) при рекурсивном копировании файлов и папок. Указывается относительно пути, указанного в `add`;
- `includePaths` — список масок файлов и папок для рекурсивного копирования. Указывается относительно пути, указанного в `add`;
- `stageDependencies` — список масок файлов и папок для указания зависимости пересборки стадии от их изменений. Позволяет указать, при изменении каких файлов и папок необходимо принудительно пересобирать конкретную пользовательскую стадию. Более подробно рассматривается [здесь]({{ "usage/build/stapel/instructions.html" | true_relative_url }}).

При использовании удаленных репозиториев дополнительно используются следующие параметры:
- `url` — адрес удаленного репозитория;
- `branch`, `tag`, `commit` — имя ветки, тега или коммита соответственно. По умолчанию — ветка master.

> По умолчанию использование директивы `branch` запрещено гитерминизмом (подробнее об этом [в статье]({{ "usage/project_configuration/giterminism.html" | true_relative_url }})).

## Использование git mapping

### Копирование директорий

Параметр `add` определяет источник, путь в Git-репозитории, откуда файлы рекурсивно копируются в образ и помещаются по адресу, указанному в параметре `to`. Если параметр не определен, то по умолчанию используется значение `/`, т.е. копируется весь репозиторий.
Пример простейшей конфигурации, добавляющей содержимое всего локального Git-репозитория в образ в папку `/app`.

```yaml
git:
- add: /
  to: /app
```

<div class="tabs">
  <a href="javascript:void(0)" class="tabs__btn btn__example1 active" onclick="openTab(event, 'btn__example1', 'tab__example1', 'git-mapping-01-source')">Структура в репозитории</a>
  <a href="javascript:void(0)" class="tabs__btn btn__example1" onclick="openTab(event, 'btn__example1', 'tab__example1', 'git-mapping-01-dest')">Структура в конечном образе</a>
</div>
<div id="git-mapping-01-source" class="tabs__content tab__example1 active">
  <img src="{{ "images/build/git_mapping_01.png" | true_relative_url }}" alt="git repository files tree" />
</div>
<div id="git-mapping-01-dest" class="tabs__content tab__example1">
  <img src="{{ "images/build/git_mapping_02.png" | true_relative_url }}" alt="image files tree" />
</div>

Также можно указать несколько _git mappings_:

```yaml
git:
- add: /src
  to: /app/src
- add: /assets
  to: /static
```

<div class="tabs">
  <a href="javascript:void(0)" class="tabs__btn btn__example2 active" onclick="openTab(event, 'btn__example2', 'tab__example2', 'git-mapping-02-source')">Структура в репозитории</a>
  <a href="javascript:void(0)" class="tabs__btn btn__example2" onclick="openTab(event, 'btn__example2', 'tab__example2', 'git-mapping-02-dest')">Структура в конечном образе</a>
</div>
<div id="git-mapping-02-source" class="tabs__content tab__example2 active">
  <img src="{{ "images/build/git_mapping_03.png" | true_relative_url }}" alt="git repository files tree" />
</div>
<div id="git-mapping-02-dest" class="tabs__content tab__example2">
  <img src="{{ "images/build/git_mapping_04.png" | true_relative_url }}" alt="image files tree" />
</div>

Следует отметить, что конфигурация _git mapping_ не похожа, например, на копирование типа `cp -r /src /app`.
Параметр `add` указывает на *содержимое* каталога, которое будет рекурсивно копироваться из репозитория.
Поэтому, если папка `/assets` со всем содержимым из репозитория должна быть скопирована в папку `/app/assets` образа, то имя *assets* вы должны указать два раза.
Либо, как вариант, вы можете использовать [фильтр](#использование-фильтров) (например, параметр `includePaths`).

Примеры обоих вариантов, которые вы можете использовать для достижения одинакового результата:
```yaml
git:
- add: /assets
  to: /app/assets
```

либо

```yaml
git:
- add: /
  to: /app
  includePaths: assets
```

### Изменение владельца

При добавлении файла из Git-репозитория вы можете указать имя и/или группу владельца файлов в образе.
Добавляемым файлам и папкам в образе при копировании будут установлены соответствующие права.
Пользователь и группа могут быть указаны как именем, так и числовым id (userid, groupid).

Пример использования:

```yaml
git:
- add: /src/index.php
  to: /app/index.php
  owner: www-data
```

Если указан только параметр `owner`, как в приведенном примере, то группой-владельцем устанавливается основная группа указанного пользователя в системе.

В результате в папку `/app` образа будет добавлен файл `index.php` и ему будут установлены следующие права:

![index.php owned by www-data user and group]({{ "images/build/git_mapping_05.png" | true_relative_url }})

Если значения параметра `owner` или `group` не числовые id, а текстовые (т.е. названия соответственно пользователя и группы), то соответствующие пользователь и группа должны существовать в системе. Их нужно добавить заранее при необходимости (к примеру, на стадии _beforeInstall_), иначе при сборке возникнет ошибка.

```yaml
git:
- add: /src/index.php
  to: /app/index.php
  owner: wwwdata
```

### Использование фильтров

Парамеры фильтров, `includePaths` и `excludePaths`, используются при составлении списка файлов для добавления.
Эти параметры содержат набор путей или масок, применяемых соответственно для включения и исключения файлов и папок при добавлении в образ.

Фильтр `excludePaths` работает следующим образом: каждая маска списка применяется к каждому файлу, найденному по пути `add`.
Если файл удовлетворяет хотя бы одной маске, то он исключается из списка файлов на добавление.
Если файл не удовлетворяет ни одной маске, то он добавляется в образ.

Фильтр `includePaths` работает наоборот — если файл удовлетворяет хотя бы одной маске, то он добавляется в образ.

Конфигурация _git mapping_ может содержать оба фильтра.
В этом случае файл добавляется в образ, если его путь удовлетворяет хотя бы одной маске `includePaths` и не удовлетворяет ни одной маске `excludePaths`.

Пример:

```yaml
git:
- add: /src
  to: /app
  includePaths:
  - '**/*.php'
  - '**/*.js'
  excludePaths:
  - '**/*-dev.*'
  - '**/*-test.*'
```

В приведенном примере добавляются `.php` и `.js` файлы из папки  `/src` исключая файлы с суффиксом `-dev.` или `-test.` в имени файла.

> Последний шаг в алгоритме с добавлением суффикса`**/*` сделан для удобства — вам достаточно указать название папки в параметрах _git mapping_, чтобы все ее содержимое удовлетворяло шаблону параметра

Маска может содержать следующие шаблоны:

- `*` — Удовлетворяет любому файлу. Шаблон включает `.` и исключает `/`.
- `**` — Удовлетворяет директории со всем ее содержимым, рекурсивно.
- `?` — Удовлетворяет любому **одному** символу в имени файла (аналогично regexp-шаблону `/.{1}/`).
- `[set]` — Удовлетворяет любому символу из указанного набора символов. Аналогично использованию в regexp-шаблонах, включая указание диапазонов типа `[^a-z]`.
- `\` — Экранирует следующий символ.

Маска, которая начинается с шаблона `*` или `**`, должна быть взята в одинарные или двойные кавычки в `werf.yaml`:
- `"*.rb"` — двойные кавычки;
- `'**/*'` — одинарные кавычки.

Примеры фильтров:

```yaml
add: /src
to: /app
includePaths:
# Удовлетворяет всем php файлам, расположенным конкретно в папке /src.
- '*.php'

# Удовлетворяет всем php файлам рекурсивно, начиная с папки /src
# (также удовлетворяет файлам *.php, т.к. '.' включается шаблон **).
- '**/*.php'

# Удовлетворяет всем файлам в папке /src/module1 рекурсивно.
- module1
```

Фильтр `includePaths` может применяться для копирования одного файла без изменения имени. Пример:
```yaml
git:
- add: /src
  to: /app
  includePaths: index.php
```

### Наложение путей копирования

Если вы определяете несколько _git mappings_, вы должны учитывать, что при наложении путей в образе в параметре `to` вы можете столкнуться с невозможностью добавления файлов. Пример:

```yaml
git:
- add: /src
  to: /app
- add: /assets
  to: /app/assets
```

Чтобы избежать ошибок сборки, werf определяет возможные наложения касающиеся фильтров `includePaths` и `excludePaths`, и если такое наложение присутствует, то werf пытается разрешить самые простые конфликты, неявно добавляя соответствующий параметр `excludePaths` в _git mapping_.
Однако, такое поведение может все-таки привести к неожиданным результатам, поэтому лучше всего избегать наложения путей при определении _git mappings_.

В примере выше werf в итоге неявно добавит параметр  `excludePaths`, и итоговая конфигурация будет следующей:

```yaml
git:
- add: /src
  to: /app
  excludePaths:  # werf добавил этот фильтр, чтобы исключить конфликт наложения результирующих путей
  - assets       # между /src/assets и /assets
- add: /assets
  to: /app/assets
```

## Работа с удаленными репозиториями

werf может использовать удаленные репозитории в качестве источника файлов.
Для указания адреса внешнего репозитория используется параметр `url`.
werf поддерживает работу с удаленными репозиториями по протоколам `https` и `git+ssh`.

### HTTPS

Синтаксис для работы по протоколу `https`:

{% raw %}
```yaml
git:
- url: https://[USERNAME[:PASSWORD]@]repo_host/repo_path[.git/]
```
{% endraw %}

Указание логина и пароля при доступе по `https` опционально.

Пример доступа к репозиторию из pipeline GitLab CI с использованием переменных окружения:

{% raw %}
```yaml
git:
- url: https://{{ env "CI_REGISTRY_USER" }}:{{ env "CI_JOB_TOKEN" }}@registry.gitlab.company.name/common/helper-utils.git
```
{% endraw %}

В приведенном примере используется метод [env](http://masterminds.github.io/sprig/os.html) библиотеки [Sprig](http://masterminds.github.io/sprig/) для доступа к переменным окружения.

### Git, SSH

Доступ к удаленному репозиторию с помощью протокола `git` защищается с использованием доступа поверх SSH. Это распространенная практика, используемая в частности GitHub, Bitbucket, GitLab, Gogs, Gitolite и т.д. Обычно адрес репозитория выглядит следующим образом:

```yaml
git:
- url: git@gitlab.company.name:project_group/project.git
```

Для работы с удаленными репозиториями по SSH необходимо понимать, как werf находит SSH-ключи (читай далее подробнее).

#### Работа с SSH-ключами

SSH-ключи для доступа предоставляются через SSH-agent. SSH-agent — это демон, который работает через файловый сокет, путь к которому хранится в переменной окружения `SSH_AUTH_SOCK`. werf монтирует этот файловый сокет во все _сборочные контейнеры_ и устанавливает переменную окружения `SSH_AUTH_SOCK`. Т.e. соединение с удаленным Git-репозиторием устанавливается с использованием ключей, зарегистрированных в запущенном SSH-агенте.

werf использует следующий алгоритм для определения запущенного SSH-агента:

- werf запущен с ключом `--ssh-key` (одним или несколькими):
  - Запускается временный SSH-агент, в который добавляются указанные при запуске werf ключи. Эти ключи используются при всех операциях с удаленными репозиториями.
  - Уже запущенный SSH-агент игнорируется.
- werf запущен без указания ключа `--ssh-key` и есть запущенный SSH-агент:
  - Используется переменная окружения `SSH_AUTH_SOCK`, ключи добавляются в соответствующий SSH-агент и используются далее при всех операциях работы с удаленными репозиториями.
- werf запущен без указания ключа `--ssh-key` и нет запущенного SSH-агента:
  - Если существует файл `~/.ssh/id_rsa`, запускается временный SSH-агент, в который добавляется ключ из файла `~/.ssh/id_rsa`.
- Если ни один из вариантов не применим, то SSH-агент не запускается и при операциях с внешними Git-репозиториями не используются никакие SSH-ключи. Сборка образа, с объявленными удаленными репозиториями в _git mapping_, завершится с ошибкой.

## Подробнее про gitArchive, gitCache, gitLatestPatch

Далее будет более подробно рассмотрен процесс добавления файлов в конечный образ. Как упоминалось ранее, Docker-образ состоит из набора слоёв. Чтобы понимать, какие слои создает werf, представим последовательную сборку трех коммитов: `1`, `2` и `3`:

- Сборка коммита 1. Исходя из конфигурации _git mapping_, все соответствующие файлы добавляются в один слой. Сам процесс добавления выполняется с помощью `git archive`. Получившийся слой соответствует стадии _gitArchive_.
- Сборка коммита 2. Накладывается патч с изменениями файлов, в результате чего получается еще один слой. Получившийся слой соответствует стадии _gitLatestPatch_.
- Сборка коммита 3. Файлы уже добавлены, и werf накладывает патч, обновляя слой _gitLatestPatch_.

Сборки для этих коммитов можно представить ​​следующим образом:

|                                      |        gitArchive        |      gitLatestPatch      |
| ------------------------------------ | :----------------------: | :----------------------: |
| Commit No. 1 is made, build at 10:00 | files as in commit No. 1 |            -             |
| Commit No. 2 is made, build at 10:05 | files as in commit No. 1 | files as in commit No. 2 |
| Commit No. 3 is made, build at 10:15 | files as in commit No. 1 | files as in commit No. 3 |

Со временем количество коммитов растет, и размер патча между коммитом №1 и текущим может стать довольно большим. Это еще больше увеличит размер последнего слоя и общий размер стадий. Чтобы предотвратить неконтролируемый рост последнего слоя, werf предоставляет дополнительный промежуточный этап — _gitCache_. Когда _gitLatestPatch_ diff становится слишком большим, большая часть его diff объединяется с _gitCache_ diff, тем самым уменьшая размер стадии _gitLatestPatch_.

### Rebase и _git-стадии_

Каждая Git-стадия хранит служебные лейблы с SHA коммитами, которые использовались при сборке стадии.
Эти коммиты будут использоваться при сборке следующей Git-стадии при создании патчей (по сути это `git diff COMMIT_FROM_PREVIOUS_GIT_STAGE LATEST_COMMIT` для каждого _git-mapping_).

Если в стадии сохранён коммит, который отсутствует в Git-репозитории (например, после выполнения rebase), werf пересоберёт эту стадию, используя актуальный коммит.

## Git worktree

Для корректной работы сборщика stapel werf-у требуется полная git-история проекта, чтобы работать в наиболее эффективном режиме. Поэтому по умолчанию werf выполняет fetch истории для текущего git проекта, когда это требуется. Это означает, что werf может автоматически сконвертировать shallow-clone репозитория в полный clone и скачать обновлённый список веток и тегов из origin в процессе очистки образов.

Поведение по умолчанию описывается следующими настройками:

```yaml
gitWorktree:
  forceShallowClone: false
  allowUnshallow: true
  allowFetchOriginBranchesAndTags: true
```

Чтобы, например, выключить автоматический unshallow рабочей директории git, необходимы следующие настройки:

```yaml
gitWorktree:
  forceShallowClone: true
  allowUnshallow: false
```
