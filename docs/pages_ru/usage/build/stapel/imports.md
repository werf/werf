---
title: Импорт из артефактов и образов
permalink: usage/build/stapel/imports.html
author: Alexey Igrychev <alexey.igrychev@flant.com>
directive_summary: import
---

Из-за используемых инструментов сборки либо просто из-за исходных файлов размер целевого образа может увеличиваться в несколько раз. Зачастую эти файлы не нужны в конечном образе. Для решения таких проблем сообщество Docker предлагает выполнять установки инструментов, сборку и удаление ненужных файлов за один шаг.

Условный пример:
```Dockerfile
RUN “download-source && cmd && cmd2 && remove-source”
```

> Аналогичный пример может быть реализован и в werf. Для этого достаточно описать инструкции в одной _пользовательской стадии_. Пример при использовании _shell-сборщика_ для стадии _install_ (аналогичен и для _ansible-сборщика_):
```yaml
shell:
  install:
  - "download-source"
  - "cmd"
  - "cmd2"
  - "remove-source"
```

Однако при использовании такого метода кэширование работать не будет, и установка инструментов сборки будет выполняться каждый раз.

Другой способ — использование multi-stage сборки, которая поддерживается в Docker, начиная с версии 17.05.

```Dockerfile
FROM node:latest AS storefront
WORKDIR /app
COPY react-app .
RUN npm install
RUN npm run build

FROM maven:latest AS appserver
WORKDIR /app
COPY . .
RUN mvn package

FROM java:8-jdk-alpine
COPY --from=storefront /app/react-app/build/ /static
COPY --from=appserver /app/target/AtSea-0.0.1-SNAPSHOT.jar /app/AtSea.jar
```

Смысл такого подхода в следующем — описать несколько вспомогательных образов и выборочно копировать артефакты из одного образа в другой, оставляя все то, что не нужно в конечном образе.

werf предлагает такой-же подход, но с использованием _образов_ и _артефактов_.

> Почему werf не использует multi-stage сборку?
* Исторически возможность _импорта_ появилась значительно раньше, чем в Docker появилась multi-stage сборка.
* werf дает больше гибкости при работе со вспомогательными образами.

Импорт _ресурсов_ из _образов_ и _артефактов_ должен быть описан в директиве `import` в конфигурации _образа_ или _артефакта_, куда импортируются файлы. `import` — массив записей, каждая из которых должна содержать следующие параметры:

- `image: <image name>` или `artifact: <artifact name>`: _исходный образ_, имя образа из которого вы хотите копировать файлы или каталоги.
- `stage: <stage name>`: _стадия исходного образа_, определённая стадия _исходного образа_, из которого вы хотите копировать файлы или каталоги.
- `add: <absolute path>`: _исходный путь_, абсолютный путь к файлу или каталогу в _исходном образе_ для копирования.
- `to: <absolute path>`: _путь назначения_, абсолютный путь в _образе назначения_ (куда импортируются файлы или каталоги). В случае отсутствия считается равным значению, указанному в параметре `add`.
- `before: <install || setup>` or `after: <install || setup>`: _стадия образа назначения_ для импорта. В настоящий момент возможен импорт только до/после стадии _install_ или _setup_.

Пример:
```yaml
import:
- artifact: application-assets
  add: /app/public/assets
  to: /var/www/site/assets
  after: install
- image: frontend
  add: /app/assets
  after: setup
```

Так же, как и при конфигурации _git mappings_, поддерживаются маски включения и исключения файлов и каталогов.
Для указания маски включения файлов используется параметр `include_paths: []`, а для исключения `exclude_paths: []`. Маски указываются относительно пути источника (параметр `add`).
Вы также можете указывать владельца и группу для импортируемых ресурсов с помощью параметров `owner: <owner>` и `group: <group>` соответственно.
Это поведение аналогично используемому при добавлении кода из Git-репозиториев, и вы можете подробнее почитать об этом [в соответствующем разделе]({{ "usage/build/stapel/git.html" | true_relative_url }}).

> Обратите внимание, что путь импортируемых ресурсов и путь указанный в _git mappings_ не должны пересекаться.

## Что такое артефакты?

***Артефакт*** — это специальный образ, используемый в других артефактах или отдельных образах, описанных в конфигурации. Артефакт предназначен преимущественно для отделения ресурсов инструментов сборки от процесса сборки образа приложения. Примерами таких ресурсов могут быть — программное обеспечение или данные, которые необходимы для сборки, но не нужны для запуска приложения, и т.п.

Используя артефакты, вы можете собирать неограниченное количество компонентов, что позволяет решать, например, следующие задачи:
- Если приложение состоит из набора компонент, каждый со своими зависимостями, то обычно вам приходится пересобирать все компоненты каждый раз. Вам бы хотелось пересобирать только те компоненты, которым это действительно нужно.
- Компоненты должны быть собраны в разных окружениях.

Импортирование _ресурсов_ из _артефактов_ указывается с помощью [директивы import]({{ "usage/build/stapel/imports.html" | true_relative_url }}) в конфигурации в _секции образа_ или _секции артефакта_.

### Конфигурация

Конфигурация _артефакта_ похожа на конфигурацию обычного _образа_. Каждый _артефакт_ должен быть описан в своей секции конфигурации.

Инструкции, связанные со стадией _from_ (инструкции указания [базового образа]({{ "usage/build/stapel/base.html" | true_relative_url }}) и [монтирования]({{ "usage/build/stapel/mounts.html" | true_relative_url }})), а также инструкции [импорта]({{ "usage/build/stapel/imports.html" | true_relative_url }}) точно такие же, как и при описании _образа_.

Стадия добавления инструкций Docker (`docker_instructions`) и [соответствующие директивы]({{ "usage/build/stapel/dockerfile.html" | true_relative_url }}) недоступны при описании _артефактов_. _Артефакт_ — это инструмент сборки, и все что от него требуется, это — только данные.

Остальные _стадии_ и инструкции описания артефактов рассматриваются далее подробно.

#### Именование

<div class="summary" markdown="1">
```yaml
artifact: string
```
</div>

_Образ артефакта_ объявляется с помощью директивы `artifact`. Синтаксис: `artifact: string`. Так как артефакты используются только самим werf, отсутствуют какие-либо ограничения на именование артефактов, в отличие от ограничений [на именование обычных _образов_.

Пример:
```yaml
artifact: "application assets"
```

#### Добавление исходного кода из Git-репозиториев

<div class="summary">

<a class="google-drawings" href="{{ "images/configuration/stapel_artifact2.svg" | true_relative_url }}" data-featherlight="image">
  <img src="{{ "images/configuration/stapel_artifact2.svg" | true_relative_url }}">
</a>

</div>

В отличие от обычных _образов_, у _конвейера стадий артефактов_ нет стадий _gitCache_ и _gitLatestPatch_.

> В werf для _артефактов_ реализована необязательная зависимость от изменений в Git-репозиториях. Таким образом, по умолчанию werf игнорирует какие-либо изменения в Git-репозитории, кэшируя образ после первой сборки. Но вы можете определить зависимости от файлов и каталогов, при изменении в которых образ артефакта будет пересобираться.

Читайте подробнее про работу с _git-репозиториями_ [в соответствующей статье]({{ "usage/build/stapel/git.html" | true_relative_url }}).

#### Запуск инструкций сборки

<div class="summary">

<a class="google-drawings" href="{{ "images/configuration/stapel_artifact3.svg" | true_relative_url }}" data-featherlight="image">
  <img src="{{ "images/configuration/stapel_artifact3.svg" | true_relative_url }}">
</a>

</div>

У артефактов точно такое же, как и у обычных образов, использование директив и пользовательских стадий — _beforeInstall_, _install_, _beforeSetup_ и _setup_.

Если в директиве `stageDependencies` в блоке Git для _пользовательской стадии_ не указана зависимость от каких-либо файлов, то образ кэшируется после первой сборки и не будет повторно собираться, пока соответствующая _стадия_ находится в _stages storage_.

> Если необходимо повторно собирать артефакт при любых изменениях в Git, нужно указать _stageDependency_ `**/*` для соответствующей _пользовательской_ стадии. Пример для стадии _install_:
```yaml
git:
- to: /
  stageDependencies:
    install: "**/*"
```

Читайте подробнее про работу с _инструкциями сборки_ [в соответствующей статье]({{ "usage/build/stapel/instructions.html" | true_relative_url }}).

## Использование артефактов

В отличие от [*обычного образа*]({{ "usage/build/stapel/instructions.html" | true_relative_url }}), у *образа артефакта* нет стадии _git latest patch_. Это сделано намеренно, т.к. стадия _git latest patch_ выполняется обычно при каждом коммите, применяя появившиеся изменения к файлам. Однако *артефакт* рекомендуется использовать как образ с высокой вероятностью кэширования, который обновляется редко или нечасто (например, при изменении специальных файлов).

Пример: нужно импортировать в артефакт данные из Git, и пересобирать ассеты только тогда, когда изменяются влияющие на сборку ассетов файлы. Т.е. в случае изменения каких-либо других файлов в Git ассеты пересобираться не должны.

Конечно, существуют случаи, когда необходимо включать изменения любых файлов Git-репозитория в _образ артефакта_ (например, если в артефакте происходит сборка приложения на Go). В этом случае необходимо указать зависимость относительно стадии (сборку которой необходимо выполнять при изменениях в Git) с помощью `git.stageDependencies` и `*` в качестве шаблона. Пример:

```yaml
git:
- add: /
  to: /app
  stageDependencies:
    setup:
    - "*"
```

В этом случае любые изменения файлов в Git-репозитории будут приводить к пересборке _образа артефакта_ и всех _образов_, в которых определен импорт этого артефакта.

**Замечание:** Если вы используете какие-либо файлы и при сборке _артефакта_, и при сборке [*обычного образа*]({{ "usage/build/stapel/instructions.html" | true_relative_url }}), правильный путь — использовать директиву `git.add` при описании каждого образа, где это необходимо, т.е. несколько раз. **Нерекомендуемый** вариант — добавить файлы при сборке артефакта, а потом импортировать их используя директиву `import` в другой образ.
