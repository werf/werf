---
title: Импортирование из образов
permalink: usage/build/stapel/imports.html
author: Alexey Igrychev <alexey.igrychev@flant.com>
directive_summary: import
---

Из-за используемых инструментов сборки либо просто из-за исходных файлов размер целевого образа может увеличиваться в несколько раз. Зачастую эти файлы не нужны в конечном образе. Для решения таких проблем сообщество Docker предлагает выполнять установки инструментов, сборку и удаление ненужных файлов за один шаг.

Условный пример:
```Dockerfile
RUN “download-source && cmd && cmd2 && remove-source”
```

> Аналогичный пример может быть реализован и в werf. Для этого достаточно описать инструкции в одной _пользовательской стадии_. Пример при использовании _shell-сборщика_ для стадии _install_ (аналогичен и для _ansible-сборщика_):
```yaml
shell:
  install:
  - "download-source"
  - "cmd"
  - "cmd2"
  - "remove-source"
```

Однако при использовании такого метода кэширование работать не будет, и установка инструментов сборки будет выполняться каждый раз.

Другой способ — использование multi-stage сборки, которая поддерживается в Docker, начиная с версии 17.05.

```Dockerfile
FROM node:latest AS storefront
WORKDIR /app
COPY react-app .
RUN npm install
RUN npm run build

FROM maven:latest AS appserver
WORKDIR /app
COPY . .
RUN mvn package

FROM java:8-jdk-alpine
COPY --from=storefront /app/react-app/build/ /static
COPY --from=appserver /app/target/AtSea-0.0.1-SNAPSHOT.jar /app/AtSea.jar
```

Смысл такого подхода в следующем — описать несколько вспомогательных образов и выборочно копировать артефакты из одного образа в другой, оставляя все то, что не нужно в конечном образе.

werf предлагает подобный подход.

> Почему werf не использует multi-stage сборку?
* Исторически возможность _импорта_ появилась значительно раньше, чем в Docker появилась multi-stage сборка.
* werf дает больше гибкости при работе со вспомогательными образами.

## Конфигурация импорта

Импорт _ресурсов_ из _образов_ должен быть описан в директиве `import` в конфигурации _образа_, куда импортируются файлы. `import` — массив записей, каждая из которых должна содержать следующие параметры:

- `image: <image name>`: _исходный образ_, имя образа из которого вы хотите копировать файлы или каталоги.
- `stage: <stage name>`: _стадия исходного образа_, определённая стадия _исходного образа_, из которого вы хотите копировать файлы или каталоги.
- `add: <absolute path>`: _исходный путь_, абсолютный путь к файлу или каталогу в _исходном образе_ для копирования.
- `to: <absolute path>`: _путь назначения_, абсолютный путь в _образе назначения_ (куда импортируются файлы или каталоги). В случае отсутствия считается равным значению, указанному в параметре `add`.
- `before: <install || setup>` or `after: <install || setup>`: _стадия образа назначения_ для импорта. В настоящий момент возможен импорт только до/после стадии _install_ или _setup_.

Пример:
```yaml
import:
- image: application-assets
  add: /app/public/assets
  to: /var/www/site/assets
  after: install
- image: frontend
  add: /app/assets
  after: setup
```

Так же, как и при конфигурации _git mappings_, поддерживаются маски включения и исключения файлов и каталогов.
Для указания маски включения файлов используется параметр `includePaths: []`, а для исключения `excludePaths: []`. Маски указываются относительно пути источника (параметр `add`).
Вы также можете указывать владельца и группу для импортируемых ресурсов с помощью параметров `owner: <owner>` и `group: <group>` соответственно.
Это поведение аналогично используемому при добавлении кода из Git-репозиториев, и вы можете подробнее почитать об этом [в соответствующем разделе]({{ "usage/build/stapel/git.html" | true_relative_url }}).

> Обратите внимание, что путь импортируемых ресурсов и путь указанный в _git mappings_ не должны пересекаться.
