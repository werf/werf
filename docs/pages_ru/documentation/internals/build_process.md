---
title: Процесс сборки
sidebar: documentation
permalink: documentation/internals/build_process.html
author: Alexey Igrychev <alexey.igrychev@flant.com>
---

Сборочный процесс werf для образов, описанных в [werf.yaml]({{ "documentation/reference/werf_yaml.html" | relative_url }}), подразумевает последовательную сборку стадий для соответствующих [конвейеров стадий]({{ "documentation/internals/stages_and_storage.html" | relative_url }}#конвеер-стадий).

Несмотря на то, что _конвейеры стадий_ для Dockerfile-образа, Stapel-образа и Stapel-артефакта отличаются, каждая стадия подчиняется общим правилам [выборки из хранилища](#выборка-стадий), [сохранения](#cохранение-стадий-в-хранилище), а также [работы кеша и блокировок](#синхронизация-блокировки-и-кеш-хранилища) в параллельных запусках. 

## Сборка стадии Dockerfile-образа

Для сборки Dockerfile-образа werf создает единственную [стадию]({{ "documentation/internals/stages_and_storage.html" | relative_url }}#конвеер-стадий) — `dockerfile`.

В настоящий момент, при сборке стадии werf использует стандартные команды встроенного в Docker клиента (это аналогично выполнению команды `docker build`), а также аргументы, которые пользователь описывает в `werf.yaml`. Кэш, создаваемый при сборке, используется, как и при обычной сборке, без помощи werf.

Подробнее о файле конфигурации сборки `werf.yaml` смотри в [соответствующем разделе]({{ "documentation/reference/werf_yaml.html" | relative_url }}#сборщик-dockerfile).

## Сборка стадии Stapel-образа и Stapel-артефакта

При сборке стадии предполагается, что инструкции стадии будут запускаться в контейнере, основанном на предыдущей собранной стадии. Такой контейнер будет упоминаться далее как **сборочный контейнер**.

Перед запуском _сборочного контейнера_ werf подготавливает набор инструкций, который зависит от типа стадии и содержит как внутренние команды werf, так и пользовательские команды, указанные в конфигурации `werf.yaml`. Например, werf может добавлять в список инструкций команды применения патча, измененных примонтированных файлов (такие патчи werf делает с помощью CLI команд git).

При запуске _сборочного контейнера_ [пробрасывается сокет ssh-агента с хоста]({{ "documentation/internals/integration_with_ssh_agent.html" | relative_url }}), а также могут использоваться [пользовательские маунты]({{ "documentation/advanced/building_images_with_stapel/mount_directive.html" | relative_url }}).

Для сборки Stapel-сборщик использует свой набор инструментов и библиотек, никак не зависит от базового образа. При запуске _сборочного контейнера_ werf монтирует специальный сервисный образ `flant/werf-stapel`. Подробнее об образе можно прочитать в [соответствующей статье]({{ "documentation/internals/development/stapel_image.html" | relative_url }}).

Также стоит отметить, что werf игнорирует значения манифеста базового образа при сборке:
- `--user=0:0`;
- `--workdir=/`;
- `--entrypoint=/.werf/stapel/embedded/bin/bash`.

В итоге, запуск _сборочного контейнера_ выглядит следующим образом:
```shell
docker run \
  --name=werf.build.offtur4fay \
  --volume=/tmp/ssh-ln8yCMlFLZob/agent.17554:/.werf/tmp/ssh-auth-sock \
  --volumes-from=stapel_0.6.1 \
  --env=SSH_AUTH_SOCK=/.werf/tmp/ssh-auth-sock \
  --user=0:0 \ 
  --workdir=/ \
  --entrypoint=/.werf/stapel/embedded/bin/bash \
  --env=COLUMNS=146 \
  sha256:d6e46aa2470df1d32034c6707c8041158b652f38d2a9ae3d7ad7e7532d22ebe0 \
  -ec eval $(echo c2V0IC14 | /.werf/stapel/embedded/bin/base64 --decode)
```

Подробнее о файле конфигурации сборки `werf.yaml` смотри в [соответствующем разделе]({{ "documentation/reference/werf_yaml.html" | relative_url }}#stapel-сборщик).

### Как сборщик Stapel работает с CMD и ENTRYPOINT

Для сборки стадии werf запускает контейнер со служебными значениями `CMD` и `ENTRYPOINT` а затем, заменяет их значениями [базового образа]({{ "documentation/advanced/building_images_with_stapel/base_image.html" | relative_url }}). Если в базовом образе эти значения не установлены, werf сбрасывает их следующим образом:
* `[]` для `CMD`;
* `[""]` для `ENTRYPOINT`.

Также werf сбрасывает (использует специальные пустые значения) значение `ENTRYPOINT` базового образа, если указано значение `CMD` в конфигурации (`docker.CMD`).

В противном случае поведение werf аналогично [поведению Docker](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).

## Выборка стадий

Алгоритм выборки стадии в werf можно представить следующим образом:

 1. Рассчитывается [дайджест стадии]({{ "documentation/internals/stages_and_storage.html" | relative_url }}#дайджест-стадии).
 2. Выбираются все стадии, подходящие под дайджест, т.к. c одним дайджестом может быть связанно несколько стадий в [хранилище]({{ "documentation/internals/stages_and_storage.html" | relative_url }}#хранилище).
 3. Выбирается старейший по времени `TIMESTAMP_MILLISEC` (подробнее про именование стадий [здесь]({ site.baseurl }}/documentation/internals/stages_and_storage.html#именование-стадий)).

### Дополнение для Stapel-образов и Stapel-артефактов

К основному алгоритму добавляется проверка родства git-коммитов. После шага **2** выполняется дополнительный отсев с использованием истории git: если текущая стадия связана с git (стадия git-архив, пользовательская стадия с git-патчами или стадия git latest patch), тогда выбираются только те стадии, которые связаны с коммитами, являющимися предками текущего коммита. Таким образом, коммиты соседних веток будут отброшены.

Возможна ситуация когда существует несколько собранных образов с одинаковым дайджестом. Более того, стадии для разных git-веток могут иметь одинаковую дайджест. Однако werf гарантированно предотвращает переиспользование кеша между несвязанными ветками. Кеш в разных ветках может быть переиспользован только если этот кеш относится к коммиту, который является базовым, как для одной ветки, так и для другой.

## Сохранение стадий в хранилище

Множество процессов werf (на одном хосте или на нескольких хостах) могут инициировать сборку одной и той же стадии в один момент времени, потому что этой стадии еще нет в хранилище. 

werf использует алгоритм оптимистичных блокировок в процессе сохранения свежесобранного образа в хранилище. Когда сборка нового образа закончена, werf блокирует хранилище на любые операции с целевым дайджестом:
- Если за время сборки подходящего образа не появилось в хранилище, то werf сохраняет новый образ, сгенерировав гарантированно уникальный идентификатор `TIMESTAMP_MILLISEC`.
- Если за время сборки подходящий образ появился в хранилище, то werf отбрасывает свежесобранный образ, а вместо него использует появившийся в хранилище образ.

Другими словами: первый процесс, который закончит сборку новой стадии (самый быстрый процесс) получит шанс сохранить собранный образ в хранилище. Медленный процесс сборки не будет блокировать более быстрые процессы в параллельной и распределенной среде.

В процессе выборки и сохранения новых стадий в хранилище werf использует [менеджер блокировок](#синхронизация-блокировки-и-кеш-хранилища) для координации работы нескольких процессов werf.

## Синхронизация: блокировки и кеш хранилища

Синхронизация — это группа сервисных компонентов werf, предназначенных для координации нескольких процессов werf при выборке и сохранении стадий в хранилище, а также при публикации образов в репозиторий образов. Существует 2 таких компонента для синхронизации:

 1. _Кеш хранилища_ — это внутренний служебный кеш werf, который существенно повышает производительность фазы рассчёта стадий в случае, если эти стадии уже есть в хранилище. Кеш хранилища содержит соответствие существующих в хранилище с дайджестом (или другими словами: содержит предварительно расчитанный шаг алгоритма выборки стадий по дайджесту). Данный кеш является когерентным и werf автоматически сбрасывает его, если будет замечена несостыковка между хранилищем стадий и кешом хранилища.
 2. _Менеджер блокировок_. Блокировки требуются для корректной публикации новых стадий в хранилище, публикации новых образов в репозиторий образов и для организации параллельных процессов выката в Kubernetes (блокируется имя релиза).

Все команды, использующие параметры хранилища (`--repo=...`) также требуют указания адреса менеджера блокировок, который задается опцией `--synchronization=...` или переменной окружения `WERF_SYNCHRONIZATION=...`.

Существует 2 типа наборов компонентов для синхронизации:
 1. Локальный. Включается опцией `--synchronization=:local`.
   - Локальный _кеш хранилища_ располагается по умолчанию в файлах `~/.werf/shared_context/storage/stages_storage_cache/1/PROJECT_NAME/DIGEST`, каждый из которых хранит соответствие существующих в хранилище по некоторому дайджесту.
   - Локальный _менеджер блокировок_ использует файловые блокировки, предоставляемые операционной системой.
 2. Kubernetes. Включается опцией `--synchronization=kubernetes://NAMESPACE[:CONTEXT][@(base64:CONFIG_DATA)|CONFIG_PATH]`.
  - _Кеш хранилища_ в Kubernetes использует для каждого проекта отдельный ConfigMap `cm/PROJECT_NAME`, который создается в указанном `NAMESPACE`.
  - _Менеджер блокировок_ в Kubernetes использует ConfigMap по имени проекта `cm/PROJECT_NAME` (тот же самый что и для кеша хранилища) для хранения распределённых блокировок в аннотациях этого ConfigMap. Werf использует [библиотека lockgate](https://github.com/werf/lockgate), которая реализует распределённые блокировки с помощью обновления аннотаций в ресурсах Kubernetes.
 3. Http. Включается опцией `--synchronization=http[s]://DOMAIN`.
  - Есть публичный сервер синхронизации доступный по домену `https://synchronization.werf.io`.
  - Собственный http сервер синхронизации может быть запущен командой `werf synchronization`. 

Werf использует `--synchronization=:local` (локальный _кеш хранилища_ и локальный _менеджер блокировок_) по умолчанию, если используется локальное хранилище.

Werf использует `--synchronization=https://synchronization.werf.io` по умолчанию, если используется удалённое хранилище (`--repo=DOCKER_REPO_ADDRESS`).

Пользователь может принудительно указать произвольный адрес компонентов для синхронизации, если это необходимо, с помощью явного указания опции `--synchronization=:local|(kubernetes://NAMESPACE[:CONTEXT][@(base64:CONFIG_DATA)|CONFIG_PATH])|(http[s]://DOMAIN)`.

**ЗАМЕЧАНИЕ:** Множество процессов werf, работающих с одним и тем же проектом обязаны использовать одинаковое хранилище и адрес набора компонентов синхронизации.
