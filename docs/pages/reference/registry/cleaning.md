---
title: Cleaning
sidebar: reference
permalink: reference/registry/cleaning.html
author: Artem Kladov <artem.kladov@flant.com>
---

Одни из основных преимуществ использования dapp, - это возможности применения разноуровневого эффективного кэширования и инструментов очистки docker registry. О возможностях кэширования вы можете узнать в соответствующем [разделе]({{ site.baseurl }}/not_used/cache_for_advanced_build.html), а далее будут рассмотрены способы обеспечения очистки docker registry.

Правильное использование инструментов очистки позволит сократить объем занимаемого docker registry пространства, забыть о рутинных операциях по очистке вашего docker registry в процессе разработки и эксплуатации приложений.

Под очисткой подразумевается очистка используемых в dapp кэшей, а также локального и удаленного docker registry.

Периодическая очистка docker registry - необходима, т.к. процессе сборки образов приложений появляются неактуальные docker-образы, которые будут занимать место в registry, но уже не понадобятся. Такие образы могут возникать например в случае, если ветка/тег были удалены, процесс сборки был внезапно остановлен и т.п.

Процесс сборки и публикации образа в распределенном окружении включает в себя следующие этапы:

* Скачивание кэша сборки приложения на сборочном сервере (pull из docker registry).
* Сборка образа на сборочном сервере.
* Выкат образа приложения вместе со сборочным кэшем в registry (push в docker registry).

**Важно понимать**, что локальные образы на сборочном сервере синхронизируются с образами в registry. Registry является первичным источником информации о том, какие образы являются лишними.

## Очистка неактуального кэша приложений

Набор связанных с dapp приложением образов в registry состоит из:

* Конечных образов приложений, о схеме их именования см подробнее в разделе [registry]({{ site.baseurl }}/reference/registry/push_and_pull.html).
  * При этом на сборочной машине такие образы не создаются, т.к. не нужны.
* Образов сборочного кэша, связанных с конечными образами приложений.

Пользователь dapp управляет очисткой кэша удаляя конечные образы приложения из registry. Для удаления конкретных конечных образов приложения не существует специальных команд в dapp — пользователь делает это самостоятельно.

Удаление же связанных с этими конечными образами приложения образов кэша сборки — по сути синхронизация сборочного кэша с реально существующими версиями приложения — происходит с помощью использования команд dapp.

* `dapp dimg stages cleanup local --improper-repo-cache REPO` удаляет те локальные образы, которые не связаны ни с одним образом конечного приложения из registry `REPO`.
* `dapp dimg stages cleanup repo --improper-repo-cache REPO` удаляет то же самое, но уже в самом registry `REPO`.

*Примечание*. Для обеих команд первичным источником информации о существующих конечных образах приложения является registry. Как следствие, запуск `dapp dimg stages cleanup local --improper-repo-cache` до публикации собранного приложения в registry удалит весь локальных кэш (т.к. registry пуст).

## Очистка образов от старых версий сборщика dapp

Docker-образы, которые создает dapp могут стать неактуальными после обновления версии dapp. Но такое происходит только в случае, если в dapp произошли существенные изменения в логике сборки и требуется пересборка уже собранных ранее образов. От пользователя требуется периодически запускать специальные команды очистки таких образов.

Аналогично, предыдущему разделу, есть 2 команды для удаления локальных образов и образов в registry.

* `dapp dimg stages cleanup local --improper-cache-version` удалит локальные docker-образы более не актуальные для текущей версии dapp.
* `dapp dimg stages cleanup repo --improper-cache-version REPO` удалит docker-образы более не актуальные для текущей версии dapp из registry `REPO`.

## Очистка некорректного сборочного кэша из-за использования git rebase

Допустим, пользователь собрал для приложения, использующего git-артефакт некоторый образ. А затем, для git-артефакта был сделан rebase, была изменена история коммитов и использовавшийся в кэше сборки идентификатор коммита перестал существовать в git-репозитории. Попытка сборки при наличии такого кэша приведет к ошибкам.

Поэтому существуют специальные команды удаления кэша, который более не валиден из-за изменений в связанных git-репозиториях:

* `dapp dimg stages cleanup local --improper-git-commit` — локально;
* `dapp dimg stages cleanup repo --improper-git-commit REPO` — в registry `REPO`.

На данный момент автоматической инвалидации подобных образов не предусмотрено.

## Очистка нетегированных образов

В результате внезапного завершения процессов сборки по каким-либо причинам, в локальном хранилище docker образов могу остаться собранные но не протегированные dapp образы. Такие образы не попадут в сборочный кэш, не будут использоваться и не будут удалены автоматически. Например, если прервать работу сборщика, убив процесс — все собранные стадии останутся в локальном хранилище docker образов непротегированными в следующем виде:

```shell
REPOSITORY    TAG         IMAGE ID           CREATED             SIZE
<none>        <none>      b482808d6b36       14 seconds ago      130 MB
<none>        <none>      6fa6a4d13396       31 seconds ago      130 MB
```

Чтобы избавиться от таких образов, в dapp предусмотрена команда:
* `dapp dimg cleanup`.

В результате ее работы будут удалены нетегированные docker-образы, только связанные с данным проектом. Технически dapp может идентифицировать эти образы по специальной метке, которая проставляется на все образы, создаваемые при сборке.

## Принудительная очистка кэша приложения

Если требуется принудительно сбросить сборочный кэш приложения, есть отдельная подкоманда flush:

* `dapp dimg stages flush local` — локально;
* `dapp dimg stages flush repo REPO` — в registry `REPO`.

*Подсказка*. Cleanup — очистка лишнего. Flush — принудительный сброс.

## Очистка кэша в режиме разработчика

Для режима разработчика существует опция `--dev`, добавляемая во все команды сборки и очистки образов. В этом режиме создается отдельный кэш образов, никак не пересекающийся с обычным кэшем образов. Все описанные команды кроме mrproper применимы и для режима разработчика при дополнительном указании опции `--dev`.

Использование команды [mrproper]({{ site.baseurl }}/reference/cli/dimg_mrproper.html), для удаления docker-образов и docker-контейнеров связанных с dapp и собранных в режиме разработчика, возможно следующим образом:

`dapp dimg mrproper --improper-dev-mode-cache`

## Полная очистка локального хранилища

Для глобального (без привязки к какому-либо проекту) удаления docker-образов и контейнеров в локальном хранилище docker образов, можно воспользоваться командой `dapp dimg mrproper`:
- `dapp dimg mrproper --all` - удалит весь dapp кэш, т.е. вообще все образы созданные dapp в локальном хранилище, а также соответствующие контейнеры;
- `dapp dimg mrproper --improper-cache-version-stages` - сделает то-же самое, но только для образов и контейнеров, созданных более старыми версиями dapp;
- `dapp dimg mrproper --improper-dev-mode-cache` - удалит образы и контейнеры созданные в режиме разработчика во всех проектах.

## Автоматическая очистка по политикам

При работе dapp совместно с [GitLab CI](https://about.gitlab.com/), в dapp существует механизм, позволяющий автоматизировать очистку удаленного хранилища docker образов. В логику работы очистки заложены определенные правила (политики), по которым принимается решение об удалении образа, и которые необходимо понимать. Также, корректная работа очистки требует предварительного выполнения ряда условий, без выполнения которых очистка не будет приводить к нужному результату.

Механизм очистки определяет какие образы необходимо удалить на основании анализа:
- **ветки**, **тега** или **коммита** в git-репозитории, из которого был собран образ;
- **кластеров kubernetes**, до которых настроен доступ в kubectl.

Подробнее о правилах, используемых при запуске команды очистки:
* **по веткам:**
    * образ, собранный для ветки обновляется в registry при каждом новом коммите (docker-тег для одной ветки один и тот же);
    * при отсутствии ветки в git (ветка, из которой собирался образ, удалена), соответствующий образ удаляется из docker registry (соответственно, при запуске команды очистки, из docker registry будут удалены все образы, для которых уже не существует веток в git);
    * пока в git есть ветка, связанная с образом, образ не удаляется из docker registry;
    * в эту категорию попадают образы, протегированные с тегом `--tag-ci` или `--tag-branch`.
* **по коммитам:**
    * при отсутствии коммита в git (к примеру, после выполнения rebase), соответствующий образ удаляется из docker registry;
    * для оставшихся образов применяются политики `GIT_COMMITS_EXPIRY_DATE_PERIOD_POLICY` и `GIT_COMMITS_LIMIT_POLICY`:
       * исходя из времени загрузки образов в registry, удаляются образы **превышающие период в 30 дней** (значение можно переопределить, указав произвольный период в секундах в переменной окружения `GIT_COMMITS_EXPIRY_DATE_PERIOD_POLICY`);
       * исходя из времени загрузки образов в registry, из оставшихся остаются только **50 последних образов** (значение можно переопределить, указав произвольное количество в переменной окружения `GIT_COMMITS_LIMIT_POLICY`).
    * в эту категорию попадают образы, протегированные с тегом `--tag-commit`.
* **по тегам:**
    * при отсутствии тега в git, соответствующий образ удаляется из docker registry;
    * для оставшихся образов применяются политики `EXPIRY_DATE_PERIOD_POLICY` и `GIT_TAGS_LIMIT_POLICY`:
      * исходя из времени загрузки образов в registry, удаляются образы **превышающие период в 30 дней** (значение можно переопределить, указав произвольный период в секундах в переменной окружения `EXPIRY_DATE_PERIOD_POLICY`);
       * исходя из времени загрузки образов в registry, из оставшихся остаются только **10 последних образов** (значение можно переопределить, указав произвольное количество в переменной окружения `GIT_TAGS_LIMIT_POLICY`).
    * в эту категорию попадают образы, протегированные с тегом `--tag-ci`.
* **по кластерам kubernetes:**
    * не удаляются те образы, которые используются в кластерах kubernetes. В кластерах, до которых настроен доступ в kubectl, сканируются все объекты типа - pod, deployment, replicaset, statefulset, daemonset, job, cronjob, replicationcontroller;
    * данный функционал можно при необходимости отключить опцией `--without-kube`.

**Очистка применяется только к образам, собранным dapp и протегированным с опциями `--tag-ci` ([GitLab CI](https://about.gitlab.com/)), `--tag-branch` или `--tag-commit`**. Если в docker registry есть другие образы, то с ними никаких действий предпринято не будет.

### Как настроить

Для каждого проекта:
* обязательно использовать `--tag-ci`, `--tag-branch` или `--tag-commit` опцию при вызове команд `dapp dimg bp` и `dapp dimg push` (при тегировании в конечном образе сохраняется дополнительная информация, используемая при чистке registry). Без выполнения этого условия **очистка работать не будет**, образы будут проигнорированы.
* очистка docker registry проекта от устаревших образов, загруженных без использования соответствующих тегов, не приведёт к их удалению.

После выполнения этих шагов, можно использовать команду `dapp dimg cleanup repo <repo>` для автоматической очистки по политикам docker-registry данного проекта.

### Как использовать

Для использования очистки нужно:
* создать `Personal Access Tokens` с необходимыми правами и обеспечить его наличие в переменной окружения `DAPP_DIMG_CLEANUP_REGISTRY_PASSWORD` (см. ниже);
* исправить `.gitlab-ci.yaml` для запуска очистки в два этапа:
    * очистка удаленного docker registry командой `dapp dimg cleanup repo $CI_REGISTRY_IMAGE`;
    * локальная очистка командой
```
dapp dimg stages cleanup local \
    --improper-cache-version \
    --improper-git-commit \
    --improper-repo-cache $CI_REGISTRY_IMAGE
```
* настроить периодический запуск pipeline в GitLab, выполняющего очистку.

**Важно:** Порядок запуска очистки сначала удаленного, затем локального хранилища важен, и обусловлен тем, что при работе локальной очистки удаленный docker registry является первичным источником информации, на основании которой содержимое локального хранилища образов на сборочном сервере синхронизируются с содержимым удаленного docker registry. Таким образом, автоматическая очистка по политикам выполняет непосредственное удаление образов в удаленном хранилище, а затем, на втором этапе, происходит синхронизация изменений с локальным хранилищем.

Т.к. запуск задания в GitLab со стандартными правами на основе `CI_JOB_TOKEN` не даст необходимых для очистки прав, при запуске очистки необходимо обеспечить наличие переменной окружения `DAPP_DIMG_CLEANUP_REGISTRY_PASSWORD=<token>`, где `<token>`, - это:
* `Personal Access Tokens` пользователя с правами не ниже `Developer` на проект GitLab, в котором будет осуществляться чистка;
* у этого token установлен `Scopes` - `api` (указать `Scopes` можно при создании `Personal Access Tokens` в разделе `Settings` -> `Access Tokens` пользователя GitLab).

Переменную `DAPP_DIMG_CLEANUP_REGISTRY_PASSWORD=<token>` нужно установить в переменных проекта в GitLab (`Settings` -> `CI / CD` -> `Variables`). Т.о. данная переменная будет доступна при обычном запуске pipeline и выполнении других операций dapp, но использоваться будет только для команды `dapp dimg cleanup repo`.

Для добавления заданий по очистке в pipeline проекта, необходимо в `.gitlab-ci.yaml` внести соответствующие изменения, обеспечивающие запуск в нужном порядке dapp для очистки сначала удаленного, затем локального хранилища. Поскольку при выполнении команды `dapp dimg cleanup repo` осуществляется анализ объектов кластера kubernetes, запускать ее необходимо на том `gitlab-runner`, у которого настроен доступ к кластерам через kubectl.

Dapp берет информацию о подключении к кластеру в следующем порядке:
* из переменной `KUBECONFIG`;
* вызывая команду `kubectl config view`;
* из файла `~/.kube/config`.

При вызове команды `dapp dimg cleanup repo REPO` dapp всегда сканирует **каждый из контекстов** kube-config на наличие используемых в данный момент в кластерах kubernetes образов.

Приведем пример `.gitlab-ci.yaml`, когда для сборки и выката приложений в GitLab используются два разных `gitlab-runner` (соответственно с тегами - build для сборки, и deploy - для выката).

```
Cleanup docker registry:
  stage: cleanup-docker-registry
  script:
    - dapp dimg cleanup repo $CI_REGISTRY_IMAGE
  retry: 2
  only:
    - schedules
  tags:
    - deploy

Cleanup build cache:
  stage: cleanup-build-cache
  script:
    - dapp dimg stages cleanup local --improper-cache-version --improper-git-commit --improper-repo-cache $CI_REGISTRY_IMAGE
  retry: 2
  only:
    - schedules
  tags:
    - build
```

В приведенном примере, оба задания запускаются только при запуске запланированного задания (`only: schedules` в `.gitlab-ci.yaml`). Создать такое задание в GitLab можно в разделе `CI/CD` -> `Schedules`, выбрав `New Schedule`. Подробнее с созданием заданий в GitLab можно ознакомиться в [соответствующем разделе](https://docs.gitlab.com/ee/user/project/pipelines/schedules.html) документации GitLab.

Если вам не нужно, чтобы запланированное задание запускало другие задания pipeline, то добавьте в их описание в `.gitlab-ci.yaml` конструкцию `except: [schedules]`. Пример:
```
Build:
  stage: build
  script:
    - dapp dimg bp --tag-ci ${CI_REGISTRY_IMAGE}
  retry: 2
  tags:
    - build
  except:
    - schedules
```

Если в вашем проекте для сборки используются несколько `gitlab-runner`, то и соответствующих заданий (в примере, это - "Cleanup build cache") должно быть несколько, с соответствующими тегами gitlab-runner'ов.

## Очистка кэша из build-директории

Кэш из build-директории включает в себя:

* Git-bare репозитории удалённых git-артефактов.
* Кэш для примонтированных сборочных директорий с использованием опции `from :build_dir` (подробнее о [кэшировании]({{ site.baseurl }}/not_used/cache_for_advanced_build.html)).

Для очистки данного кэша — достаточно удалить build директорию `~/.dapp/builds/<dapp name>` (директория может быть переопределена с помощью опции [--build-dir]({{ site.baseurl }}/reference/cli/dimg_build.html)).
