---
title: Использование артефактов
sidebar: reference
permalink: artifact.html
folder: directive
---

Артефакт (artifact) — это набор правил для сборки образа с файловым ресурсом (образа артефакта), который затем используется в одном или нескольких образах приложений. Образ артефакта не используется и не остается после окончания процесса сборки образов приложений, он нужен для изолирования процесса сборки ресурсов, или инструментов сборки (среды, программного обеспечение, данных) от процесса сборки образов приложений, использующих эти ресурсы или инструменты.

Количество артефактов, описываемых в одном dappfile строго не ограничено

Основное различие при использовании разного синтаксиса dappfile в части описания артефактов - в случае с YAML синтаксисом доступен только импорт артефакта, в случае же с ruby синтаксисом, доступен как вариант описания импорта артефакта в образ приложения так и описание экспорта артефакта из образа артефакта.

## Правила использования

* пути добавления не должны пересекаться между артефактами
* изменение любого параметра артефакта ведёт к смене сигнатур, пересборке связанных [стадий](stages.html#стадия) приложения
* приложение может содержать любое количество артефактов
* артефакты обязаны иметь имя
* имена образов приложений и образов артефактов должны различаться


## YAML синтаксис (dappfile.yml)

Описание образа артефакта выполняется с помощью директивы `artifact: <name>`, где `<name>` - обязательное имя артефакта. Имя артефакта используется для указания артефакта по имени в описании образа приложения, при импорте файлов из артефакта в образ приложения. При использовании YAML синтаксиса доступен только импорт из артефакта (отсутствует директива `export`).

Указание базового образа при описании образа приложения или образа артефакта выполняется с помощью обязательной директивы `from: <DOCKER_IMAGE>`, где `<DOCKER_IMAGE>` - имя образа в формате `image:tag` (tag может отсутствовать, тогда используется latest). Как и при описании образов приложений, описание нескольких образов артефактов выполняется линейно - друг за другом, отделяются строкой состоящей из последовательности `---` (согласно YAML спецификации).

Использование артефакта в образе приложения описывается с помощью директивы `import:`, которая представляет собой массив следующих элементов:
* `artifact: ARTIFACT_NAME`, где `ARTIFACT_NAME` - имя артефакта, из которого необходимо скопировать файлы в образ приложения;
* `add: SOURCE_DIRECTORY_TO_IMPORT`, где `SOURCE_DIRECTORY_TO_IMPORT` - путь в образе артефакта к файлу или папке, которые должны быть скопированы в образ приложения;
* `to: DESTINATION_DIRECTORY`, где `DESTINATION_DIRECTORY` - путь в образе приложения, куда должны быть скопированы файлы из образа артефакта. Необязательный элемент, в случае отсутствия принимается равным значению `SOURCE_DIRECTORY_TO_IMPORT`;
* `before: STAGE | after: STAGE`, где `STAGE` - стадия `install` или `setup`, соответственно до (`before`) или после (`after`) которой необходимо импортировать файлы артефакта в образ.

### Пример использования артефакта
```
import:
- artifact: application-assets
  add: /app/public/assets
  after: install
- artifact: application-assets
  add: /vendor
  to: /app/vendor
  before: setup
```

### Пример описания образа приложения с использованием артефакта

В следующем примере используется описание образа приложения и образа артефакта. В артефакте создается файл, который импортируется в образ `application`, и на стадии setup выводится его содержимое.

```
artifact: assets
from: alpine
shell:
  install:
  - mkdir /tmp/asset-files
  - echo 'Artifact file for import' >/tmp/asset-files/asset
---
dimg: application
from: ubuntu:16.04
import:
  - artifact: assets
    add: /tmp/asset-files
    to: /app
    after: install
shell:
  setup:
    - cat /app/asset
```

## Ruby синтаксис (Dappfile)

Для добавления артефакта можно использовать директиву export или директиву import.

Директива `git [<url>]` позволяет определить один или несколько git-артефактов.

* Поддерживается два типа git-артефактов, local и remote.
* Необязательный параметр \<url\> соответствует адресу удалённого git-репозитория (remote).
* Для добавления git-артефакта необходимо использовать поддирективу add.
  * Принимает параметр \<cwd\> (по умолчанию используется '\\').
  * Параметры \<include_paths\>, \<exclude_paths\>, \<owner\>, \<group\>, \<to\> определяются в контексте.
  * Параметры \<branch\>, \<commit\> могут быть определены в контексте remote git-артефакта.
* В контексте директивы можно указать базовые параметры git-артефактов, которые могут быть переопределены в контексте каждого из них.
  * \<owner\>.
  * \<group\>.
  * \<branch\>.
  * \<commit\>.

### Параметры артефакта

#### Общие
* to: абсолютный путь, в который будут копироваться ресурсы.
* cwd: абсолютный путь, определяет рабочую директорию.
* include_paths: добавить только указанные относительные пути.
* exclude_paths: игнорировать указанные относительные пути.
* owner: определить пользователя.
* group: определить группу.
* Принимает параметр \<cwd\> (по умолчанию используется путь \<to\>).
* Параметры \<include_paths\>, \<exclude_paths\>, \<owner\>, \<group\>, \<to\> определяются в контексте.
* Параметр \<to\> по умолчанию соответствует \<cwd\>.
* Если собирается не scratch: в контексте обязательно использование хотя бы одной из директив **before** или **after**, где:
    * директива определяет порядок применения артефакта (до или после);
    * значение определяет стадию (install или setup).

### Примеры

##### export
```ruby
dimg do
  docker.from 'image:tag'

  artifact do
    shell.build_artifact.run 'command1', 'command2'

    export '/artifact' do
      before 'install'
      to '/app'
    end
  end

  artifact do
    shell.build_artifact.run 'command3', 'command4'

    export '/artifact/assets' do
      after 'setup'
      to '/app'
    end
  end
end
```

##### import
```ruby
dimg do
  docker.from 'image:tag'

  artifact('artifact-a') do
    shell.build_artifact.run 'command1', 'command2'
  end

  artifact('artifact-b') do
    shell.build_artifact.run 'command3', 'command4'
  end

  import('artifact-a', '/artifact') do
    before 'install'
    to '/app'
  end

  import('artifact-b', '/artifact/assets') do
    after 'setup'
    to '/app'
  end
end
```

#### Собрать scratch образ
```ruby
dimg_group do
  artifact do
    docker.from 'image:tag'
    shell.build_artifact.run 'command1', 'command2'

    export '/' do
      to '/app'
    end
  end

  dimg
end
```
