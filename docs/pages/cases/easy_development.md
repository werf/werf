---
title: Упрощение разработки
sidebar: how_to
permalink: easy_development.html
---

Dapp предлагает ряд инструментов для упрощения разработки, которых не предоставляют аналоги.

## Артефакты

Размер конечного образа за счёт инструментов сборки и исходных файлов может увеличиваться в несколько раз, притом что пользователю они не требуются.

Для решения подобных проблем сообщество docker предлагает в одном шаге делать установку инструментов, сборку и удаление инструментов,

```
RUN “download-source && cmd && cmd2 && remove-source”
```

Но при таком использовании не получится использовать кэширование, а это время на постоянную установку инструментария.

dapp предлагает альтернативу в виде приложений артефактов, сборка которых осуществляется по тем же правилам, что и приложений, но с другим набором стадий.

Приложение артефакта используется для изолирования процесса сборки и инструментов сборки (среды, программного обеспечение, данных) ресурсов от образов, использующих эти ресурсы.

```ruby
dimg do
  docker.from 'ubuntu:16.04'

  # определение приложения артефакта
  artifact do
    # добавление исходных файлов и зависимости пересборки артефакта от любого изменения
    git.add do
      to('/app')
      stage_dependencies.build_artifact('*')
    end

    shell do
      # установка инструментов сборки
      install.run('apt-get install build-essentials libmysql-dev')
      # сборка
      build_artifact.run('make -C /app')
    end

    # определение артефакта, импортирование `/app/build` в `/usr/bin` приложения после стадии `setup`
    export('/app/build') do
      to('/usr/bin/app')
      after('setup')
    end
  end
end
```

В таком случае, сборка приложения будет осуществляться в образе артефакта, а в конечный образ попадёт только бинарный файл.

Разница между стадиями заключается в следующем:
* на стадии build\_artifact определяются шаги для сборки артефакта, зависимости от файлов которой можно описать в stage\_dependencies в директиве git;
* за наложение финального патча отвечает стадия g\_a\_artifact\_patch, которая будет собрана только в том случае, если потребуется пересобрать build\_artifact;
* не используется стадия docker\_instruction, так как приложение артефакта является служебным.

При отсутствии зависимостей у стадии build\_artifact артефакт закэшируется после первой сборки и не будет пересобираться.

Стоит отметить, что может быть произвольное количество как приложений артефактов, так и артефактов. Артефактом в данном случае называется директория, которая экспортируется в образ. Т.о. одно приложение артефакта может экспортировать несколько директорий в конечный образ приложения.

Таким образом, с использованием артефактов можно независимо собирать неограниченное количество компонентов, притом также решая следующие проблемы:
* Пересборка происходит при изменении несвязанных данных и подготовка ресурсов занимает значительное время, а приложение можно разделить на несвязанные компоненты.
* Ресурсы необходимо собирать в среде отличающейся от среды приложения.

Артефакты можно использовать и [в ansible и в chef сборщике](artifact.html).

## Отладка при сборке

### Интроспекция стадий в интерактивном режиме

Контролировать результат работы правил сборки образа позволяет возможность интроспекции стадий. Интроспекция представляет собой запуск shell-сессии для пользователя в интерактивном режиме в собираемом образе. При интроспекции стадии, сборочный контейнер и его среда, содержат служебный инструментарий и служебные переменные окружения. Служебный инструментарий представляет собой набор специальных утилит, необходимых для сборки (его добавление осуществляется монтированием директорий из служебных контейнеров дистрибутивов dappdeps - в сборочном контейнере они доступны по пути /.dapp/deps).

В общем случае, если падает набор команд, создающих образ стадии Y из образа стадии X, то:

Если выполнение набора команд, создающих образ стадии Y из образа стадии X, завершается ошибкой, то:

* c опцией `--introspect-before-error` пользователь попадет в контейнер с образом X;
* с опцией `--introspect-error` пользователь попадет в сборочный контейнер в состоянии сразу после исполнения команды, которая завершилась ошибкой.

Например, есть Dappfile с ошибкой:

```ruby
dimg do
  docker.from 'ubuntu:16.04'

  shell.before_install do
    run 'apt-get update'
  end

  shell.install do
    run 'apt-get install -y nonexistent'
  end
end
```

При запуске сборки dapp упадет с подобным сообщением:

```shell
$ dapp dimg build
From ...                                                                              [OK] 0.95 sec
Before install ...                                                                    [OK] 10.98 sec

Install group
  Install ...   Launched command: `apt-get install -y nonexistent`
                                                                                      [FAILED] 1.93 sec
Stacktrace dumped to /tmp/dapp-stacktrace-736a2035-4c8e-4ee3-9b55-8cfe5b4704a0.out
>>> START STREAM
Reading package lists...

Building dependency tree...

Reading state information...
E: Unable to locate package nonexistent
>>> END STREAM
```

Произошло следующее: при сборке образа стадии Install, выполнение команды `apt-get install -y nonexistent` завершилось ошибкой. При указании команде сборки опции `--introspect-error`, пользователь получает доступ в сборочный контейнер в состоянии сразу после исполнения команды `apt-get install -y nonexistent`:


```shell
$ dapp dimg build --introspect-error
From ...                                                                              [OK] 0.9 sec
Before install ...                                                                    [OK] 10.24 sec
Install group
  Install ...   Launched command: `apt-get install -y nonexistent`
                                                                                      [FAILED] 1.91 sec
root@18ae29cf201a:/# apt-get install -y nonexistent
Reading package lists... Done
Building dependency tree       
Reading state information... Done
E: Unable to locate package nonexistent
root@18ae29cf201a:/# apt-get install -y nginx
...
root@18ae29cf201a:/# exit
Stacktrace dumped to /tmp/dapp-stacktrace-4ecac017-bcaf-4304-b6e7-fe7ca481c7af.out
>>> START STREAM
Reading package lists...

Building dependency tree...

Reading state information...
E: Unable to locate package nonexistent
>>> END STREAM
```

В данном контейнере можно вручную выполнить команды, просмотреть состояние системы и понять в чем проблема.

Если использовать опцию `--introspect-before-error` для команды сборки, то пользователь соответственно получит доступ в сборочный контейнер для стадии, предшествующей стадии Before install. Т.е. ни одна команда для сборки стадии Before install в данном контейнере еще не будет выполнена.

### Интроспекция стадий после успешной сборки

Во время разработки конфигурации, часто требуется запустить сборку, а затем вручную проверить результат сборки стадии. В случае если ошибок при сборке стадии не произошло, для этого используются опции `--introspect-stage=<stage>` для обычного образа и `--introspect-artifact-stage=<stage>` для образа артефакта. Возможно указание лишь одной стадии, для которой нужна интроспекция, но опции интроспекции стадии при возникновении ошибок и интроспекции успешно собранной стадии можно указывать одновременно.

Интроспекция стадий также позволяет прийти к необходимому результату в сборочном контейнере, а затем перенести соответствующие шаги (инструкции) в конфигурацию соответствующей стадии. Такой подход может быть полезен когда поставленная задача ясна, но необходимые для ее решения шаги не очевидны и требуют экспериментов. Также, при использовании интроспекции с [Ansible-сборщиком](ansible_builder.html), появляется возможность отладки Ansible playbooks в сборочном контейнере с последующим переносом Ansible-задач в соответствующие стадии конфигурации.

Возможные значения опции introspect-stage:

* from
* before_install
* before_install_artifact
* g_a_archive
* g_a_pre_install_patch
* install, g_a_post_install_patch
* after_install_artifact
* before_setup
* before_setup_artifact
* g_a_pre_setup_patch
* setup
* g_a_post_setup_patch
* after_setup_artifact
* g_a_latest_patch
* docker_instructions

Возможные значения опции introspect-artifact-stage:

* from
* before_install
* before_install_artifact
* g_a_archive
* g_a_pre_install_patch
* install
* g_a_post_install_patch
* after_install_artifact
* before_setup
* before_setup_artifact
* g_a_pre_setup_patch
* setup
* after_setup_artifact
* g_a_artifact_patch
* build_artifact

### Интроспекция стадий при альтернативной схеме кэширования

Подробней со схемами кэширования можно познакомиться в [соответствующем разделе](cache_for_advanced_build.html#сборочный-кэш-приложения).

В случае использования опции интроспекции `--introspect-before-error` при альтернативной схеме кэширования, пользователь получит среду выполнения предыдущей перед проблемной инструкции, а не предыдущей стадии.

Для включение альтернативной схемы кэширования, в dappfile.yaml необходимо указать `asLayers: true`. При отсутствии директивы `asLayers`, или в случае указания `asLayers: false`, используется кэширование по умолчанию. Переключение между режимами сборки регулируется только директивой `asLayers` — остальные инструкции конфигурации остаются неизменными.

После того, как сборочные инструкции отлажены, `asLayers` необходимо выключить, т.к. альтернативная схема кэширования порождает избыточное количество docker-образов и не рассчитана на инкрементальную сборку (т.к. увеличивается время ожидания и размер сборочного кэша).

### Режим разработчика

Для облегчения и ускорения процесса разработки конфигурации сборки, в dapp предусмотрен специальный режим разработчика, включаемый при использовании опции `--dev`. Особенности режима разработчика:
- работа с текущим состоянием локального репозитория
- отдельный, принудительно сохраняемый, кэш образов.

Работа с текущим состоянием локального репозитория предполагает, что при определении изменений в локальном репозитории, для каждого файла выполняется расчет с учетом его `имени`, `содержания` и `режима доступа`.

При разработке конфигурации, в стандартном режиме сборки необходимо коммитить изменения в git-репозиторий, чтобы dapp учитывал изменения. В режиме разработчика же, dapp при сборке учитывает некоммитнутые изменения локального Git-репозитория (учитываются пути из поддиректив git: add, includePaths, excludePaths, stageDependencies) и необходимости обязательно выполнять коммиты перед сборкой нет. Это может быть удобно, например, если вы на узле сборки вносите изменения в код приложения и хотите сразу же проверить ваши изменения. При добавлении git-submodules и вложенных Git-репозиториев, в режиме разработчика учитываются файлы .gitignore на всех уровнях.

Отдельный кэш образов создаваемый в режиме разработчика, никак не затрагивает обычный кэш образов используемый dapp, а также принудительно сохраняет успешно собранные образы, не смотря на появление ошибок на последующих этапах. Это может быть полезно, если вы хотите внести изменения и проверить сборку, но не хотите влиять на текущий кэш сборки. Также можно выполнять работу в режиме разработчика, чтобы по её завершении удалить только кэш режима разработчика.

Подробнее про кэширование в режиме разработчика рассказано в соответствующем [разделе](cleanup_for_advanced_build.html#очистка-кэша-в-режиме-разработчика).



