<!-- THIS FILE IS AUTOGENERATED BY werf docs COMMAND! DO NOT EDIT! -->

- Complete application lifecycle management: build and publish images, deploy application into Kubernetes and cleanup unused images by policies.
 - Application build and deploy specification (as many components as needed) completely described in one git repository with source code (single source of truth).
 - Build images with Dockerfiles.
 - Alternatively, build images with custom syntax to take advantage of Ansible builder and incremental rebuilds based on git history.
 - Helm 2 compatible chart and complex deploy process with logging, tracking, early errors detection and annotations to customize tracking logic of specific resources.
 - Werf is a CLI tool written in Golang which can be embedded into any existing CI/CD system to implement CI/CD for your application.
 - Cross-platform development: Linux based containers are supported on Linux, macOS, and Windows.

## Coming soon

- ~3-way-merge [#1616](https://github.com/flant/werf/issues/1616).~
- Easy local development of applications with werf [#1940](https://github.com/flant/werf/issues/1940).
- Content addressable tagging scheme [#1184](https://github.com/flant/werf/issues/1184).
- Proven approaches and recipes for most popular CI systems [#1617](https://github.com/flant/werf/issues/1617).
- Distributed builds with common registry [#1614](https://github.com/flant/werf/issues/1614).
- Helm 3 support [#1606](https://github.com/flant/werf/issues/1606).
- Userspace builds without Docker daemon (as in kaniko) [#1618](https://github.com/flant/werf/issues/1618).

## Complete features list

### Building

- Conveniently build as many images as needed for a single project.
- Building images by Dockerfile or Stapel builder instructions.
- Parallel builds on a single host (using file locks).
- Distributed builds (coming soon) [#1614](https://github.com/flant/werf/issues/1614).
- Advanced build with Stapel:
  - Incremental rebuilds based on git history.
  - Building images with Ansible tasks or Shell scripts.
  - Sharing a common cache between builds using mounts.
  - Reducing image size by detaching source data and build tools.
- Building one image from config on the top of another image from the same config.
- Debug tools for build process inspection.
- Detailed output.

### Publishing

- Store images in one or several Docker repositories by the following patterns:
  - `IMAGES_REPO:[IMAGE_NAME-]TAG` using `monorepo` mode.
  - `IMAGES_REPO[/IMAGE_NAME]:TAG` using `multirepo` mode.
- Different image tagging strategies:
  - Tag image by git tag, branch or commit.
  - Content based tagging (coming soon) [#1184](https://github.com/flant/werf/issues/1184).

### Deploy

- Deploy an application into Kubernetes and check that application is deployed correctly.
  - Track all application resources status.
  - Control of resources readiness.
  - Control of the deployment process with annotations.
- Full visibility both of the deploy process and of the final result.
  - Logging and error reporting.
  - Periodical status reports during deploy process.
  - Easy debugging of problems without unnecessary kubectl invocations.
- Fail CI pipeline fast when problem detected.
  - Early resources failures detection during deploy process without need to wait full timeout.
- Full compatibility with Helm 2.
- Ability to limit deploy user access using RBAC definition (Tiller is compiled into Werf and run from the deploy user outside of cluster).
- Parallel deploys on a single host (using file locks).
- Distributed parallel deploys (coming soon) [#1620](https://github.com/flant/werf/issues/1620).
- Allow continuous delivery of new images tagged by the same name (by git branch for example).

### Cleanup

- Local and Docker registry cleaning by customizable policies.
- Keeping images that used in Kubernetes clusters. Werf scans the following kinds of objects: Pod, Deployment, ReplicaSet, StatefulSet, DaemonSet, Job, CronJob, ReplicationController.
