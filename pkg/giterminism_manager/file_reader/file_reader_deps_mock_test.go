// Code generated by MockGen. DO NOT EDIT.
// Source: file_reader.go
//
// Generated by this command:
//
//	mockgen -source file_reader.go -package file_reader_test -destination file_reader_deps_mock_test.go
//

// Package file_reader_test is a generated GoMock package.
package file_reader_test

import (
	context "context"
	os "os"
	filepath "path/filepath"
	reflect "reflect"

	git_repo "github.com/werf/werf/v2/pkg/git_repo"
	path_matcher "github.com/werf/werf/v2/pkg/path_matcher"
	gomock "go.uber.org/mock/gomock"
)

// MockgiterminismConfig is a mock of giterminismConfig interface.
type MockgiterminismConfig struct {
	ctrl     *gomock.Controller
	recorder *MockgiterminismConfigMockRecorder
	isgomock struct{}
}

// MockgiterminismConfigMockRecorder is the mock recorder for MockgiterminismConfig.
type MockgiterminismConfigMockRecorder struct {
	mock *MockgiterminismConfig
}

// NewMockgiterminismConfig creates a new mock instance.
func NewMockgiterminismConfig(ctrl *gomock.Controller) *MockgiterminismConfig {
	mock := &MockgiterminismConfig{ctrl: ctrl}
	mock.recorder = &MockgiterminismConfigMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockgiterminismConfig) EXPECT() *MockgiterminismConfigMockRecorder {
	return m.recorder
}

// IsUncommittedConfigAccepted mocks base method.
func (m *MockgiterminismConfig) IsUncommittedConfigAccepted() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUncommittedConfigAccepted")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsUncommittedConfigAccepted indicates an expected call of IsUncommittedConfigAccepted.
func (mr *MockgiterminismConfigMockRecorder) IsUncommittedConfigAccepted() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUncommittedConfigAccepted", reflect.TypeOf((*MockgiterminismConfig)(nil).IsUncommittedConfigAccepted))
}

// IsUncommittedDockerfileAccepted mocks base method.
func (m *MockgiterminismConfig) IsUncommittedDockerfileAccepted(relPath string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUncommittedDockerfileAccepted", relPath)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsUncommittedDockerfileAccepted indicates an expected call of IsUncommittedDockerfileAccepted.
func (mr *MockgiterminismConfigMockRecorder) IsUncommittedDockerfileAccepted(relPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUncommittedDockerfileAccepted", reflect.TypeOf((*MockgiterminismConfig)(nil).IsUncommittedDockerfileAccepted), relPath)
}

// IsUncommittedDockerignoreAccepted mocks base method.
func (m *MockgiterminismConfig) IsUncommittedDockerignoreAccepted(relPath string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUncommittedDockerignoreAccepted", relPath)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsUncommittedDockerignoreAccepted indicates an expected call of IsUncommittedDockerignoreAccepted.
func (mr *MockgiterminismConfigMockRecorder) IsUncommittedDockerignoreAccepted(relPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUncommittedDockerignoreAccepted", reflect.TypeOf((*MockgiterminismConfig)(nil).IsUncommittedDockerignoreAccepted), relPath)
}

// UncommittedConfigGoTemplateRenderingFilePathMatcher mocks base method.
func (m *MockgiterminismConfig) UncommittedConfigGoTemplateRenderingFilePathMatcher() path_matcher.PathMatcher {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UncommittedConfigGoTemplateRenderingFilePathMatcher")
	ret0, _ := ret[0].(path_matcher.PathMatcher)
	return ret0
}

// UncommittedConfigGoTemplateRenderingFilePathMatcher indicates an expected call of UncommittedConfigGoTemplateRenderingFilePathMatcher.
func (mr *MockgiterminismConfigMockRecorder) UncommittedConfigGoTemplateRenderingFilePathMatcher() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UncommittedConfigGoTemplateRenderingFilePathMatcher", reflect.TypeOf((*MockgiterminismConfig)(nil).UncommittedConfigGoTemplateRenderingFilePathMatcher))
}

// UncommittedConfigTemplateFilePathMatcher mocks base method.
func (m *MockgiterminismConfig) UncommittedConfigTemplateFilePathMatcher() path_matcher.PathMatcher {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UncommittedConfigTemplateFilePathMatcher")
	ret0, _ := ret[0].(path_matcher.PathMatcher)
	return ret0
}

// UncommittedConfigTemplateFilePathMatcher indicates an expected call of UncommittedConfigTemplateFilePathMatcher.
func (mr *MockgiterminismConfigMockRecorder) UncommittedConfigTemplateFilePathMatcher() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UncommittedConfigTemplateFilePathMatcher", reflect.TypeOf((*MockgiterminismConfig)(nil).UncommittedConfigTemplateFilePathMatcher))
}

// UncommittedHelmFilePathMatcher mocks base method.
func (m *MockgiterminismConfig) UncommittedHelmFilePathMatcher() path_matcher.PathMatcher {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UncommittedHelmFilePathMatcher")
	ret0, _ := ret[0].(path_matcher.PathMatcher)
	return ret0
}

// UncommittedHelmFilePathMatcher indicates an expected call of UncommittedHelmFilePathMatcher.
func (mr *MockgiterminismConfigMockRecorder) UncommittedHelmFilePathMatcher() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UncommittedHelmFilePathMatcher", reflect.TypeOf((*MockgiterminismConfig)(nil).UncommittedHelmFilePathMatcher))
}

// MocksharedOptions is a mock of sharedOptions interface.
type MocksharedOptions struct {
	ctrl     *gomock.Controller
	recorder *MocksharedOptionsMockRecorder
	isgomock struct{}
}

// MocksharedOptionsMockRecorder is the mock recorder for MocksharedOptions.
type MocksharedOptionsMockRecorder struct {
	mock *MocksharedOptions
}

// NewMocksharedOptions creates a new mock instance.
func NewMocksharedOptions(ctrl *gomock.Controller) *MocksharedOptions {
	mock := &MocksharedOptions{ctrl: ctrl}
	mock.recorder = &MocksharedOptionsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocksharedOptions) EXPECT() *MocksharedOptionsMockRecorder {
	return m.recorder
}

// Dev mocks base method.
func (m *MocksharedOptions) Dev() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Dev")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Dev indicates an expected call of Dev.
func (mr *MocksharedOptionsMockRecorder) Dev() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dev", reflect.TypeOf((*MocksharedOptions)(nil).Dev))
}

// HeadCommit mocks base method.
func (m *MocksharedOptions) HeadCommit(ctx context.Context) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HeadCommit", ctx)
	ret0, _ := ret[0].(string)
	return ret0
}

// HeadCommit indicates an expected call of HeadCommit.
func (mr *MocksharedOptionsMockRecorder) HeadCommit(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HeadCommit", reflect.TypeOf((*MocksharedOptions)(nil).HeadCommit), ctx)
}

// LocalGitRepo mocks base method.
func (m *MocksharedOptions) LocalGitRepo() git_repo.GitRepo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LocalGitRepo")
	ret0, _ := ret[0].(git_repo.GitRepo)
	return ret0
}

// LocalGitRepo indicates an expected call of LocalGitRepo.
func (mr *MocksharedOptionsMockRecorder) LocalGitRepo() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LocalGitRepo", reflect.TypeOf((*MocksharedOptions)(nil).LocalGitRepo))
}

// LooseGiterminism mocks base method.
func (m *MocksharedOptions) LooseGiterminism() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LooseGiterminism")
	ret0, _ := ret[0].(bool)
	return ret0
}

// LooseGiterminism indicates an expected call of LooseGiterminism.
func (mr *MocksharedOptionsMockRecorder) LooseGiterminism() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LooseGiterminism", reflect.TypeOf((*MocksharedOptions)(nil).LooseGiterminism))
}

// ProjectDir mocks base method.
func (m *MocksharedOptions) ProjectDir() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProjectDir")
	ret0, _ := ret[0].(string)
	return ret0
}

// ProjectDir indicates an expected call of ProjectDir.
func (mr *MocksharedOptionsMockRecorder) ProjectDir() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProjectDir", reflect.TypeOf((*MocksharedOptions)(nil).ProjectDir))
}

// RelativeToGitProjectDir mocks base method.
func (m *MocksharedOptions) RelativeToGitProjectDir() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RelativeToGitProjectDir")
	ret0, _ := ret[0].(string)
	return ret0
}

// RelativeToGitProjectDir indicates an expected call of RelativeToGitProjectDir.
func (mr *MocksharedOptionsMockRecorder) RelativeToGitProjectDir() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RelativeToGitProjectDir", reflect.TypeOf((*MocksharedOptions)(nil).RelativeToGitProjectDir))
}

// MockfileSystem is a mock of fileSystem interface.
type MockfileSystem struct {
	ctrl     *gomock.Controller
	recorder *MockfileSystemMockRecorder
	isgomock struct{}
}

// MockfileSystemMockRecorder is the mock recorder for MockfileSystem.
type MockfileSystemMockRecorder struct {
	mock *MockfileSystem
}

// NewMockfileSystem creates a new mock instance.
func NewMockfileSystem(ctrl *gomock.Controller) *MockfileSystem {
	mock := &MockfileSystem{ctrl: ctrl}
	mock.recorder = &MockfileSystemMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockfileSystem) EXPECT() *MockfileSystemMockRecorder {
	return m.recorder
}

// DirExists mocks base method.
func (m *MockfileSystem) DirExists(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DirExists", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DirExists indicates an expected call of DirExists.
func (mr *MockfileSystemMockRecorder) DirExists(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DirExists", reflect.TypeOf((*MockfileSystem)(nil).DirExists), path)
}

// FileExists mocks base method.
func (m *MockfileSystem) FileExists(p string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileExists", p)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileExists indicates an expected call of FileExists.
func (mr *MockfileSystemMockRecorder) FileExists(p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileExists", reflect.TypeOf((*MockfileSystem)(nil).FileExists), p)
}

// IsNotExist mocks base method.
func (m *MockfileSystem) IsNotExist(err error) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsNotExist", err)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsNotExist indicates an expected call of IsNotExist.
func (mr *MockfileSystemMockRecorder) IsNotExist(err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsNotExist", reflect.TypeOf((*MockfileSystem)(nil).IsNotExist), err)
}

// Lstat mocks base method.
func (m *MockfileSystem) Lstat(name string) (os.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lstat", name)
	ret0, _ := ret[0].(os.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lstat indicates an expected call of Lstat.
func (mr *MockfileSystemMockRecorder) Lstat(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lstat", reflect.TypeOf((*MockfileSystem)(nil).Lstat), name)
}

// ReadFile mocks base method.
func (m *MockfileSystem) ReadFile(filename string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFile", filename)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFile indicates an expected call of ReadFile.
func (mr *MockfileSystemMockRecorder) ReadFile(filename any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFile", reflect.TypeOf((*MockfileSystem)(nil).ReadFile), filename)
}

// Readlink mocks base method.
func (m *MockfileSystem) Readlink(name string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Readlink", name)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Readlink indicates an expected call of Readlink.
func (mr *MockfileSystemMockRecorder) Readlink(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Readlink", reflect.TypeOf((*MockfileSystem)(nil).Readlink), name)
}

// RegularFileExists mocks base method.
func (m *MockfileSystem) RegularFileExists(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegularFileExists", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RegularFileExists indicates an expected call of RegularFileExists.
func (mr *MockfileSystemMockRecorder) RegularFileExists(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegularFileExists", reflect.TypeOf((*MockfileSystem)(nil).RegularFileExists), path)
}

// Walk mocks base method.
func (m *MockfileSystem) Walk(root string, fn filepath.WalkFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Walk", root, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// Walk indicates an expected call of Walk.
func (mr *MockfileSystemMockRecorder) Walk(root, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Walk", reflect.TypeOf((*MockfileSystem)(nil).Walk), root, fn)
}
